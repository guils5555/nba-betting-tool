<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ü§ñ Automated NFL & NBA Bet Finder v3.0-ML</title>
    
    <!-- TensorFlow.js for Machine Learning -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0/dist/tf.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        
        .header h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 16px;
        }
        
        .card {
            background: white;
            border-radius: 16px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .tab {
            flex: 1;
            min-width: 150px;
            padding: 12px;
            background: white;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .tab.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .btn {
            padding: 15px 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
            width: 100%;
        }
        
        .btn:hover {
            transform: translateY(-2px);
        }
        
        .btn:active {
            transform: scale(0.98);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .bet-card {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
        }
        
        .bet-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .player-name {
            font-size: 20px;
            font-weight: bold;
        }
        
        .confidence-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }
        
        .confidence-high {
            background: #4ade80;
            color: #065f46;
        }
        
        .confidence-medium {
            background: #fbbf24;
            color: #78350f;
        }
        
        .confidence-low {
            background: #94a3b8;
            color: #1e293b;
        }
        
        .bet-details {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255,255,255,0.3);
        }
        
        .bet-stat {
            display: flex;
            flex-direction: column;
        }
        
        .bet-stat-label {
            font-size: 12px;
            opacity: 0.9;
            margin-bottom: 4px;
        }
        
        .bet-stat-value {
            font-size: 18px;
            font-weight: bold;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .game-selector {
            margin-bottom: 20px;
        }
        
        .game-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .game-card:hover {
            background: #e9ecef;
            transform: translateX(5px);
        }
        
        .game-card.selected {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .game-teams {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .game-time {
            font-size: 14px;
            opacity: 0.8;
        }
        
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }
        
        .empty-state h3 {
            margin-bottom: 10px;
            color: #333;
        }
        
        input, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 15px;
        }
        
        /* Sport Switcher Styles */
        .sport-switcher {
            display: flex;
            gap: 15px;
            justify-content: center;
            max-width: 400px;
            margin: 20px auto;
        }
        
        .sport-btn {
            flex: 1;
            padding: 12px 30px;
            border: 2px solid white;
            background: transparent;
            color: white;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .sport-btn:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-2px);
        }
        
        .sport-btn.active {
            background: white;
            color: #667eea;
            box-shadow: 0 4px 12px rgba(255,255,255,0.3);
            transform: scale(1.05);
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ü§ñ Automated Bet Finder</h1>
            <p>AI-powered edge detection with live odds</p>
            <p style="font-size: 11px; opacity: 0.7; margin-top: 5px;">v3.0-ML ‚Ä¢ Context Adjustments ‚Ä¢ Machine Learning ‚Ä¢ Results Tracking</p>
            
            <!-- Sport Switcher -->
            <div class="sport-switcher">
                <button class="sport-btn active" onclick="switchSport('nfl')" id="nfl-btn">
                    üèà NFL
                </button>
                <button class="sport-btn" onclick="switchSport('nba')" id="nba-btn">
                    üèÄ NBA
                </button>
            </div>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="showTab('quick')">‚ö° Quick Scan</button>
            <button class="tab" onclick="showTab('manual')">‚úèÔ∏è Manual Entry</button>
            <button class="tab" onclick="showTab('parlay')">üé∞ Parlay Builder</button>
            <button class="tab" onclick="showTab('moneyline')">üí∞ Moneyline/Spread</button>
            <button class="tab" onclick="showTab('results')">üìä Results & Tracking</button>
            <button class="tab" onclick="showTab('analytics')">üìà Analytics Dashboard</button>
        </div>
        
        <!-- QUICK SCAN TAB -->
        <div id="quick-tab" class="tab-content active">
            <div class="card">
                <h2 style="margin-bottom: 15px;"><span id="sport-icon">üèà</span> <span id="sport-name">NFL</span> Smart Scanner</h2>
                <p style="color: #666; margin-bottom: 20px;">
                    Automatically fetch and analyze props from FanDuel, DraftKings, and other sportsbooks via The Odds API
                </p>
                
                <!-- API Key Configuration -->
                <div id="api-key-section" style="background: #f3f4f6; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <strong style="color: #1f2937;">üîë The Odds API Key</strong>
                        <a href="https://the-odds-api.com/" target="_blank" style="font-size: 12px; color: #3b82f6;">Get Free Key ‚Üí</a>
                    </div>
                    <input type="text" id="odds-api-key" placeholder="Enter your Odds API key (free tier: 500 requests/month)" 
                           style="width: 100%; padding: 10px; border: 2px solid #d1d5db; border-radius: 6px; font-size: 14px; margin-bottom: 8px;" />
                    <small style="color: #6b7280; font-size: 11px; display: block;">
                        Your key is saved locally in your browser. Get a free key at <a href="https://the-odds-api.com" target="_blank">the-odds-api.com</a> (500 requests/month free)
                    </small>
                </div>
                
                <!-- Scan Settings -->
                <div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <strong style="color: #92400e; display: block; margin-bottom: 10px;">‚öôÔ∏è Scan Settings</strong>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div>
                            <label style="font-size: 12px; color: #78350f; display: block; margin-bottom: 4px;">Min Calibrated Hit Rate</label>
                            <input type="number" id="scan-min-hit-rate" value="55" min="0" max="100" step="5"
                                   style="width: 100%; padding: 8px; border: 2px solid #fbbf24; border-radius: 4px;" />
                        </div>
                        <div>
                            <label style="font-size: 12px; color: #78350f; display: block; margin-bottom: 4px;">Min True Edge (%)</label>
                            <input type="number" id="scan-min-edge" value="10" min="0" max="50" step="1"
                                   style="width: 100%; padding: 8px; border: 2px solid #fbbf24; border-radius: 4px;" />
                        </div>
                    </div>
                    <small style="color: #78350f; font-size: 11px; display: block; margin-top: 8px;">
                        Using calibration factor: <strong>0.854</strong> (multiply predictions by 85.4%)
                    </small>
                </div>
                
                <!-- Scan Buttons -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px;">
                    <button class="btn" onclick="scanTodaysGames()" id="scan-all-btn" style="font-size: 14px; padding: 12px;">
                        üîç Scan All Games Tonight
                    </button>
                    <button class="btn" onclick="scanSpecificGame()" id="scan-game-btn" style="font-size: 14px; padding: 12px; background: linear-gradient(135deg, #10b981 0%, #059669 100%);">
                        üéØ Scan Specific Game
                    </button>
                </div>
                
                <div id="quick-results" style="margin-top: 20px;"></div>
            </div>
        </div>
        
        <!-- MONEYLINE/SPREAD TAB -->
        <div id="moneyline-tab" class="tab-content">
            <div class="card">
                <h2 style="margin-bottom: 15px;"><span id="moneyline-sport-icon">üèà</span> <span id="moneyline-sport-name">NFL</span> Moneyline & Spread Analyzer</h2>
                <p style="color: #666; margin-bottom: 20px;">
                    Analyze game lines and spreads to find betting value on team outcomes
                </p>
                
                <label>Away Team</label>
                <input type="text" id="ml-away-team" placeholder="Los Angeles Lakers" />
                
                <label>Home Team</label>
                <input type="text" id="ml-home-team" placeholder="Boston Celtics" />
                
                <!-- ENHANCED TEAM STATS SECTION -->
                <div style="background: #e0f2fe; border-left: 4px solid #0284c7; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3 style="margin: 0 0 10px 0; color: #0369a1; font-size: 16px;">üìä Team Stats (Manual Entry for Analysis)</h3>
                    <p style="font-size: 12px; color: #075985; margin-bottom: 15px;">
                        Enter team statistics to calculate win probability and projected scores. More accurate data = better projections!
                    </p>
                    
                    <!-- RECORDS -->
                    <div style="background: white; padding: 15px; border-radius: 6px; margin-bottom: 15px;">
                        <h4 style="margin: 0 0 10px 0; color: #333; font-size: 14px;">üìà Season Records</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                            <div>
                                <label style="font-size: 13px; color: #666;">Away Team Record (W-L)</label>
                                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 8px; align-items: center;">
                                    <input type="number" id="ml-away-wins" placeholder="25" min="0" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;" />
                                    <span style="color: #666;">-</span>
                                    <input type="number" id="ml-away-losses" placeholder="18" min="0" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;" />
                                </div>
                            </div>
                            <div>
                                <label style="font-size: 13px; color: #666;">Home Team Record (W-L)</label>
                                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 8px; align-items: center;">
                                    <input type="number" id="ml-home-wins" placeholder="32" min="0" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;" />
                                    <span style="color: #666;">-</span>
                                    <input type="number" id="ml-home-losses" placeholder="11" min="0" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;" />
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- RECENT FORM -->
                    <div style="background: white; padding: 15px; border-radius: 6px; margin-bottom: 15px;">
                        <h4 style="margin: 0 0 10px 0; color: #333; font-size: 14px;">üî• Recent Form (Last 10 Games)</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                            <div>
                                <label style="font-size: 13px; color: #666;">Away Team Last 10 (W-L)</label>
                                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 8px; align-items: center;">
                                    <input type="number" id="ml-away-form-wins" placeholder="7" min="0" max="10" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;" />
                                    <span style="color: #666;">-</span>
                                    <input type="number" id="ml-away-form-losses" placeholder="3" min="0" max="10" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;" />
                                </div>
                            </div>
                            <div>
                                <label style="font-size: 13px; color: #666;">Home Team Last 10 (W-L)</label>
                                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 8px; align-items: center;">
                                    <input type="number" id="ml-home-form-wins" placeholder="9" min="0" max="10" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;" />
                                    <span style="color: #666;">-</span>
                                    <input type="number" id="ml-home-form-losses" placeholder="1" min="0" max="10" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px;" />
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- SCORING STATS -->
                    <div style="background: white; padding: 15px; border-radius: 6px; margin-bottom: 15px;">
                        <h4 style="margin: 0 0 10px 0; color: #333; font-size: 14px;">‚ö° Scoring Averages</h4>
                        
                        <!-- Input Method Toggle -->
                        <div style="margin-bottom: 15px; padding: 10px; background: #f8fafc; border-radius: 6px;">
                            <label style="font-size: 12px; color: #666; margin-bottom: 8px; display: block;">Input Method:</label>
                            <div style="display: flex; gap: 10px;">
                                <label style="font-size: 13px; color: #333; cursor: pointer;">
                                    <input type="radio" name="ml-scoring-method" value="ppg" checked onchange="toggleScoringMethod(this.value)" style="margin-right: 5px;">
                                    Per Game (PPG)
                                </label>
                                <label style="font-size: 13px; color: #333; cursor: pointer;">
                                    <input type="radio" name="ml-scoring-method" value="total" onchange="toggleScoringMethod(this.value)" style="margin-right: 5px;">
                                    Total Points (NFL format)
                                </label>
                            </div>
                        </div>
                        
                        <!-- Per Game Input (Default) -->
                        <div id="ml-ppg-inputs" style="display: block;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                <div>
                                    <label style="font-size: 13px; color: #666;">Away Team PPG (Points Per Game)</label>
                                    <input type="number" step="0.1" id="ml-away-ppg" placeholder="28.5" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; width: 100%;" />
                                </div>
                                <div>
                                    <label style="font-size: 13px; color: #666;">Home Team PPG</label>
                                    <input type="number" step="0.1" id="ml-home-ppg" placeholder="30.1" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; width: 100%;" />
                                </div>
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
                                <div>
                                    <label style="font-size: 13px; color: #666;">Away Team PA/G (Points Allowed)</label>
                                    <input type="number" step="0.1" id="ml-away-papg" placeholder="19.2" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; width: 100%;" />
                                </div>
                                <div>
                                    <label style="font-size: 13px; color: #666;">Home Team PA/G</label>
                                    <input type="number" step="0.1" id="ml-home-papg" placeholder="20.5" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; width: 100%;" />
                                </div>
                            </div>
                        </div>
                        
                        <!-- Total Points Input (NFL Format) -->
                        <div id="ml-total-inputs" style="display: none;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                                <div>
                                    <label style="font-size: 13px; color: #666;">Games Played</label>
                                    <input type="number" id="ml-games-played" placeholder="17" value="17" min="1" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; width: 100%;" />
                                </div>
                                <div style="grid-column: span 2;"></div>
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                <div>
                                    <label style="font-size: 13px; color: #666;">Away Points For (Total)</label>
                                    <input type="number" id="ml-away-pf" placeholder="485" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; width: 100%;" />
                                </div>
                                <div>
                                    <label style="font-size: 13px; color: #666;">Home Points For (Total)</label>
                                    <input type="number" id="ml-home-pf" placeholder="512" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; width: 100%;" />
                                </div>
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
                                <div>
                                    <label style="font-size: 13px; color: #666;">Away Points Against (Total)</label>
                                    <input type="number" id="ml-away-pa" placeholder="327" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; width: 100%;" />
                                </div>
                                <div>
                                    <label style="font-size: 13px; color: #666;">Home Points Against (Total)</label>
                                    <input type="number" id="ml-home-pa" placeholder="349" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; width: 100%;" />
                                </div>
                            </div>
                            <div style="font-size: 11px; color: #666; margin-top: 8px; font-style: italic;">
                                üí° Enter total points from NFL.com stats - PPG will be calculated automatically
                            </div>
                        </div>
                    </div>
                    
                    <!-- REST & INJURIES -->
                    <div style="background: white; padding: 15px; border-radius: 6px;">
                        <h4 style="margin: 0 0 10px 0; color: #333; font-size: 14px;">üí§ Rest & Injuries</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 10px;">
                            <div>
                                <label style="font-size: 13px; color: #666;">Away Team Rest Days</label>
                                <select id="ml-away-rest" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; width: 100%;">
                                    <option value="0">0 days (back-to-back)</option>
                                    <option value="1" selected>1 day</option>
                                    <option value="2">2 days</option>
                                    <option value="3">3 days</option>
                                    <option value="4">4+ days</option>
                                </select>
                            </div>
                            <div>
                                <label style="font-size: 13px; color: #666;">Home Team Rest Days</label>
                                <select id="ml-home-rest" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 13px; width: 100%;">
                                    <option value="0">0 days (back-to-back)</option>
                                    <option value="1" selected>1 day</option>
                                    <option value="2">2 days</option>
                                    <option value="3">3 days</option>
                                    <option value="4">4+ days</option>
                                </select>
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                            <div>
                                <label style="font-size: 13px; color: #666;">Away Team Key Injuries</label>
                                <textarea id="ml-away-injuries" placeholder="e.g., Bo Nix QB (OUT)&#10;or Anthony Davis (OUT) - 25 PPG&#10;or None" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px; width: 100%; min-height: 60px; font-family: inherit; resize: vertical;"></textarea>
                                <small style="font-size: 11px; color: #666; display: block; margin-top: 4px;">
                                    üí° Include position (QB, RB, WR) and status (OUT) for accurate impact analysis
                                </small>
                            </div>
                            <div>
                                <label style="font-size: 13px; color: #666;">Home Team Key Injuries</label>
                                <textarea id="ml-home-injuries" placeholder="e.g., None" style="padding: 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 12px; width: 100%; min-height: 60px; font-family: inherit; resize: vertical;"></textarea>
                                <small style="font-size: 11px; color: #666; display: block; margin-top: 4px;">
                                    üí° Format: "Player Name POSITION (OUT)" for best results
                                </small>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; padding: 10px; background: #fef3c7; border-radius: 6px; border-left: 4px solid #f59e0b;">
                        <p style="margin: 0; font-size: 12px; color: #92400e;">
                            üí° <strong>Tip:</strong> Get stats from ESPN, Basketball-Reference, or team stats pages. More accurate data = better projections!
                        </p>
                    </div>
                </div>
                
                <div style="background: #f0f4f8; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3 style="margin-bottom: 15px; color: #333;">üí∞ Moneyline Odds</h3>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <label>Away Team ML</label>
                            <input type="number" id="ml-away-odds" placeholder="+130" />
                        </div>
                        <div>
                            <label>Home Team ML</label>
                            <input type="number" id="ml-home-odds" placeholder="-154" />
                        </div>
                    </div>
                </div>
                
                <div style="background: #f0f4f8; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3 style="margin-bottom: 15px; color: #333;">üìä Spread Odds</h3>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <label>Away Team Spread</label>
                            <input type="number" step="0.5" id="ml-away-spread" placeholder="+3" />
                        </div>
                        <div>
                            <label>Away Team Spread Odds</label>
                            <input type="number" id="ml-away-spread-odds" placeholder="-120" />
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">
                        <div>
                            <label>Home Team Spread</label>
                            <input type="number" step="0.5" id="ml-home-spread" placeholder="-3" />
                        </div>
                        <div>
                            <label>Home Team Spread Odds</label>
                            <input type="number" id="ml-home-spread-odds" placeholder="-102" />
                        </div>
                    </div>
                </div>
                
                <div style="background: #f0f4f8; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h3 style="margin-bottom: 15px; color: #333;">üéØ Over/Under (Total Points)</h3>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <label>Total Points Line</label>
                            <input type="number" step="0.5" id="ml-total-line" placeholder="43.5" />
                        </div>
                        <div>
                            <label>Over Odds</label>
                            <input type="number" id="ml-over-odds" placeholder="-110" />
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 15px;">
                        <div>
                            <label>Under Odds</label>
                            <input type="number" id="ml-under-odds" placeholder="-110" />
                        </div>
                        <div>
                            <!-- Empty space for symmetry -->
                        </div>
                    </div>
                </div>
                
                <button class="btn" onclick="analyzeMoneyline()" id="ml-analyze-btn">
                    üìä Analyze Game Lines
                </button>
                
                <div id="moneyline-results" style="margin-top: 20px;"></div>
            </div>
        </div>
        
        <!-- RESULTS & TRACKING TAB -->
        <div id="results-tab" class="tab-content">
            <div class="card">
                <h2 style="margin-bottom: 15px;">üìä Results & Tracking</h2>
                <p style="color: #666; margin-bottom: 20px;">
                    Track your bet results to train the ML model and improve future predictions
                </p>
                
                <!-- Stats Overview -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 25px;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 12px; color: white;">
                        <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px;">Total Bets</div>
                        <div id="stats-total-bets" style="font-size: 32px; font-weight: bold;">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); padding: 20px; border-radius: 12px; color: white;">
                        <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px;">Total Wagered</div>
                        <div id="stats-total-wagered" style="font-size: 32px; font-weight: bold;">$0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); padding: 20px; border-radius: 12px; color: white;">
                        <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px;">Win Rate</div>
                        <div id="stats-win-rate" style="font-size: 32px; font-weight: bold;">0%</div>
                    </div>
                    <div style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); padding: 20px; border-radius: 12px; color: white;">
                        <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px;">Total P/L</div>
                        <div id="stats-total-pl" style="font-size: 32px; font-weight: bold;">$0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); padding: 20px; border-radius: 12px; color: white;">
                        <div style="font-size: 14px; opacity: 0.9; margin-bottom: 5px;">ROI</div>
                        <div id="stats-roi" style="font-size: 32px; font-weight: bold;">0%</div>
                    </div>
                </div>
                
                <!-- Pending Results -->
                <div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 15px 0; color: #92400e; font-size: 16px;">‚è≥ Pending Results</h3>
                    <p style="font-size: 13px; color: #92400e; margin-bottom: 15px;">
                        Enter results for your active bets. Use buttons (not typing) for accuracy!
                    </p>
                    <div id="pending-results-list">
                        <p style="color: #78350f; font-style: italic; margin: 0;">No pending bets. Add bets from Parlay Builder!</p>
                    </div>
                </div>
                
                <!-- Recent Results -->
                <div style="background: white; border: 1px solid #e5e7eb; border-radius: 8px; padding: 15px;">
                    <h3 style="margin: 0 0 15px 0; color: #111827; font-size: 16px;">üìã Recent Results</h3>
                    <div id="recent-results-list">
                        <p style="color: #6b7280; font-style: italic; margin: 0;">No results yet. Start tracking your bets!</p>
                    </div>
                </div>
            </div>
        </div>
        
        
        <!-- MANUAL ENTRY TAB -->
        <div id="manual-tab" class="tab-content">
            <div class="card">
                <h2 style="margin-bottom: 15px;"><span id="manual-sport-icon">üèà</span> Manual Entry</h2>
                <p style="color: #666; margin-bottom: 20px;">
                    Manually enter specific <span id="manual-sport-name">NFL</span> odds from any sportsbook to analyze custom lines
                </p>
                
                <label>Player Name</label>
                <input type="text" id="manual-player" placeholder="Jonathan Taylor" />
                
                <label id="manual-opponent-label">Opponent (optional - for defense adjustment)</label>
                <input type="text" id="manual-opponent" placeholder="PHI, DAL, KC" />
                <small style="color: #666; font-size: 12px; display: block; margin-bottom: 15px;" id="manual-opponent-help">
                    Enter team abbreviation to adjust projection based on defensive strength
                </small>
                
                <label id="manual-home-label">Home Team (optional - for weather/venue adjustment)</label>
                <input type="text" id="manual-home-team" placeholder="Atlanta Falcons" />
                <small style="color: #666; font-size: 12px; display: block; margin-bottom: 15px;" id="manual-home-help">
                    Enter full home team name for dome/weather adjustments (NFL only)
                </small>
                
                
                <label>Prop Type</label>
                <select id="manual-prop-type">
                    <!-- Options will be populated dynamically based on sport -->
                    <option value="pass_yds">Passing Yards</option>
                    <option value="pass_tds">Passing TDs</option>
                    <option value="rush_yds">Rushing Yards</option>
                    <option value="rush_tds">Rushing TDs</option>
                    <option value="receptions">Receptions</option>
                    <option value="reception_yds">Receiving Yards</option>
                    <option value="rec_tds">Receiving TDs</option>
                </select>
                
                <label id="manual-recent-label" style="margin-top: 15px; display: block; font-weight: 600;">Recent Games (last 7 games)</label>
                
                <!-- AUTO-FETCH BUTTON (NBA ONLY) - DISABLED: CORS proxy unreliable -->
                <div id="auto-fetch-section" style="background: #fee2e2; border: 2px solid #dc2626; padding: 15px; border-radius: 8px; margin-bottom: 15px; display: none;">
                    <h4 style="margin: 0 0 8px 0; color: #991b1b; font-size: 14px;">‚ö†Ô∏è Auto-Fetch Currently Disabled</h4>
                    <p style="font-size: 12px; color: #7f1d1d; margin-bottom: 10px;">
                        The auto-fetch feature is temporarily disabled due to CORS proxy reliability issues. 
                        Please enter stats manually from Basketball-Reference.com, or set up the Python backend for reliable auto-fetching.
                    </p>
                    <button onclick="autoFetchNBAStats()" id="auto-fetch-btn" 
                        style="width: 100%; padding: 12px; background: #9ca3af; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: not-allowed; font-size: 14px; margin-bottom: 8px;"
                        disabled>
                        üîç Auto-Fetch Stats (Temporarily Disabled)
                    </button>
                    <small style="display: block; color: #7f1d1d; font-size: 11px;">
                        üí° <strong>Manual entry is faster and more reliable right now.</strong><br>
                        Go to basketball-reference.com ‚Üí Find player ‚Üí Copy last 7 games ‚Üí Paste below
                    </small>
                </div>
                
                <!-- MANUAL ENTRY HELPER (NBA) -->
                <div id="manual-entry-helper" style="background: #d1fae5; border-left: 4px solid #10b981; padding: 12px; border-radius: 6px; margin-bottom: 15px; display: none;">
                    <div style="font-size: 13px; font-weight: 600; color: #065f46; margin-bottom: 8px;">
                        üìä Quick Manual Entry Guide
                    </div>
                    <div style="font-size: 12px; color: #047857; line-height: 1.6;">
                        <strong>Fast 30-second method:</strong><br>
                        1. Search "<span id="helper-player-name" style="font-weight: 600;">Player</span> game log" on Google<br>
                        2. Click Basketball Reference result<br>
                        3. Look at <span style="background: #fef3c7; padding: 2px 4px; border-radius: 3px; font-weight: 600;">PTS</span> column (or AST, REB, etc.)<br>
                        4. Copy last 7 numbers (most recent at top)<br>
                        5. Paste below separated by commas<br>
                        <div style="margin-top: 8px; padding: 8px; background: white; border-radius: 4px; font-family: monospace; font-size: 11px;">
                            Example: 37, 30, 23, 28, 19, 39, 18
                        </div>
                    </div>
                </div>
                
                <input type="text" id="manual-recent-games" placeholder="73, 53, 89, 81, 30, 64, 103" style="padding: 12px; border: 2px solid #d1d5db; border-radius: 8px; font-size: 14px; margin-bottom: 10px;" />
                <small style="color: #666; font-size: 12px; display: block; margin-bottom: 15px; line-height: 1.5;" id="manual-recent-help">
                    Get stats from <a href="https://www.pro-football-reference.com" target="_blank" style="color: #3b82f6; text-decoration: underline;">Pro-Football-Reference</a> ‚Üí Search player ‚Üí Game Logs ‚Üí Copy last 7 games
                </small>
                
                <!-- NBA: Minutes Input -->
                <div id="manual-minutes-section" style="display: none;">
                    <label style="display: block; font-weight: 600;">Minutes Played (optional - for per-minute accuracy)</label>
                    <input type="text" id="manual-recent-minutes" placeholder="29, 25, 27, 31, 23, 24, 36" style="padding: 12px; border: 2px solid #d1d5db; border-radius: 8px; font-size: 14px; margin-bottom: 10px;" />
                    <small style="color: #666; font-size: 12px; display: block; margin-bottom: 5px;">
                        <strong>üí° Pro Feature:</strong> Enter minutes for each game above (same order) for per-minute projection
                    </small>
                    
                    <!-- NBA Shot Attempts (FGA for points, 3PA for threes) -->
                    <div id="manual-nba-shots-section" style="margin-top: 15px;">
                        <label style="display: block; font-weight: 600; margin-bottom: 8px;">
                            üéØ Shot Attempts (optional - improves accuracy significantly)
                        </label>
                        
                        <div id="manual-fga-section" style="margin-bottom: 10px;">
                            <label style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 5px;">
                                Field Goal Attempts (FGA) - for Points props
                            </label>
                            <input type="text" id="manual-recent-fga" placeholder="15, 18, 12, 20, 16, 14, 17" style="width: 100%; padding: 10px; border: 2px solid #d1d5db; border-radius: 6px; font-size: 14px; margin-bottom: 5px;" />
                            <small style="color: #666; font-size: 11px; display: block;">
                                üí° Get from Basketball-Reference ‚Üí FGA column (same order as points above)
                            </small>
                        </div>
                        
                        <div id="manual-3pa-section" style="margin-bottom: 10px;">
                            <label style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 5px;">
                                3-Point Attempts (3PA) - for Threes props
                            </label>
                            <input type="text" id="manual-recent-3pa" placeholder="6, 8, 5, 9, 7, 6, 8" style="width: 100%; padding: 10px; border: 2px solid #d1d5db; border-radius: 6px; font-size: 14px; margin-bottom: 5px;" />
                            <small style="color: #666; font-size: 11px; display: block;">
                                üí° Get from Basketball-Reference ‚Üí 3PA column (same order as threes above)
                            </small>
                        </div>
                        
                        <div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 10px; border-radius: 4px; margin-top: 10px;">
                            <small style="font-size: 11px; color: #92400e;">
                                <strong>‚ö° Why this matters:</strong> Shot attempts reveal shooting variance. 
                                A player averaging 20 pts on 15 FGA could score anywhere from 10-30 depending on shooting night. 
                                This prevents 100% confidence on bets that can still miss.
                            </small>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; margin-bottom: 15px;">
                        <div>
                            <input type="number" step="0.5" id="manual-tonight-minutes" placeholder="Expected mins tonight" style="width: 100%; padding: 10px; border: 1px solid #cbd5e1; border-radius: 6px; font-size: 13px;" />
                            <small style="color: #666; font-size: 11px; display: block; margin-top: 3px;">
                                If expecting more/less than average
                            </small>
                        </div>
                        <div>
                            <label style="font-size: 13px; font-weight: 600; margin-bottom: 5px; display: block;">
                                <input type="checkbox" id="manual-exclude-outliers" style="margin-right: 5px;">
                                Auto-exclude outliers
                            </label>
                            <small style="color: #666; font-size: 11px; display: block;">
                                Remove statistical anomalies
                            </small>
                        </div>
                    </div>
                </div>
                
                <!-- NFL: Attempts Input -->
                <div id="manual-attempts-section" style="display: block;">
                    <label style="display: block; font-weight: 600;" id="manual-attempts-label">Attempts (optional - for per-attempt accuracy)</label>
                    <input type="text" id="manual-recent-attempts" placeholder="35, 38, 33, 42, 37, 36, 39" style="padding: 12px; border: 2px solid #d1d5db; border-radius: 8px; font-size: 14px; margin-bottom: 10px;" />
                    <small style="color: #666; font-size: 12px; display: block; margin-bottom: 5px;" id="manual-attempts-help">
                        <strong>üí° Pro Feature:</strong> Enter attempts for each game above (pass attempts for QBs, rush attempts for RBs, targets for WRs)
                    </small>
                    
                    <!-- Completions/Receptions Input (for passing/receiving yards) -->
                    <div id="manual-completions-section" style="display: none; margin-bottom: 10px;">
                        <label style="display: block; font-weight: 600; margin-top: 10px;" id="manual-completions-label">Completions (optional)</label>
                        <input type="text" id="manual-recent-completions" placeholder="23, 28, 22, 31, 25, 24, 27" style="padding: 12px; border: 2px solid #d1d5db; border-radius: 8px; font-size: 14px; margin-bottom: 5px;" />
                        <small style="color: #666; font-size: 12px; display: block; margin-bottom: 5px;">
                            For yards per completion calculation (more accurate than yards per attempt)
                        </small>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                        <div>
                            <input type="number" step="0.5" id="manual-tonight-attempts" placeholder="Expected attempts tonight" style="width: 100%; padding: 10px; border: 1px solid #cbd5e1; border-radius: 6px; font-size: 13px;" />
                            <small style="color: #666; font-size: 11px; display: block; margin-top: 3px;">
                                If expecting more/less than average
                            </small>
                        </div>
                        <div>
                            <label style="font-size: 13px; font-weight: 600; margin-bottom: 5px; display: block;">
                                <input type="checkbox" id="manual-exclude-outliers-nfl" style="margin-right: 5px;">
                                Auto-exclude outliers
                            </label>
                            <small style="color: #666; font-size: 11px; display: block;">
                                Remove statistical anomalies
                            </small>
                        </div>
                    </div>
                </div>
                
                <!-- Context Adjustments Section -->
                <div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 10px 0; color: #92400e; font-size: 14px;">‚öôÔ∏è Context Adjustments (Optional)</h4>
                    <p style="font-size: 12px; color: #78350f; margin-bottom: 12px;">
                        These adjustments help account for matchups and situational factors the basic projection misses
                    </p>
                    
                    <label style="font-size: 13px; font-weight: 600;">Today's Opponent</label>
                    <select id="manual-opponent-team" style="width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px;">
                        <option value="">-- Select Opponent (for defense adjustment) --</option>
                        <!-- Will be populated based on sport -->
                    </select>
                    <small style="color: #78350f; font-size: 11px; display: block; margin-bottom: 12px;">
                        Adjusts projection based on opponent's defense vs this position
                    </small>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                        <div>
                            <label style="font-size: 13px; font-weight: 600;">Home or Away?</label>
                            <select id="manual-home-away" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px;">
                                <option value="home">Home (+5% boost)</option>
                                <option value="away">Away (-5% penalty)</option>
                                <option value="neutral">Neutral (no adjustment)</option>
                            </select>
                            <small style="display: block; color: #6b7280; font-size: 11px; margin-top: 3px;">
                                Players perform ~5% better at home
                            </small>
                        </div>
                        <div>
                            <label style="font-size: 13px; font-weight: 600;">Days of Rest</label>
                            <select id="manual-rest-days" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px;">
                                <option value="0">0 days (B2B) (-12%)</option>
                                <option value="1" selected>1 day (-5%)</option>
                                <option value="2">2 days (normal)</option>
                                <option value="3">3+ days (+5%)</option>
                            </select>
                            <small style="display: block; color: #6b7280; font-size: 11px; margin-top: 3px;">
                                Fatigue significantly impacts performance
                            </small>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                        <div>
                            <label style="font-size: 13px; font-weight: 600;">
                                <input type="checkbox" id="manual-injury-adjustment" style="margin-right: 5px;">
                                Key Teammate(s) OUT
                            </label>
                            <small style="display: block; color: #6b7280; font-size: 11px; margin-top: 3px; font-weight: normal;">
                                e.g., Mitchell out = more usage for Garland
                            </small>
                        </div>
                        <div>
                            <label style="font-size: 13px; font-weight: 600;">
                                <input type="checkbox" id="manual-starter-adjustment" style="margin-right: 5px;">
                                Bench Player Starting Tonight
                            </label>
                            <small style="display: block; color: #6b7280; font-size: 11px; margin-top: 3px; font-weight: normal;">
                                ‚ö†Ô∏è ONLY if usually a bench player!<br>
                                e.g., Sam Merrill starting (not Murray)
                            </small>
                        </div>
                    </div>
                    
                    <div style="background: #fef3c7; border: 2px solid #f59e0b; padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                        <label style="font-size: 13px; font-weight: 600; color: #92400e; display: block; margin-bottom: 8px;">
                            üéØ Blowout Risk Detector
                        </label>
                        <small style="display: block; color: #78350f; font-size: 11px; margin-bottom: 10px;">
                            Adjusts for rest risk when player's team is heavily favored/unfavored
                        </small>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div>
                                <label style="font-size: 12px; font-weight: 600; color: #92400e;">Game Spread</label>
                                <input type="number" step="0.5" id="manual-game-spread" placeholder="e.g., -15.5" 
                                    style="width: 100%; padding: 8px; border: 2px solid #fbbf24; border-radius: 6px; font-size: 13px;">
                                <small style="display: block; color: #78350f; font-size: 10px; margin-top: 3px;">
                                    Negative if player's team favored
                                </small>
                            </div>
                            <div>
                                <label style="font-size: 12px; font-weight: 600; color: #92400e;">Player's Team</label>
                                <select id="manual-team-favored" style="width: 100%; padding: 8px; border: 2px solid #fbbf24; border-radius: 6px; font-size: 13px;">
                                    <option value="neutral">Unknown/Even</option>
                                    <option value="player">Favored (spread < -10)</option>
                                    <option value="opponent">Underdog (spread > +10)</option>
                                </select>
                                <small style="display: block; color: #78350f; font-size: 10px; margin-top: 3px;">
                                    Auto-detects blowout risk
                                </small>
                            </div>
                        </div>
                        
                        <div id="manual-blowout-warning" style="display: none; background: #fffbeb; padding: 8px; border-radius: 4px; margin-top: 8px; font-size: 11px; color: #92400e; border-left: 3px solid #f59e0b;">
                            <!-- Will be filled by JavaScript -->
                        </div>
                    </div>
                    
                    <div id="adjustment-explanation" style="background: white; padding: 10px; border-radius: 6px; font-size: 12px; color: #374151; display: none;">
                        <!-- Will show what adjustments are being applied -->
                    </div>
                </div>
                
                <!-- TD ANALYZER SECTION (for rush_tds and rec_tds) -->
                <div id="td-analyzer-section" style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 15px; border-radius: 8px; margin-bottom: 15px; display: none;">
                    <h4 style="margin: 0 0 10px 0; color: #92400e; font-size: 14px;">üèà Touchdown Probability Calculator</h4>
                    <p style="font-size: 12px; color: #78350f; margin-bottom: 12px;">
                        For TD props (Anytime, 2+, 3+), we calculate probability based on recent scoring frequency
                    </p>
                    
                    <div style="background: white; padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                        <label style="font-size: 13px; font-weight: 600; color: #92400e; display: block; margin-bottom: 5px;">
                            Recent Touchdowns (Last 7 Games)
                        </label>
                        <input type="text" id="td-recent-scores" placeholder="0, 1, 0, 1, 1, 0, 2" style="width: 100%; padding: 10px; border: 1px solid #fbbf24; border-radius: 6px; font-size: 13px; margin-bottom: 5px;" />
                        <small style="color: #78350f; font-size: 11px; display: block;">
                            Enter number of TDs scored in each of last 7 games (rushing TDs for RBs, receiving TDs for WRs/TEs)
                        </small>
                    </div>
                    
                    <h5 style="margin: 12px 0 8px 0; color: #92400e; font-size: 13px;">üìä Available TD Bets & Odds:</h5>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 12px;">
                        <div>
                            <label style="font-size: 12px; font-weight: 600; color: #92400e;">Anytime TD</label>
                            <input type="number" id="td-anytime-odds" placeholder="+140" style="width: 100%; padding: 8px; border: 1px solid #fbbf24; border-radius: 6px; font-size: 13px;" />
                            <small style="color: #78350f; font-size: 10px; display: block; margin-top: 2px;">Player scores 1+ TDs</small>
                        </div>
                        <div>
                            <label style="font-size: 12px; font-weight: 600; color: #92400e;">First TD</label>
                            <input type="number" id="td-first-odds" placeholder="+750" style="width: 100%; padding: 8px; border: 1px solid #fbbf24; border-radius: 6px; font-size: 13px;" />
                            <small style="color: #78350f; font-size: 10px; display: block; margin-top: 2px;">Player scores FIRST TD</small>
                        </div>
                        <div>
                            <label style="font-size: 12px; font-weight: 600; color: #92400e;">2+ TDs</label>
                            <input type="number" id="td-twoplus-odds" placeholder="+1000" style="width: 100%; padding: 8px; border: 1px solid #fbbf24; border-radius: 6px; font-size: 13px;" />
                            <small style="color: #78350f; font-size: 10px; display: block; margin-top: 2px;">Player scores 2+ TDs</small>
                        </div>
                        <div>
                            <label style="font-size: 12px; font-weight: 600; color: #92400e;">3+ TDs</label>
                            <input type="number" id="td-threeplus-odds" placeholder="+7500" style="width: 100%; padding: 8px; border: 1px solid #fbbf24; border-radius: 6px; font-size: 13px;" />
                            <small style="color: #78350f; font-size: 10px; display: block; margin-top: 2px;">Player scores 3+ TDs</small>
                        </div>
                    </div>
                    
                    <div style="background: #fffbeb; padding: 8px; border-radius: 4px; font-size: 11px; color: #92400e; margin-top: 10px;">
                        <strong>üí° How it works:</strong> We use Poisson distribution based on player's TD frequency to calculate probability of each outcome. If true probability > implied probability from odds, that's positive EV!
                    </div>
                </div>
                
                <!-- DEFENSIVE STATS SECTION -->
                <div style="background: #f0f9ff; border-left: 4px solid #3b82f6; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 10px 0; color: #1e40af; font-size: 14px;">üõ°Ô∏è Opponent Defense Stats (Optional - Highly Recommended)</h4>
                    <p style="font-size: 12px; color: #1e3a8a; margin-bottom: 12px;">
                        Add opponent's defensive stats to adjust projection based on matchup strength
                    </p>
                    
                    <!-- NFL Pass Defense -->
                    <div id="defense-pass-section" style="display: none;">
                        <label style="font-size: 13px; font-weight: 600; color: #1e40af;">Pass Defense Rank (2025-26)</label>
                        <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 10px; margin-bottom: 10px;">
                            <select id="defense-pass-rank" style="width: 100%; padding: 8px; border: 1px solid #bfdbfe; border-radius: 6px; font-size: 13px;">
                                <option value="">-- Select Ranking --</option>
                                <option value="1-5">üî¥ Elite (Top 5) - Tough matchup</option>
                                <option value="6-10">üü° Very Good (6-10) - Difficult</option>
                                <option value="11-15">üü° Above Average (11-15) - Moderate</option>
                                <option value="16-20">üü¢ Average (16-20) - Neutral</option>
                                <option value="21-25">üü¢ Below Average (21-25) - Favorable</option>
                                <option value="26-32">üü¢ Poor (26-32) - Great matchup!</option>
                            </select>
                            <input type="number" id="defense-pass-rank-exact" min="1" max="32" placeholder="Exact (1-32)" style="width: 100%; padding: 8px; border: 1px solid #bfdbfe; border-radius: 6px; font-size: 13px;" />
                        </div>
                        <small style="display: block; color: #1e3a8a; font-size: 11px; margin-bottom: 10px;">
                            Find on <strong>ESPN</strong> (Team Stats ‚Üí Pass Defense) or <strong>TeamRankings.com</strong>
                        </small>
                        
                        <label style="font-size: 13px; font-weight: 600; margin-top: 10px; display: block; color: #1e40af;">
                            Pass Yards Allowed (Last 7 Games)
                        </label>
                        <input type="text" id="defense-pass-yards-last7" placeholder="e.g., 245, 310, 198, 267, 289, 221, 255" style="width: 100%; padding: 10px; border: 1px solid #bfdbfe; border-radius: 6px; font-size: 13px; margin-bottom: 5px;" />
                        <small style="color: #1e3a8a; font-size: 11px; display: block; margin-bottom: 10px;">
                            <strong>üí° Pro Tip:</strong> Total passing yards allowed by defense in each of their last 7 games
                        </small>
                    </div>
                    
                    <!-- NFL Rush Defense -->
                    <div id="defense-rush-section" style="display: none;">
                        <label style="font-size: 13px; font-weight: 600; color: #1e40af;">Run Defense Rank (2025-26)</label>
                        <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 10px; margin-bottom: 10px;">
                            <select id="defense-rush-rank" style="width: 100%; padding: 8px; border: 1px solid #bfdbfe; border-radius: 6px; font-size: 13px;">
                                <option value="">-- Select Ranking --</option>
                                <option value="1-5">üî¥ Elite (Top 5) - Tough matchup</option>
                                <option value="6-10">üü° Very Good (6-10) - Difficult</option>
                                <option value="11-15">üü° Above Average (11-15) - Moderate</option>
                                <option value="16-20">üü¢ Average (16-20) - Neutral</option>
                                <option value="21-25">üü¢ Below Average (21-25) - Favorable</option>
                                <option value="26-32">üü¢ Poor (26-32) - Great matchup!</option>
                            </select>
                            <input type="number" id="defense-rush-rank-exact" min="1" max="32" placeholder="Exact (1-32)" style="width: 100%; padding: 8px; border: 1px solid #bfdbfe; border-radius: 6px; font-size: 13px;" />
                        </div>
                        
                        <label style="font-size: 13px; font-weight: 600; margin-top: 10px; display: block; color: #1e40af;">
                            Rush Yards Allowed (Last 7 Games)
                        </label>
                        <input type="text" id="defense-rush-yards-last7" placeholder="e.g., 98, 142, 87, 156, 121, 105, 134" style="width: 100%; padding: 10px; border: 1px solid #bfdbfe; border-radius: 6px; font-size: 13px; margin-bottom: 5px;" />
                        <small style="color: #1e3a8a; font-size: 11px; display: block; margin-bottom: 10px;">
                            <strong>üí° Pro Tip:</strong> Total rushing yards allowed by defense in each of their last 7 games
                        </small>
                    </div>
                    
                    <!-- NBA Points Defense -->
                    <div id="defense-points-section" style="display: none;">
                        <label style="font-size: 13px; font-weight: 600; color: #1e40af;">Points Defense Rank (2025-26)</label>
                        <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 10px; margin-bottom: 10px;">
                            <select id="defense-points-rank" style="width: 100%; padding: 8px; border: 1px solid #bfdbfe; border-radius: 6px; font-size: 13px;">
                                <option value="">-- Select Ranking --</option>
                                <option value="1-5">üî¥ Elite (Top 5) - Tough matchup</option>
                                <option value="6-10">üü° Very Good (6-10) - Difficult</option>
                                <option value="11-15">üü° Above Average (11-15) - Moderate</option>
                                <option value="16-20">üü¢ Average (16-20) - Neutral</option>
                                <option value="21-25">üü¢ Below Average (21-25) - Favorable</option>
                                <option value="26-30">üü¢ Poor (26-30) - Great matchup!</option>
                            </select>
                            <input type="number" id="defense-points-rank-exact" min="1" max="30" placeholder="Exact (1-30)" style="width: 100%; padding: 8px; border: 1px solid #bfdbfe; border-radius: 6px; font-size: 13px;" />
                        </div>
                        
                        <label style="font-size: 13px; font-weight: 600; margin-top: 10px; display: block; color: #1e40af;">
                            Points Allowed (Last 7 Games)
                        </label>
                        <input type="text" id="defense-points-last7" placeholder="e.g., 108, 115, 102, 121, 110, 106, 118" style="width: 100%; padding: 10px; border: 1px solid #bfdbfe; border-radius: 6px; font-size: 13px; margin-bottom: 5px;" />
                        <small style="color: #1e3a8a; font-size: 11px; display: block; margin-bottom: 10px;">
                            <strong>üí° Pro Tip:</strong> Total points allowed by defense in each of their last 7 games
                        </small>
                    </div>
                    
                    <!-- NBA Rebounds Defense -->
                    <div id="defense-rebounds-section" style="display: none;">
                        <label style="font-size: 13px; font-weight: 600; color: #1e40af;">Rebounds Defense Rank (2025-26)</label>
                        <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 10px; margin-bottom: 10px;">
                            <select id="defense-rebounds-rank" style="width: 100%; padding: 8px; border: 1px solid #bfdbfe; border-radius: 6px; font-size: 13px;">
                                <option value="">-- Select Ranking --</option>
                                <option value="1-5">üî¥ Elite (Top 5) - Tough matchup</option>
                                <option value="6-10">üü° Very Good (6-10) - Difficult</option>
                                <option value="11-15">üü° Above Average (11-15) - Moderate</option>
                                <option value="16-20">üü¢ Average (16-20) - Neutral</option>
                                <option value="21-25">üü¢ Below Average (21-25) - Favorable</option>
                                <option value="26-30">üü¢ Poor (26-30) - Great matchup!</option>
                            </select>
                            <input type="number" id="defense-rebounds-rank-exact" min="1" max="30" placeholder="Exact (1-30)" style="width: 100%; padding: 8px; border: 1px solid #bfdbfe; border-radius: 6px; font-size: 13px;" />
                        </div>
                        
                        <label style="font-size: 13px; font-weight: 600; margin-top: 10px; display: block; color: #1e40af;">
                            Rebounds Allowed (Last 7 Games)
                        </label>
                        <input type="text" id="defense-rebounds-last7" placeholder="e.g., 42, 48, 39, 51, 44, 41, 46" style="width: 100%; padding: 10px; border: 1px solid #bfdbfe; border-radius: 6px; font-size: 13px; margin-bottom: 5px;" />
                        <small style="color: #1e3a8a; font-size: 11px; display: block; margin-bottom: 10px;">
                            <strong>üí° Pro Tip:</strong> Total rebounds allowed by defense in each of their last 7 games
                        </small>
                    </div>
                    
                    <!-- NBA Assists Defense -->
                    <div id="defense-assists-section" style="display: none;">
                        <label style="font-size: 13px; font-weight: 600; color: #1e40af;">Assists Defense Rank (2025-26)</label>
                        <div style="display: grid; grid-template-columns: 2fr 1fr; gap: 10px; margin-bottom: 10px;">
                            <select id="defense-assists-rank" style="width: 100%; padding: 8px; border: 1px solid #bfdbfe; border-radius: 6px; font-size: 13px;">
                                <option value="">-- Select Ranking --</option>
                                <option value="1-5">üî¥ Elite (Top 5) - Tough matchup</option>
                                <option value="6-10">üü° Very Good (6-10) - Difficult</option>
                                <option value="11-15">üü° Above Average (11-15) - Moderate</option>
                                <option value="16-20">üü¢ Average (16-20) - Neutral</option>
                                <option value="21-25">üü¢ Below Average (21-25) - Favorable</option>
                                <option value="26-30">üü¢ Poor (26-30) - Great matchup!</option>
                            </select>
                            <input type="number" id="defense-assists-rank-exact" min="1" max="30" placeholder="Exact (1-30)" style="width: 100%; padding: 8px; border: 1px solid #bfdbfe; border-radius: 6px; font-size: 13px;" />
                        </div>
                        
                        <label style="font-size: 13px; font-weight: 600; margin-top: 10px; display: block; color: #1e40af;">
                            Assists Allowed (Last 7 Games)
                        </label>
                        <input type="text" id="defense-assists-last7" placeholder="e.g., 24, 28, 22, 30, 25, 23, 27" style="width: 100%; padding: 10px; border: 1px solid #bfdbfe; border-radius: 6px; font-size: 13px; margin-bottom: 5px;" />
                        <small style="color: #1e3a8a; font-size: 11px; display: block; margin-bottom: 10px;">
                            <strong>üí° Pro Tip:</strong> Total assists allowed by defense in each of their last 7 games
                        </small>
                    </div>
                    
                    <!-- Defense Analysis Display -->
                    <div id="defense-analysis-display" style="background: white; border: 1px solid #bfdbfe; padding: 10px; border-radius: 6px; margin-top: 10px; display: none;">
                        <div style="font-size: 12px; color: #1e3a8a; font-weight: 600; margin-bottom: 5px;">üìä Defensive Matchup Preview</div>
                        <div id="defense-summary" style="font-size: 11px; color: #1e40af;"></div>
                    </div>
                    
                    <div style="background: #dbeafe; padding: 8px; border-radius: 4px; font-size: 11px; color: #1e40af; margin-top: 10px;">
                        <strong>üí° How this works:</strong> If opponent allows 180 pass yards/game vs league avg 220, projection reduces by ~18%. Strong defenses hurt your player, weak defenses help!<br>
                        <strong>üìä Yards vs Rank:</strong> If you enter BOTH yards and rank, the yards data is used (more accurate). The rank will be shown for context. To use rank only, leave yards field empty.
                    </div>
                </div>
                
                <!-- LINE AND ODDS SECTION (Hidden for TD props) -->
                <div id="line-odds-section">
                    <label>Line (e.g., 2.5 for receptions, 89.5 for yards)</label>
                    <input type="number" step="0.5" id="manual-line" placeholder="2.5" />
                    <small style="color: #666; font-size: 12px; display: block; margin-bottom: 15px;">
                        Enter the line - the tool will recommend whether to bet OVER or UNDER
                    </small>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                        <div>
                            <label>OVER Odds</label>
                            <input type="number" id="manual-over-odds" placeholder="-142" />
                        </div>
                        <div>
                            <label>UNDER Odds</label>
                            <input type="number" id="manual-under-odds" placeholder="+112" />
                        </div>
                    </div>
                    <small style="color: #666; font-size: 12px; display: block; margin-bottom: 15px;">
                        Enter odds for both sides - the tool will recommend the better value
                    </small>
                </div>
                
                <label>Sportsbook</label>
                <input type="text" id="manual-bookmaker" placeholder="BetOnline" />
                
                <button class="btn" onclick="analyzeManualBet()" id="manual-analyze-btn">
                    üìä Analyze This Bet
                </button>
                
                <div id="manual-results" style="margin-top: 20px;"></div>
            </div>
            
            <!-- RESULTS TRACKING -->
            <div class="card" style="margin-top: 20px;">
                <h3 style="margin-bottom: 15px;">üìä Results Tracker</h3>
                <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
                    Track your bets to see how accurate the tool's projections are over time
                </p>
                
                <!-- ML Status -->
                <div id="ml-status" style="background: #ede9fe; border-left: 4px solid #8b5cf6; padding: 12px; border-radius: 8px; margin-bottom: 15px; font-size: 13px;">
                    <strong style="color: #6b21a8;">ü§ñ Machine Learning Status:</strong>
                    <div id="ml-status-text" style="margin-top: 5px; color: #7c3aed;">
                        Not enough data yet. Enter actual results when tracking bets to train ML model (need 10+ data points).
                    </div>
                    <button onclick="showMLAnalysis()" 
                            style="margin-top: 10px; padding: 8px 16px; background: #8b5cf6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600;"
                            onmouseover="this.style.background='#7c3aed'" 
                            onmouseout="this.style.background='#8b5cf6'">
                        üìä View Detailed ML Analysis
                    </button>
                </div>
                
                <!-- ML Analysis Modal (hidden by default) -->
                <div id="ml-analysis-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000; overflow-y: auto;">
                    <div style="max-width: 1000px; margin: 50px auto; background: white; border-radius: 12px; padding: 30px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h2 style="margin: 0; color: #1f2937;">ü§ñ ML Performance Analysis</h2>
                            <button onclick="document.getElementById('ml-analysis-modal').style.display='none'" 
                                    style="padding: 8px 16px; background: #ef4444; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                                Close
                            </button>
                        </div>
                        <div id="ml-analysis-content"></div>
                    </div>
                </div>
                
                <div id="tracking-stats" style="background: #f3f4f6; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; text-align: center;">
                        <div>
                            <div style="font-size: 24px; font-weight: bold; color: #1f2937;" id="track-total">0</div>
                            <div style="font-size: 12px; color: #6b7280;">Total Bets</div>
                        </div>
                        <div>
                            <div style="font-size: 24px; font-weight: bold; color: #10b981;" id="track-wins">0</div>
                            <div style="font-size: 12px; color: #6b7280;">Wins</div>
                        </div>
                        <div>
                            <div style="font-size: 24px; font-weight: bold; color: #ef4444;" id="track-losses">0</div>
                            <div style="font-size: 12px; color: #6b7280;">Losses</div>
                        </div>
                        <div>
                            <div style="font-size: 24px; font-weight: bold; color: #3b82f6;" id="track-winrate">0%</div>
                            <div style="font-size: 12px; color: #6b7280;">Win Rate</div>
                        </div>
                    </div>
                </div>
                
                <!-- PARLAY PERFORMANCE -->
                <div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 10px 0; color: #92400e; font-size: 14px;">üé∞ Parlay Performance</h4>
                    <div id="parlay-performance-stats">
                        <p style="color: #9ca3af; text-align: center; font-size: 13px; font-style: italic; margin: 0;">
                            No parlays tracked yet
                        </p>
                    </div>
                </div>
                
                <!-- HIT RATE ACCURACY -->
                <div style="background: #dbeafe; border-left: 4px solid #3b82f6; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 10px 0; color: #1e40af; font-size: 14px;">üéØ Hit Rate Accuracy</h4>
                    <div id="hit-rate-accuracy-stats">
                        <p style="color: #9ca3af; text-align: center; font-size: 13px; font-style: italic; margin: 0;">
                            No bets with hit rates tracked yet
                        </p>
                    </div>
                </div>
                
                <div id="tracked-bets-list" style="max-height: 400px; overflow-y: auto;">
                    <p style="color: #9ca3af; text-align: center; padding: 20px; font-style: italic;">
                        No bets tracked yet. After analyzing a bet, you can mark it as a win or loss here.
                    </p>
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 15px;">
                    <button onclick="exportTracking()" class="btn" style="flex: 1; background: #6b7280; font-size: 14px; padding: 10px;">
                        üì• Export to CSV
                    </button>
                    <button onclick="clearTracking()" class="btn" style="flex: 1; background: #ef4444; font-size: 14px; padding: 10px;">
                        üóëÔ∏è Clear All
                    </button>
                </div>
            </div>
        </div>
        
        <!-- PARLAY BUILDER TAB -->
        <div id="parlay-tab" class="tab-content">
            <div class="card">
                <h2 style="margin-bottom: 15px;">üé∞ Parlay Builder</h2>
                <p style="color: #666; margin-bottom: 20px;">
                    Build parlays from analyzed bets and track results for better ML learning
                </p>
                
                <div style="background: #e0f2fe; border-left: 4px solid #0284c7; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <strong style="color: #075985;">üí° How to use:</strong><br>
                    <ol style="margin: 10px 0 0 20px; color: #0c4a6e; line-height: 1.6;">
                        <li>Go to <strong>Manual Entry</strong> tab</li>
                        <li>Analyze each bet you want in your parlay</li>
                        <li>Click <strong>"Add to Parlay"</strong> button on each analysis</li>
                        <li>Come back here to see your parlay</li>
                        <li>After games finish, enter actual results and mark WIN/LOSS</li>
                    </ol>
                </div>
                
                <!-- AI PARLAY BUILDER -->
                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 12px; padding: 20px; margin-bottom: 25px; color: white; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
                    <h3 style="margin: 0 0 10px 0; color: white; display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 24px;">ü§ñ</span>
                        <span>AI Parlay Builder</span>
                        <span style="background: rgba(255,255,255,0.3); padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: normal;">BETA</span>
                    </h3>
                    <p style="margin: 0 0 15px 0; opacity: 0.9; font-size: 13px;">
                        Let AI analyze all your bets and build optimal parlays ranked by probability and value
                    </p>
                    
                    <div id="ai-analyzed-bets-pool" style="background: rgba(255,255,255,0.15); border-radius: 8px; padding: 12px; margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <span style="font-size: 12px; font-weight: 600;">Today's Analyzed Bets Pool:</span>
                            <span id="ai-pool-count" style="background: rgba(255,255,255,0.3); padding: 4px 10px; border-radius: 12px; font-size: 12px; font-weight: bold;">0 bets</span>
                        </div>
                        <div id="ai-pool-bets" style="max-height: 150px; overflow-y: auto;">
                            <p style="text-align: center; opacity: 0.7; font-size: 12px; margin: 10px 0;">
                                Analyze bets in Manual Entry to add them to the pool
                            </p>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 10px;">
                        <button onclick="buildOptimalParlays(1)" style="background: rgba(255,255,255,0.25); border: 2px solid rgba(255,255,255,0.5); color: white; padding: 10px; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 12px; transition: all 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.35)'" onmouseout="this.style.background='rgba(255,255,255,0.25)'">
                            üíé 1-Leg Picks
                        </button>
                        <button onclick="buildOptimalParlays(2)" style="background: rgba(255,255,255,0.25); border: 2px solid rgba(255,255,255,0.5); color: white; padding: 10px; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 12px; transition: all 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.35)'" onmouseout="this.style.background='rgba(255,255,255,0.25)'">
                            üéØ 2-Leg Parlays
                        </button>
                        <button onclick="buildOptimalParlays(3)" style="background: rgba(255,255,255,0.25); border: 2px solid rgba(255,255,255,0.5); color: white; padding: 10px; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 12px; transition: all 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.35)'" onmouseout="this.style.background='rgba(255,255,255,0.25)'">
                            üé≤ 3-Leg Parlays
                        </button>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px;">
                        <button onclick="buildOptimalParlays(4)" style="background: rgba(255,255,255,0.20); border: 2px solid rgba(255,200,0,0.6); color: white; padding: 10px; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 12px; transition: all 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.30)'" onmouseout="this.style.background='rgba(255,255,255,0.20)'">
                            ‚ö†Ô∏è 4-Leg Parlays
                        </button>
                        <button onclick="buildOptimalParlays(5)" style="background: rgba(255,255,255,0.15); border: 2px solid rgba(255,0,0,0.6); color: white; padding: 10px; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 12px; transition: all 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.25)'" onmouseout="this.style.background='rgba(255,255,255,0.15)'">
                            üö® 5+ Leg Parlays
                        </button>
                    </div>
                    <div style="background: rgba(239, 68, 68, 0.15); border-left: 3px solid #ef4444; padding: 8px; border-radius: 4px; margin-bottom: 15px;">
                        <p style="margin: 0; font-size: 11px; color: rgba(255,255,255,0.9);">
                            ‚ö†Ô∏è <strong>Your Stats:</strong> 1-leg: 75% | 2-leg: 31% | 3-leg: 0% | 4-leg: 0% | 5-leg: 0%
                        </p>
                        <p style="margin: 5px 0 0 0; font-size: 10px; color: rgba(255,255,255,0.8);">
                            Recommendation: Focus on 1-2 leg parlays for best results
                        </p>
                    </div>
                    
                    <button onclick="clearAIPool()" style="background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 11px; width: 100%;">
                        üóëÔ∏è Clear Pool
                    </button>
                </div>
                
                <!-- AI RECOMMENDATIONS -->
                <div id="ai-recommendations" style="display: none; background: #f0fdf4; border: 2px solid #10b981; border-radius: 12px; padding: 20px; margin-bottom: 25px;">
                    <h3 style="margin: 0 0 15px 0; color: #065f46; display: flex; align-items: center; gap: 8px;">
                        <span>üéØ</span>
                        <span>AI Parlay Recommendations</span>
                    </h3>
                    <div id="ai-recommendations-list"></div>
                </div>
                
                <div id="parlay-list-container">
                    <h3 style="margin-bottom: 10px;">Current Parlay (<span id="parlay-count">0</span> legs)</h3>
                    <div id="parlay-legs" style="margin-bottom: 20px;">
                        <p style="color: #9ca3af; text-align: center; padding: 40px; font-style: italic;">
                            No bets added yet. Analyze bets in Manual Entry and click "Add to Parlay"
                        </p>
                    </div>
                    
                    <div id="parlay-summary" style="display: none; background: #f3f4f6; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; text-align: center; margin-bottom: 15px;">
                            <div>
                                <div style="font-size: 11px; color: #6b7280; margin-bottom: 5px;">TOTAL ODDS</div>
                                <div id="parlay-total-odds" style="font-size: 20px; font-weight: bold; color: #1f2937;">+0</div>
                            </div>
                            <div>
                                <div style="font-size: 11px; color: #6b7280; margin-bottom: 5px;">PROBABILITY</div>
                                <div id="parlay-probability" style="font-size: 20px; font-weight: bold; color: #1f2937;">0%</div>
                            </div>
                        </div>
                        
                        <div style="border-top: 1px solid #d1d5db; padding-top: 15px;">
                            <div style="font-size: 11px; color: #6b7280; margin-bottom: 10px; text-align: center; font-weight: 600;">PAYOUTS</div>
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; text-align: center;">
                                <div style="background: white; padding: 10px; border-radius: 6px;">
                                    <div style="font-size: 10px; color: #6b7280; margin-bottom: 3px;">$1 BET</div>
                                    <div id="parlay-payout-1" style="font-size: 16px; font-weight: bold; color: #10b981;">$0</div>
                                </div>
                                <div style="background: white; padding: 10px; border-radius: 6px;">
                                    <div style="font-size: 10px; color: #6b7280; margin-bottom: 3px;">$10 BET</div>
                                    <div id="parlay-payout-10" style="font-size: 16px; font-weight: bold; color: #10b981;">$0</div>
                                </div>
                                <div style="background: white; padding: 10px; border-radius: 6px;">
                                    <div style="font-size: 10px; color: #6b7280; margin-bottom: 3px;">$100 BET</div>
                                    <div id="parlay-payout-100" style="font-size: 16px; font-weight: bold; color: #10b981;">$0</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div id="parlay-actions" style="display: none;">
                        <button onclick="saveParlayForTracking()" class="btn" style="width: 100%; background: #3b82f6; margin-bottom: 10px; padding: 15px; font-size: 16px; font-weight: 600;">
                            üíæ Save & Track This Parlay
                        </button>
                        <small style="display: block; text-align: center; color: #6b7280; font-size: 12px; margin-bottom: 10px;">
                            Saves to Results & Tracking tab where you can enter outcomes and train ML
                        </small>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                            <button onclick="trackParlayResultDirect('win')" class="btn" style="padding: 12px; background: #10b981; font-size: 14px; font-weight: 600;">
                                ‚úÖ Quick Track WIN
                            </button>
                            <button onclick="trackParlayResultDirect('loss')" class="btn" style="padding: 12px; background: #ef4444; font-size: 14px; font-weight: 600;">
                                ‚ùå Quick Track LOSS
                            </button>
                        </div>
                        <small style="display: block; text-align: center; color: #6b7280; font-size: 11px; margin-bottom: 10px;">
                            Or use quick track if you already know the result
                        </small>
                        <button onclick="clearParlay()" class="btn" style="width: 100%; background: #6b7280; padding: 10px; font-size: 13px;">
                            üóëÔ∏è Clear & Start Over
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- LEGACY SECTIONS - HIDDEN (Now using Results & Tracking tab) -->
            <div class="card" style="margin-top: 20px; display: none;">
                <h3 style="margin-bottom: 15px;">‚è≥ Pending Parlays (Legacy)</h3>
                <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
                    Use Results & Tracking tab instead
                </p>
                <div id="pending-parlays-list">
                    <p style="color: #9ca3af; text-align: center; padding: 20px; font-style: italic;">
                        No pending parlays. Use Results & Tracking tab
                    </p>
                </div>
            </div>
            
            <div class="card" style="margin-top: 20px; display: none;">
                <h3 style="margin-bottom: 15px;">üìú Parlay History (Legacy)</h3>
                <div id="parlay-history-list">
                    <p style="color: #9ca3af; text-align: center; padding: 20px; font-style: italic;">
                        No parlays tracked yet
                    </p>
                </div>
            </div>
        </div>
        
        <!-- ANALYTICS DASHBOARD TAB -->
        <div id="analytics-tab" class="tab-content">
            <div class="card">
                <h2 style="margin-bottom: 20px;">üìà Analytics Dashboard</h2>
                <p style="color: #666; margin-bottom: 25px;">
                    Visual insights into your betting performance over time
                </p>
                
                <!-- Time Period Selector -->
                <div style="margin-bottom: 25px; display: flex; gap: 10px; flex-wrap: wrap;">
                    <button onclick="updateAnalyticsPeriod('all')" id="analytics-period-all" class="analytics-period-btn" style="background: #3b82f6; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-weight: 600;">
                        All Time
                    </button>
                    <button onclick="updateAnalyticsPeriod('6months')" id="analytics-period-6months" class="analytics-period-btn" style="background: #6b7280; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                        Last 6 Months
                    </button>
                    <button onclick="updateAnalyticsPeriod('3months')" id="analytics-period-3months" class="analytics-period-btn" style="background: #6b7280; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                        Last 3 Months
                    </button>
                    <button onclick="updateAnalyticsPeriod('30days')" id="analytics-period-30days" class="analytics-period-btn" style="background: #6b7280; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">
                        Last 30 Days
                    </button>
                </div>
                
                <!-- Summary Stats Cards -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 30px;">
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 20px; border-radius: 12px; color: white;">
                        <div style="font-size: 13px; opacity: 0.9; margin-bottom: 8px;">Total Parlays</div>
                        <div style="font-size: 32px; font-weight: bold;" id="analytics-total-parlays">0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); padding: 20px; border-radius: 12px; color: white;">
                        <div style="font-size: 13px; opacity: 0.9; margin-bottom: 8px;">Win Rate</div>
                        <div style="font-size: 32px; font-weight: bold;" id="analytics-win-rate">0%</div>
                    </div>
                    <div style="background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%); padding: 20px; border-radius: 12px; color: white;">
                        <div style="font-size: 13px; opacity: 0.9; margin-bottom: 8px;">Total Profit/Loss</div>
                        <div style="font-size: 32px; font-weight: bold;" id="analytics-total-pl">$0</div>
                    </div>
                    <div style="background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); padding: 20px; border-radius: 12px; color: white;">
                        <div style="font-size: 13px; opacity: 0.9; margin-bottom: 8px;">ROI</div>
                        <div style="font-size: 32px; font-weight: bold;" id="analytics-roi">0%</div>
                    </div>
                </div>
                
                <!-- Monthly Win/Loss Chart -->
                <div class="card" style="margin-bottom: 25px; background: #f9fafb;">
                    <h3 style="margin-bottom: 15px;">üìä Monthly Performance</h3>
                    <canvas id="monthly-chart" style="max-height: 300px;"></canvas>
                </div>
                
                <!-- Profit/Loss Trend -->
                <div class="card" style="margin-bottom: 25px; background: #f9fafb;">
                    <h3 style="margin-bottom: 15px;">üí∞ Cumulative Profit/Loss</h3>
                    <canvas id="profit-trend-chart" style="max-height: 300px;"></canvas>
                </div>
                
                <!-- Performance by Prop Type -->
                <div class="card" style="margin-bottom: 25px; background: #f9fafb;">
                    <h3 style="margin-bottom: 15px;">üéØ Performance by Prop Type</h3>
                    <div id="prop-type-stats"></div>
                </div>
                
                <!-- Performance by Player (Top 10) -->
                <div class="card" style="margin-bottom: 25px; background: #f9fafb;">
                    <h3 style="margin-bottom: 15px;">üë§ Top Players (Most Bet On)</h3>
                    <div id="player-stats"></div>
                </div>
                
                <!-- Calibration Trend -->
                <div class="card" style="background: #f9fafb;">
                    <h3 style="margin-bottom: 15px;">üéØ Calibration Accuracy Over Time</h3>
                    <canvas id="calibration-chart" style="max-height: 250px;"></canvas>
                    <div style="margin-top: 15px; padding: 12px; background: white; border-radius: 6px; border-left: 4px solid #3b82f6;">
                        <p style="margin: 0; font-size: 13px; color: #374151;">
                            <strong>What is calibration?</strong> If your tool predicts 70% confidence on 100 bets, 
                            ideally 70 should win. Good calibration = 85-95%. Perfect = 100%.
                        </p>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- ALT LINES ANALYZER (moved after parlay) -->
            
            <!-- ALT LINES ANALYZER -->
            <div class="card" style="margin-top: 20px;">
                <h3 style="margin-bottom: 15px;">üìä Alt Lines Analyzer</h3>
                <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
                    Compare multiple alternate lines for the same player/prop to find the best value. 
                    <strong>Note:</strong> For combo props (PRA, Pts+Rebs, etc.), use Manual Entry tab instead.
                </p>
                
                <!-- Quick Examples -->
                <details style="margin-bottom: 15px; padding: 10px; background: #f8fafc; border-radius: 8px; cursor: pointer;">
                    <summary style="font-weight: bold; color: #475569; font-size: 14px;">üìö Quick Examples (click to expand)</summary>
                    <div style="margin-top: 10px; font-size: 13px; color: #64748b;">
                        <strong>üèà NFL Example - Derrick Henry Rushing Yards:</strong>
                        <div style="background: white; padding: 10px; border-radius: 4px; margin: 5px 0; font-family: monospace;">
                            Player: Derrick Henry<br>
                            Prop Type: Rushing Yards<br>
                            Recent Games: 216, 128, 100, 94, 60, 64, 103, 75<br>
                            Alt Lines:<br>
                            50 -850<br>
                            75 -350<br>
                            87.5 -112<br>
                            100 +110<br>
                            125 +180
                        </div>
                        
                        <strong>üèÄ NBA Example - LeBron James Points:</strong>
                        <div style="background: white; padding: 10px; border-radius: 4px; margin: 5px 0; font-family: monospace;">
                            Player: LeBron James<br>
                            Prop Type: Points<br>
                            Recent Games: 28, 31, 25, 29, 22, 27, 30<br>
                            Alt Lines:<br>
                            20.5 -400<br>
                            25.5 -150<br>
                            30.5 +120<br>
                            35.5 +250
                        </div>
                    </div>
                </details>
                
                <label>Player Name</label>
                <input type="text" id="alt-player" placeholder="e.g., Derrick Henry or LeBron James" />
                
                <label>Prop Type</label>
                <select id="alt-prop-type">
                    <optgroup label="üèà NFL Props">
                        <option value="rush_yds">Rushing Yards</option>
                        <option value="reception_yds">Receiving Yards</option>
                        <option value="pass_yds">Passing Yards</option>
                        <option value="receptions">Receptions</option>
                        <option value="pass_tds">Passing TDs</option>
                        <option value="rush_tds">Rushing TDs</option>
                    </optgroup>
                    <optgroup label="üèÄ NBA Props">
                        <option value="points">Points</option>
                        <option value="rebounds">Rebounds</option>
                        <option value="assists">Assists</option>
                        <option value="threes">3-Pointers Made</option>
                        <option value="steals">Steals</option>
                        <option value="blocks">Blocks</option>
                        <option value="turnovers">Turnovers</option>
                    </optgroup>
                </select>
                
                <label>Recent Games (comma separated)</label>
                <input type="text" id="alt-recent-games" placeholder="e.g., 120, 145, 87, 156, 98 (or 28, 31, 25, 29 for NBA)" />
                <small style="color: #666; font-size: 12px; display: block; margin-bottom: 15px;">
                    Required - Enter player's recent game stats for the prop type selected
                </small>
                
                <label>Minutes Played (optional - for per-minute projection)</label>
                <input type="text" id="alt-recent-minutes" placeholder="e.g., 29, 25, 27, 31, 23, 24, 36" />
                <small style="color: #666; font-size: 12px; display: block; margin-bottom: 5px;">
                    <strong>üí° Pro Feature:</strong> Enter minutes for each game above (same order). Enables per-minute projection accuracy.
                </small>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                    <div>
                        <input type="number" step="0.5" id="alt-tonight-minutes" placeholder="Expected minutes tonight" style="width: 100%; padding: 8px; border: 1px solid #cbd5e1; border-radius: 6px; font-size: 13px;" />
                        <small style="color: #666; font-size: 11px; display: block; margin-top: 3px;">
                            If you know tonight's projected minutes
                        </small>
                    </div>
                    <div>
                        <label style="font-size: 13px; font-weight: 600; margin-bottom: 5px; display: block;">
                            <input type="checkbox" id="alt-exclude-outliers" style="margin-right: 5px;">
                            Auto-exclude outliers
                        </label>
                        <small style="color: #666; font-size: 11px; display: block;">
                            Remove games >2 SD from average rate
                        </small>
                    </div>
                </div>
                
                <!-- Context Adjustments Section (same as Manual Entry) -->
                <div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 10px 0; color: #92400e; font-size: 14px;">‚öôÔ∏è Context Adjustments (Optional)</h4>
                    <p style="font-size: 12px; color: #78350f; margin-bottom: 12px;">
                        These adjustments help account for matchups and situational factors
                    </p>
                    
                    <label style="font-size: 13px; font-weight: 600;">Today's Opponent</label>
                    <select id="alt-opponent-team" style="width: 100%; padding: 10px; margin-bottom: 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px;">
                        <option value="">-- Select Opponent (for defense adjustment) --</option>
                        <!-- Will be populated based on sport -->
                    </select>
                    <small style="color: #78350f; font-size: 11px; display: block; margin-bottom: 12px;">
                        Adjusts projection based on opponent's defense vs this position
                    </small>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                        <div>
                            <label style="font-size: 13px; font-weight: 600;">Home or Away?</label>
                            <select id="alt-home-away" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px;">
                                <option value="home">Home (+5% boost)</option>
                                <option value="away">Away (-5% penalty)</option>
                                <option value="neutral">Neutral (no adjustment)</option>
                            </select>
                            <small style="display: block; color: #6b7280; font-size: 11px; margin-top: 3px;">
                                Players perform ~5% better at home
                            </small>
                        </div>
                        <div>
                            <label style="font-size: 13px; font-weight: 600;">Days of Rest</label>
                            <select id="alt-rest-days" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px;">
                                <option value="0">0 days (B2B) (-12%)</option>
                                <option value="1" selected>1 day (-5%)</option>
                                <option value="2">2 days (normal)</option>
                                <option value="3">3+ days (+5%)</option>
                            </select>
                            <small style="display: block; color: #6b7280; font-size: 11px; margin-top: 3px;">
                                Fatigue significantly impacts performance
                            </small>
                        </div>
                    </div>
                    
                    <div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                        <label style="font-size: 13px; font-weight: 600; color: #92400e; display: block; margin-bottom: 8px;">
                            üéØ Blowout Risk Detector
                        </label>
                        <small style="display: block; color: #78350f; font-size: 11px; margin-bottom: 10px;">
                            Adjusts for rest risk when player's team is heavily favored/unfavored
                        </small>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <div>
                                <label style="font-size: 12px; font-weight: 600; color: #92400e;">Game Spread</label>
                                <input type="number" step="0.5" id="alt-game-spread" placeholder="e.g., -15.5" 
                                    style="width: 100%; padding: 8px; border: 2px solid #fbbf24; border-radius: 6px; font-size: 13px;">
                                <small style="display: block; color: #78350f; font-size: 10px; margin-top: 3px;">
                                    Negative if player's team favored
                                </small>
                            </div>
                            <div>
                                <label style="font-size: 12px; font-weight: 600; color: #92400e;">Player's Team</label>
                                <select id="alt-team-favored" style="width: 100%; padding: 8px; border: 2px solid #fbbf24; border-radius: 6px; font-size: 13px;">
                                    <option value="neutral">Unknown/Even</option>
                                    <option value="player">Favored (spread < -10)</option>
                                    <option value="opponent">Underdog (spread > +10)</option>
                                </select>
                                <small style="display: block; color: #78350f; font-size: 10px; margin-top: 3px;">
                                    Auto-detects blowout risk
                                </small>
                            </div>
                        </div>
                        
                        <div id="blowout-warning" style="display: none; background: #fef3c7; padding: 8px; border-radius: 4px; margin-top: 8px; font-size: 11px; color: #92400e;">
                            <!-- Will be filled by JavaScript -->
                        </div>
                    </div>
                </div>
                
                <label>Context-Adjusted Projection (optional)</label>
                <input type="number" step="0.1" id="alt-adjusted-projection" placeholder="e.g., 21.8 (leave blank to use weighted average)" />
                <small style="color: #666; font-size: 12px; display: block; margin-bottom: 15px;">
                    <strong>üí° Note:</strong> Leave this blank to auto-calculate with context adjustments above. Only override if you have external projection.
                </small>
                
                <label>Alternate Lines (one per line, format: "line odds")</label>
                <textarea id="alt-lines" rows="6" placeholder="50 -850&#10;75 -350&#10;100 -120&#10;125 +150&#10;150 +280" style="width: 100%; padding: 10px; border: 1px solid #cbd5e1; border-radius: 8px; font-family: monospace; resize: vertical;"></textarea>
                <small style="color: #666; font-size: 12px; display: block; margin-bottom: 15px;">
                    <strong>Format:</strong> "line odds" (one per line)<br>
                    <strong>NFL Example:</strong> "50 -850" = OVER 50 rushing yards at -850 odds<br>
                    <strong>NBA Example:</strong> "25.5 -120" = OVER 25.5 points at -120 odds
                </small>
                
                <button class="btn" onclick="analyzeAltLines()" id="alt-analyze-btn">
                    üìä Compare Alt Lines
                </button>
                
                <div id="alt-results" style="margin-top: 20px;"></div>
            </div>
            
            <!-- PARLAY BUILDER -->
                <h3 style="margin-bottom: 15px;">üí° Compare Multiple Books</h3>
                <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
                    Enter the same player/prop from different sportsbooks to compare which has better value
                </p>
                <div id="comparison-bets"></div>
                <button class="btn" onclick="clearComparison()" style="background: #94a3b8; margin-top: 10px;">
                    Clear All
                </button>
            </div>
            
            <div class="card" style="margin-top: 20px;">
                <h3 style="margin-bottom: 15px;">üé∞ Build Parlay from Manual Bets</h3>
                <p style="color: #666; margin-bottom: 15px; font-size: 14px;">
                    Combine your analyzed bets into a parlay. Add multiple bets above, then build your parlay here.
                </p>
                
                <div id="manual-parlay-bets" style="margin-bottom: 15px;">
                    <p style="color: #999; font-style: italic;">No bets added yet. Analyze bets above to add them to your parlay.</p>
                </div>
                
                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <button class="btn" onclick="buildManualParlay()" id="build-manual-parlay-btn" style="flex: 1; background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);">
                        üé∞ Build Parlay
                    </button>
                    <button class="btn" onclick="clearManualParlay()" style="flex: 1; background: #94a3b8;">
                        Clear Bets
                    </button>
                </div>
                
                <div id="manual-parlay-result"></div>
            </div>
        </div>
        
    <!-- Chart.js for Analytics Dashboard -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    
    <script>
        // Define this FIRST so buttons can call it
        
        // NBA Opponent Defense Database (2024-25 season)
        const NBA_TEAMS = [
            'ATL', 'BOS', 'BKN', 'CHA', 'CHI', 'CLE', 'DAL', 'DEN', 'DET', 'GSW',
            'HOU', 'IND', 'LAC', 'LAL', 'MEM', 'MIA', 'MIL', 'MIN', 'NOP', 'NYK',
            'OKC', 'ORL', 'PHI', 'PHX', 'POR', 'SAC', 'SAS', 'TOR', 'UTA', 'WAS'
        ];
        
        const NBA_DEFENSE_ADJ = {
            // Points allowed by position (vs league average)
            points_PG: {'IND': 5.2, 'ATL': 3.2, 'WAS': 2.8, 'CHA': 2.1, 'UTA': 1.8, 'TOR': 1.5, 'POR': 0.9, 'SAC': 0.6, 'DET': 0.4, 'OKC': -4.0, 'BOS': -3.5, 'CLE': -3.0, 'MIA': -2.5, 'NYK': -2.2},
            points_SG: {'IND': 4.8, 'ATL': 2.9, 'WAS': 2.5, 'CHA': 1.9, 'POR': 1.3, 'SAC': 0.8, 'DET': 0.5, 'OKC': -4.2, 'BOS': -3.8, 'CLE': -2.8, 'MIA': -2.3, 'NYK': -2.0},
            points_SF: {'IND': 4.5, 'WAS': 3.0, 'ATL': 2.7, 'CHA': 2.3, 'POR': 2.0, 'SAC': 1.2, 'DET': 0.8, 'OKC': -4.5, 'BOS': -3.8, 'CLE': -3.2, 'MIA': -2.6, 'NYK': -2.3},
            points_PF: {'IND': 4.2, 'WAS': 2.8, 'ATL': 2.5, 'POR': 2.2, 'CHA': 1.9, 'SAC': 1.0, 'DET': 0.6, 'OKC': -4.2, 'BOS': -3.5, 'CLE': -2.9, 'MIA': -2.4, 'NYK': -2.1},
            points_C: {'IND': 3.8, 'ATL': 2.5, 'WAS': 2.2, 'POR': 1.9, 'CHA': 1.6, 'SAC': 0.9, 'DET': 0.5, 'MIL': -4.5, 'OKC': -4.2, 'BOS': -3.9, 'CLE': -3.3, 'NYK': -2.8},
            
            // Rebounds allowed by position (vs league average)
            rebounds_PG: {'IND': 0.8, 'ATL': 0.6, 'WAS': 0.5, 'SAC': 0.3, 'CHI': 0.2, 'OKC': -0.7, 'BOS': -0.6, 'CLE': -0.5, 'MIA': -0.4},
            rebounds_SG: {'IND': 0.9, 'ATL': 0.7, 'WAS': 0.6, 'SAC': 0.4, 'CHI': 0.3, 'OKC': -0.8, 'BOS': -0.7, 'CLE': -0.6, 'MIA': -0.5},
            rebounds_SF: {'IND': 1.2, 'ATL': 1.0, 'WAS': 0.9, 'SAC': 0.6, 'CHI': 0.4, 'OKC': -1.1, 'BOS': -1.0, 'CLE': -0.8, 'MIA': -0.7},
            rebounds_PF: {'IND': 1.5, 'ATL': 1.3, 'WAS': 1.1, 'SAC': 0.8, 'DET': 0.5, 'CHI': 0.3, 'OKC': -1.4, 'BOS': -1.3, 'CLE': -1.0, 'MIL': -0.9, 'MIA': -0.8},
            rebounds_C: {'IND': 2.2, 'ATL': 1.8, 'WAS': 1.6, 'SAC': 1.2, 'DET': 0.9, 'CHA': 0.7, 'CHI': 0.5, 'BKN': 1.8, 'OKC': -2.0, 'BOS': -1.8, 'CLE': -1.5, 'MIL': -1.4, 'NYK': -1.2, 'MIA': -1.0},
            
            // Assists allowed (vs league average)
            assists: {'IND': 1.2, 'ATL': 0.9, 'WAS': 0.7, 'SAC': 0.4, 'DET': 0.3, 'OKC': -1.0, 'BOS': -0.9, 'CLE': -0.8, 'MIA': -0.6},
            
            // 3-pointers allowed (vs league average)
            threes: {'IND': 0.8, 'ATL': 0.5, 'WAS': 0.4, 'CHA': 0.3, 'SAC': 0.2, 'OKC': -1.0, 'BOS': -0.9, 'CLE': -0.8, 'MIA': -0.6}
        };
        
        const PLAYER_POSITIONS = {
            // Point Guards
            'darius garland': 'PG', 'trae young': 'PG', 'damian lillard': 'PG', 'stephen curry': 'PG',
            'luka doncic': 'PG', 'ja morant': 'PG', 'tyrese haliburton': 'PG', 'lamelo ball': 'PG',
            'jalen brunson': 'PG', 'shai gilgeous-alexander': 'PG', 'tyrese maxey': 'PG', 'fred vanvleet': 'PG',
            'dejounte murray': 'PG', 'mike conley': 'PG', 'chris paul': 'PG', 'kyle lowry': 'PG',
            
            // Shooting Guards
            'donovan mitchell': 'SG', 'devin booker': 'SG', 'anthony edwards': 'SG', 'jaylen brown': 'SG',
            'sam merrill': 'SG', 'zach lavine': 'SG', 'demar derozan': 'SG', 'bradley beal': 'SG',
            'desmond bane': 'SG', 'jalen green': 'SG', 'austin reaves': 'SG',
            
            // Small Forwards
            'lebron james': 'SF', 'kevin durant': 'SF', 'jayson tatum': 'SF', 'jimmy butler': 'SF',
            'kawhi leonard': 'SF', 'paul george': 'SF', 'brandon ingram': 'SF', 'scottie barnes': 'SF',
            'franz wagner': 'SF', 'mikal bridges': 'SF',
            
            // Power Forwards
            'giannis antetokounmpo': 'PF', 'julius randle': 'PF', 'pascal siakam': 'PF',
            'paolo banchero': 'PF', 'jaren jackson jr': 'PF', 'lauri markkanen': 'PF',
            'tobias harris': 'PF', 'jerami grant': 'PF',
            
            // Centers
            'nikola jokic': 'C', 'joel embiid': 'C', 'anthony davis': 'C', 'victor wembanyama': 'C',
            'evan mobley': 'C', 'jarrett allen': 'C', 'rudy gobert': 'C', 'bam adebayo': 'C',
            'nic claxton': 'C', 'domantas sabonis': 'C', 'alperen sengun': 'C', 'nikola vucevic': 'C',
            'jusuf nurkic': 'C', 'myles turner': 'C', 'alex sarr': 'C', 'chet holmgren': 'C',
            'deandre ayton': 'C', 'clint capela': 'C', 'walker kessler': 'C'
        };
        
        // Results Tracking
        let trackedBets = JSON.parse(localStorage.getItem('betTracking') || '[]');
        let trackedParlays = JSON.parse(localStorage.getItem('parlayTracking') || '[]');
        let currentParlay = JSON.parse(localStorage.getItem('currentParlay') || '[]');
        let pendingParlays = JSON.parse(localStorage.getItem('pendingParlays') || '[]');
        let aiParlayPool = JSON.parse(localStorage.getItem('aiParlayPool') || '[]');
        
        // ========================================
        // MACHINE LEARNING MODEL (TensorFlow.js)
        // ========================================
        
        let mlModel = null;
        let mlModelTrained = false;
        
        // Initialize ML model
        async function initializeMLModel() {
            if (mlModel) return mlModel;
            
            console.log('ü§ñ Initializing ML model...');
            
            // Create a simple neural network
            mlModel = tf.sequential({
                layers: [
                    // Input layer: 10 features
                    tf.layers.dense({
                        units: 32,
                        activation: 'relu',
                        inputShape: [10],
                        kernelInitializer: 'heNormal'
                    }),
                    // Hidden layer
                    tf.layers.dropout({ rate: 0.2 }),
                    tf.layers.dense({
                        units: 16,
                        activation: 'relu',
                        kernelInitializer: 'heNormal'
                    }),
                    // Output layer: predicted value
                    tf.layers.dense({
                        units: 1,
                        activation: 'linear'
                    })
                ]
            });
            
            // Compile model
            mlModel.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'meanSquaredError',
                metrics: ['mae']
            });
            
            console.log('‚úÖ ML model initialized');
            return mlModel;
        }
        
        // Encode prop type to number
        function encodePropType(propType) {
            const encoding = {
                'points': 1, 'rebounds': 2, 'assists': 3, 'threes': 4,
                'pass_yds': 5, 'rush_yds': 6, 'reception_yds': 7,
                'receptions': 8, 'pass_tds': 9, 'rush_tds': 10, 'rec_tds': 11
            };
            return encoding[propType] || 0;
        }
        
        // Prepare features for ML model
        function prepareFeatures(bet) {
            return [
                parseFloat(bet.weighted_avg || bet.projection) / 100,  // Normalize
                parseFloat(bet.simple_avg || bet.projection) / 100,
                parseFloat(bet.std_dev || 0) / 50,
                parseFloat(bet.opponent_adjustment || 0) / 10,
                parseFloat(bet.injury_adjustment || 0) / 10,
                parseFloat(bet.starter_adjustment || 0) / 10,
                parseFloat(bet.line) / 100,
                parseFloat(bet.cv || 0) / 100,
                (bet.games ? bet.games.length : 7) / 10,
                encodePropType(bet.prop_type || bet.propType) / 11
            ];
        }
        
        // ML Performance Analysis
        function showMLAnalysis() {
            const modal = document.getElementById('ml-analysis-modal');
            const content = document.getElementById('ml-analysis-content');
            
            // Get all bet legs from ALL sources
            const savedParlaysRaw = JSON.parse(localStorage.getItem('savedParlays') || '[]').filter(p => p.result);
            const trackedParlaysData = typeof trackedParlays !== 'undefined' ? trackedParlays : [];
            
            // Extract individual legs from both sources
            let allLegs = [];
            
            // From savedParlays (Results & Tracking)
            savedParlaysRaw.forEach(parlay => {
                if (parlay.legs && parlay.legs.length > 0) {
                    parlay.legs.forEach(leg => {
                        if (leg.actualResult !== undefined || leg.hit !== undefined) {
                            allLegs.push({
                                actualResult: leg.actualResult,
                                hit: leg.hit !== undefined ? leg.hit : (leg.actualResult !== undefined),
                                adjustedProjection: leg.adjusted_projection || leg.projection,
                                hit_rate: leg.hit_rate,
                                true_edge: leg.true_edge,
                                prop_type: leg.prop_type,
                                games: leg.games
                            });
                        }
                    });
                }
            });
            
            // From trackedParlays (old system)
            trackedParlaysData.forEach(parlay => {
                if (parlay.legs && parlay.legs.length > 0) {
                    parlay.legs.forEach(leg => {
                        if (leg.actualResult !== undefined || leg.result !== undefined) {
                            allLegs.push({
                                actualResult: leg.actualResult,
                                hit: leg.result === true || leg.result === 'win',
                                adjustedProjection: leg.projection,
                                hit_rate: leg.hitRate,
                                true_edge: leg.edge,
                                prop_type: leg.propType,
                                games: leg.games
                            });
                        }
                    });
                }
            });
            
            const completeBets = allLegs;
            
            if (completeBets.length < 10) {
                alert('Need at least 10 completed bets for analysis. You have ' + completeBets.length);
                return;
            }
            
            // Calculate metrics
            const total = completeBets.length;
            const wins = completeBets.filter(b => b.hit).length;
            const winRate = (wins / total * 100).toFixed(1);
            
            // Calibration Analysis: Does 60% prediction hit 60% of the time?
            const calibrationBuckets = {
                '0-30%': { predicted: [], actual: 0, total: 0 },
                '30-45%': { predicted: [], actual: 0, total: 0 },
                '45-55%': { predicted: [], actual: 0, total: 0 },
                '55-70%': { predicted: [], actual: 0, total: 0 },
                '70-100%': { predicted: [], actual: 0, total: 0 }
            };
            
            completeBets.forEach(bet => {
                const proj = parseFloat(bet.adjustedProjection || bet.hit_rate || 50);
                const hit = bet.hit ? 1 : 0;
                
                if (proj < 30) {
                    calibrationBuckets['0-30%'].predicted.push(proj);
                    calibrationBuckets['0-30%'].actual += hit;
                    calibrationBuckets['0-30%'].total++;
                } else if (proj < 45) {
                    calibrationBuckets['30-45%'].predicted.push(proj);
                    calibrationBuckets['30-45%'].actual += hit;
                    calibrationBuckets['30-45%'].total++;
                } else if (proj < 55) {
                    calibrationBuckets['45-55%'].predicted.push(proj);
                    calibrationBuckets['45-55%'].actual += hit;
                    calibrationBuckets['45-55%'].total++;
                } else if (proj < 70) {
                    calibrationBuckets['55-70%'].predicted.push(proj);
                    calibrationBuckets['55-70%'].actual += hit;
                    calibrationBuckets['55-70%'].total++;
                } else {
                    calibrationBuckets['70-100%'].predicted.push(proj);
                    calibrationBuckets['70-100%'].actual += hit;
                    calibrationBuckets['70-100%'].total++;
                }
            });
            
            // Time-based improvement
            const first50 = completeBets.slice(0, Math.min(50, total));
            const last50 = completeBets.slice(Math.max(0, total - 50));
            const first50WinRate = first50.filter(b => b.hit).length / first50.length * 100;
            const last50WinRate = last50.filter(b => b.hit).length / last50.length * 100;
            const improvement = last50WinRate - first50WinRate;
            
            // Edge analysis
            const positiveEdgeBets = completeBets.filter(b => parseFloat(b.true_edge || 0) > 5);
            const positiveEdgeWinRate = positiveEdgeBets.length > 0 ? 
                (positiveEdgeBets.filter(b => b.hit).length / positiveEdgeBets.length * 100) : 0;
            
            // Build HTML
            let html = `
                <div style="background: #f3f4f6; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 15px 0; color: #1f2937;">üìä Overall Performance</h3>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                        <div style="background: white; padding: 15px; border-radius: 6px;">
                            <div style="font-size: 12px; color: #6b7280; margin-bottom: 5px;">Total Bets Analyzed</div>
                            <div style="font-size: 28px; font-weight: 600; color: #1f2937;">${total}</div>
                        </div>
                        <div style="background: white; padding: 15px; border-radius: 6px;">
                            <div style="font-size: 12px; color: #6b7280; margin-bottom: 5px;">Overall Win Rate</div>
                            <div style="font-size: 28px; font-weight: 600; color: ${wins/total >= 0.52 ? '#10b981' : wins/total >= 0.48 ? '#f59e0b' : '#ef4444'};">${winRate}%</div>
                        </div>
                    </div>
                </div>
                
                <div style="background: #ecfdf5; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #10b981;">
                    <h3 style="margin: 0 0 15px 0; color: #065f46;">üìà Improvement Over Time</h3>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 15px;">
                        <div>
                            <div style="font-size: 12px; color: #047857;">First 50 Bets</div>
                            <div style="font-size: 24px; font-weight: 600; color: #10b981;">${first50WinRate.toFixed(1)}%</div>
                        </div>
                        <div>
                            <div style="font-size: 12px; color: #047857;">Last 50 Bets</div>
                            <div style="font-size: 24px; font-weight: 600; color: #10b981;">${last50WinRate.toFixed(1)}%</div>
                        </div>
                        <div>
                            <div style="font-size: 12px; color: #047857;">Improvement</div>
                            <div style="font-size: 24px; font-weight: 600; color: ${improvement >= 0 ? '#10b981' : '#ef4444'};">
                                ${improvement >= 0 ? '+' : ''}${improvement.toFixed(1)}%
                            </div>
                        </div>
                    </div>
                    <div style="font-size: 13px; color: #047857;">
                        ${improvement > 5 ? '‚úÖ <strong>ML model is improving!</strong> Your predictions are getting more accurate over time.' :
                          improvement > 0 ? 'üìä <strong>Slight improvement.</strong> Model is learning but needs more data.' :
                          improvement > -5 ? '‚ö†Ô∏è <strong>No clear improvement yet.</strong> Model may need more data or different features.' :
                          '‚ùå <strong>Performance declining.</strong> May indicate overfitting or changing conditions.'}
                    </div>
                </div>
                
                <div style="background: #fef3c7; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #f59e0b;">
                    <h3 style="margin: 0 0 15px 0; color: #92400e;">üéØ Calibration Analysis</h3>
                    <p style="font-size: 13px; color: #78350f; margin-bottom: 15px;">
                        Does the model's confidence match reality? If it says 60%, does it hit 60% of the time?
                    </p>
                    <div style="background: white; padding: 15px; border-radius: 6px;">
                        ${Object.entries(calibrationBuckets).map(([range, data]) => {
                            if (data.total === 0) return '';
                            const avgPredicted = data.predicted.reduce((a, b) => a + b, 0) / data.total;
                            const actualRate = (data.actual / data.total * 100);
                            const diff = actualRate - avgPredicted;
                            const isGood = Math.abs(diff) < 10;
                            
                            return `
                                <div style="padding: 10px 0; border-bottom: 1px solid #e5e7eb;">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <div>
                                            <strong style="color: #1f2937;">${range} Confidence</strong>
                                            <div style="font-size: 12px; color: #6b7280;">${data.total} bets</div>
                                        </div>
                                        <div style="text-align: right;">
                                            <div style="font-size: 14px; color: #6b7280;">
                                                Predicted: ${avgPredicted.toFixed(1)}% ‚Üí Actual: ${actualRate.toFixed(1)}%
                                            </div>
                                            <div style="font-size: 12px; font-weight: 600; color: ${isGood ? '#10b981' : diff > 0 ? '#3b82f6' : '#ef4444'};">
                                                ${isGood ? '‚úÖ Well calibrated' : diff > 0 ? 'üìà Underconfident' : 'üìâ Overconfident'} (${diff >= 0 ? '+' : ''}${diff.toFixed(1)}%)
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                    <div style="margin-top: 15px; font-size: 13px; color: #92400e;">
                        ${Object.values(calibrationBuckets).some(d => d.total > 0 && Math.abs((d.actual / d.total * 100) - (d.predicted.reduce((a,b) => a+b, 0) / d.total)) > 15) ?
                            '‚ö†Ô∏è <strong>Calibration needs work.</strong> Model predictions don\'t match actual outcomes. Consider retraining.' :
                            '‚úÖ <strong>Good calibration!</strong> Model confidence levels are accurate.'}
                    </div>
                </div>
                
                <div style="background: #dbeafe; padding: 20px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #3b82f6;">
                    <h3 style="margin: 0 0 15px 0; color: #1e40af;">üíé Edge Detection Accuracy</h3>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                        <div style="background: white; padding: 15px; border-radius: 6px;">
                            <div style="font-size: 12px; color: #1e40af; margin-bottom: 5px;">Bets with +5% Edge or More</div>
                            <div style="font-size: 28px; font-weight: 600; color: #3b82f6;">${positiveEdgeBets.length}</div>
                        </div>
                        <div style="background: white; padding: 15px; border-radius: 6px;">
                            <div style="font-size: 12px; color: #1e40af; margin-bottom: 5px;">Win Rate on +Edge Bets</div>
                            <div style="font-size: 28px; font-weight: 600; color: ${positiveEdgeWinRate >= 55 ? '#10b981' : '#f59e0b'};">
                                ${positiveEdgeWinRate.toFixed(1)}%
                            </div>
                        </div>
                    </div>
                    <div style="margin-top: 15px; font-size: 13px; color: #1e40af;">
                        ${positiveEdgeWinRate >= 55 ? '‚úÖ <strong>Edge detection working!</strong> High-edge bets are winning more often.' :
                          positiveEdgeWinRate >= 50 ? 'üìä <strong>Edge detection okay.</strong> Slight advantage on high-edge bets.' :
                          '‚ùå <strong>Edge detection not working.</strong> High-edge bets aren\'t outperforming.'}
                    </div>
                </div>
                
                <div style="background: #fee2e2; padding: 20px; border-radius: 8px; border-left: 4px solid #ef4444;">
                    <h3 style="margin: 0 0 15px 0; color: #991b1b;">üí° Recommendations</h3>
                    <ul style="margin: 10px 0; padding-left: 20px; color: #7f1d1d; line-height: 1.8;">
                        ${improvement < 0 ? '<li><strong>Performance is declining.</strong> Consider resetting the model and retraining with only recent data.</li>' : ''}
                        ${positiveEdgeWinRate < 52 ? '<li><strong>High-edge bets aren\'t winning enough.</strong> Your edge calculations may be overestimating value. Be more conservative.</li>' : ''}
                        ${Object.values(calibrationBuckets).some(d => d.total > 5 && (d.actual / d.total * 100) - (d.predicted.reduce((a,b) => a+b, 0) / d.total) < -15) ?
                            '<li><strong>Model is overconfident.</strong> Lower your confidence in close calls (45-55% range).</li>' : ''}
                        ${winRate < 48 ? '<li><strong>Overall win rate is low.</strong> Focus on higher-probability bets (60%+) instead of close calls.</li>' : ''}
                        ${first50.length >= 50 && last50.length >= 50 && improvement > 3 ? 
                            '<li><strong>Model is learning well!</strong> Continue tracking bets to refine predictions.</li>' : ''}
                        <li><strong>Track more data.</strong> You have ${total} bets. Aim for 200+ for robust ML predictions.</li>
                    </ul>
                </div>
                
                <div style="background: #fef3c7; padding: 20px; border-radius: 8px; margin-top: 20px; border-left: 4px solid #f59e0b;">
                    <h3 style="margin: 0 0 15px 0; color: #92400e;">üîó Correlation Analysis</h3>
                    <p style="font-size: 13px; color: #78350f; margin-bottom: 15px;">
                        Do same-player or same-game parlays underperform due to correlation?
                    </p>
                    
                    ${(() => {
                        const savedParlays = JSON.parse(localStorage.getItem('savedParlays') || '[]').filter(p => p.result);
                        
                        const samePlayerParlays = savedParlays.filter(p => p.isSamePlayer);
                        const duplicatePlayerParlays = savedParlays.filter(p => p.hasDuplicatePlayers && !p.isSamePlayer);
                        const sameGameParlays = savedParlays.filter(p => p.isSameGame);
                        const uncorrelatedParlays = savedParlays.filter(p => !p.isSamePlayer && !p.hasDuplicatePlayers && !p.isSameGame);
                        
                        const samePlayerWins = samePlayerParlays.filter(p => p.result === 'WON').length;
                        const duplicateWins = duplicatePlayerParlays.filter(p => p.result === 'WON').length;
                        const sameGameWins = sameGameParlays.filter(p => p.result === 'WON').length;
                        const uncorrelatedWins = uncorrelatedParlays.filter(p => p.result === 'WON').length;
                        
                        const samePlayerRate = samePlayerParlays.length > 0 ? (samePlayerWins / samePlayerParlays.length * 100) : 0;
                        const duplicateRate = duplicatePlayerParlays.length > 0 ? (duplicateWins / duplicatePlayerParlays.length * 100) : 0;
                        const sameGameRate = sameGameParlays.length > 0 ? (sameGameWins / sameGameParlays.length * 100) : 0;
                        const uncorrelatedRate = uncorrelatedParlays.length > 0 ? (uncorrelatedWins / uncorrelatedParlays.length * 100) : 0;
                        
                        return `
                            <div style="background: white; padding: 15px; border-radius: 6px;">
                                <div style="padding: 10px 0; border-bottom: 1px solid #e5e7eb;">
                                    <div style="display: flex; justify-content: space-between;">
                                        <strong style="color: #1f2937;">Same-Player Parlays</strong>
                                        <span style="color: #6b7280;">${samePlayerParlays.length} parlays</span>
                                    </div>
                                    <div style="margin-top: 5px;">
                                        <span style="font-size: 12px; color: #6b7280;">Win Rate: </span>
                                        <span style="font-size: 16px; font-weight: 600; color: ${samePlayerRate >= uncorrelatedRate ? '#10b981' : '#ef4444'};">
                                            ${samePlayerRate.toFixed(1)}%
                                        </span>
                                        ${samePlayerParlays.length > 0 ? 
                                            ` <span style="font-size: 12px; color: ${samePlayerRate >= uncorrelatedRate ? '#10b981' : '#ef4444'};">
                                                (${samePlayerRate >= uncorrelatedRate ? '+' : ''}${(samePlayerRate - uncorrelatedRate).toFixed(1)}% vs uncorrelated)
                                            </span>` : ''}
                                    </div>
                                </div>
                                
                                <div style="padding: 10px 0; border-bottom: 1px solid #e5e7eb;">
                                    <div style="display: flex; justify-content: space-between;">
                                        <strong style="color: #1f2937;">Multiple Same-Player Legs</strong>
                                        <span style="color: #6b7280;">${duplicatePlayerParlays.length} parlays</span>
                                    </div>
                                    <div style="margin-top: 5px;">
                                        <span style="font-size: 12px; color: #6b7280;">Win Rate: </span>
                                        <span style="font-size: 16px; font-weight: 600; color: ${duplicateRate >= uncorrelatedRate ? '#10b981' : '#ef4444'};">
                                            ${duplicateRate.toFixed(1)}%
                                        </span>
                                        ${duplicatePlayerParlays.length > 0 ?
                                            ` <span style="font-size: 12px; color: ${duplicateRate >= uncorrelatedRate ? '#10b981' : '#ef4444'};">
                                                (${duplicateRate >= uncorrelatedRate ? '+' : ''}${(duplicateRate - uncorrelatedRate).toFixed(1)}% vs uncorrelated)
                                            </span>` : ''}
                                    </div>
                                </div>
                                
                                <div style="padding: 10px 0; border-bottom: 1px solid #e5e7eb;">
                                    <div style="display: flex; justify-content: space-between;">
                                        <strong style="color: #1f2937;">Same-Game Parlays</strong>
                                        <span style="color: #6b7280;">${sameGameParlays.length} parlays</span>
                                    </div>
                                    <div style="margin-top: 5px;">
                                        <span style="font-size: 12px; color: #6b7280;">Win Rate: </span>
                                        <span style="font-size: 16px; font-weight: 600; color: ${sameGameRate >= uncorrelatedRate ? '#10b981' : '#ef4444'};">
                                            ${sameGameRate.toFixed(1)}%
                                        </span>
                                        ${sameGameParlays.length > 0 ?
                                            ` <span style="font-size: 12px; color: ${sameGameRate >= uncorrelatedRate ? '#10b981' : '#ef4444'};">
                                                (${sameGameRate >= uncorrelatedRate ? '+' : ''}${(sameGameRate - uncorrelatedRate).toFixed(1)}% vs uncorrelated)
                                            </span>` : ''}
                                    </div>
                                </div>
                                
                                <div style="padding: 10px 0;">
                                    <div style="display: flex; justify-content: space-between;">
                                        <strong style="color: #1f2937;">Uncorrelated Parlays</strong>
                                        <span style="color: #6b7280;">${uncorrelatedParlays.length} parlays</span>
                                    </div>
                                    <div style="margin-top: 5px;">
                                        <span style="font-size: 12px; color: #6b7280;">Win Rate (Baseline): </span>
                                        <span style="font-size: 16px; font-weight: 600; color: #3b82f6;">
                                            ${uncorrelatedRate.toFixed(1)}%
                                        </span>
                                    </div>
                                </div>
                            </div>
                            
                            <div style="margin-top: 15px; font-size: 13px; color: #92400e;">
                                ${samePlayerRate < uncorrelatedRate - 10 && samePlayerParlays.length >= 5 ?
                                    '‚ùå <strong>Same-player parlays significantly underperform!</strong> High correlation confirmed. Avoid these.' :
                                    samePlayerParlays.length < 5 ?
                                    '‚è≥ Need more same-player parlay data to confirm correlation effects.' :
                                    '‚úÖ Correlation effects within expected range.'}
                            </div>
                        `;
                    })()}
                </div>
            `;
            
            content.innerHTML = html;
            modal.style.display = 'block';
        }
        
        // Train ML model on tracked bets
        async function trainMLModel() {
            // Collect bets from ALL sources
            // 1. Old trackedBets system
            const oldCompleteBets = trackedBets.filter(b => b.actualResult !== undefined && !b.excludeFromML);
            
            // 2. New savedParlays from Results & Tracking
            const savedParlays = JSON.parse(localStorage.getItem('savedParlays') || '[]');
            const newCompleteBets = [];
            
            savedParlays.filter(p => p.result).forEach(parlay => {
                // Extract individual legs with results for ML training
                parlay.legs.forEach(leg => {
                    if (leg.actualResult !== undefined && leg.hit !== undefined) {
                        // Convert to trackedBets format for ML
                        newCompleteBets.push({
                            player: leg.player,
                            prop_type: leg.prop_type || leg.propType,
                            line: parseFloat(leg.line),
                            bet: leg.bet,
                            projection: parseFloat(leg.projection || leg.adjusted_projection || 0),
                            hit_rate: parseFloat(leg.hit_rate || 50),
                            actualResult: parseFloat(leg.actualResult),
                            hit: leg.hit,
                            odds: parseInt(leg.odds || 0),
                            true_edge: parseFloat(leg.true_edge || 0),
                            opponent: leg.opponent || '',
                            source: 'savedParlays'
                        });
                    }
                });
            });
            
            // 3. trackedParlays (your 66 existing parlays)
            const trackedParlaysData = typeof trackedParlays !== 'undefined' ? trackedParlays : [];
            const historicalBets = [];
            
            trackedParlaysData.forEach(tp => {
                tp.legs.forEach(leg => {
                    if (leg.actualResult !== undefined && !leg.voided) {
                        // Determine if leg hit based on bet type
                        let legHit = false;
                        
                        // Handle YES/NO bets (moneyline, total_over, total_under, spread)
                        if (leg.bet === 'YES' || leg.bet === 'NO') {
                            legHit = leg.actualResult === leg.bet;
                        }
                        // Handle OVER/UNDER bets (player props)
                        else if (leg.bet === 'OVER' || leg.bet === 'UNDER') {
                            // Alt lines use >= and <=, regular lines use > and <
                            legHit = leg.is_alt_line ? 
                                ((leg.bet === 'OVER' && leg.actualResult >= leg.line) || 
                                 (leg.bet === 'UNDER' && leg.actualResult <= leg.line)) :
                                ((leg.bet === 'OVER' && leg.actualResult > leg.line) || 
                                 (leg.bet === 'UNDER' && leg.actualResult < leg.line));
                        }
                        
                        historicalBets.push({
                            player: leg.player,
                            prop_type: leg.propType,
                            line: parseFloat(leg.line) || 0,
                            bet: leg.bet,
                            projection: parseFloat(leg.projection || 0),
                            hit_rate: 50, // Default if not available
                            actualResult: leg.actualResult,
                            hit: legHit,
                            odds: parseInt(leg.odds || 0),
                            true_edge: 0,
                            opponent: '',
                            source: 'trackedParlays'
                        });
                    }
                });
            });
            
            // Combine all sources
            const completeBets = [...oldCompleteBets, ...newCompleteBets, ...historicalBets];
            
            if (completeBets.length < 10) {
                console.log('‚è≥ Not enough data to train ML model (need 10+, have ' + completeBets.length + ')');
                console.log('  - Old trackedBets:', oldCompleteBets.length);
                console.log('  - New savedParlays:', newCompleteBets.length);
                console.log('  - Historical parlays:', historicalBets.length);
                return false;
            }
            
            console.log('üß† Training ML model on ' + completeBets.length + ' bets...');
            console.log('  üìä Data sources:');
            console.log('     - Old system:', oldCompleteBets.length);
            console.log('     - New Results tab:', newCompleteBets.length);
            console.log('     - Historical parlays:', historicalBets.length);
            
            await initializeMLModel();
            
            // Prepare training data
            const features = completeBets.map(bet => prepareFeatures(bet));
            const labels = completeBets.map(bet => parseFloat(bet.actualResult) / 100);
            
            const xs = tf.tensor2d(features);
            const ys = tf.tensor2d(labels, [labels.length, 1]);
            
            // Train the model
            await mlModel.fit(xs, ys, {
                epochs: 50,
                batchSize: 8,
                validationSplit: 0.2,
                verbose: 0,
                callbacks: {
                    onEpochEnd: (epoch, logs) => {
                        if (epoch % 10 === 0) {
                            console.log(`Epoch ${epoch}: loss = ${logs.loss.toFixed(4)}, mae = ${logs.mae.toFixed(4)}`);
                        }
                    }
                }
            });
            
            // Cleanup tensors
            xs.dispose();
            ys.dispose();
            
            mlModelTrained = true;
            console.log('‚úÖ ML model trained successfully!');
            return true;
        }
        
        // Get ML prediction with confidence interval
        async function getMLPrediction(bet) {
            if (!mlModelTrained) {
                await trainMLModel();
            }
            
            if (!mlModelTrained) {
                return null; // Not enough data
            }
            
            const features = prepareFeatures(bet);
            const input = tf.tensor2d([features]);
            
            // Get prediction
            const predictionTensor = mlModel.predict(input);
            const prediction = (await predictionTensor.data())[0] * 100;
            
            // Cleanup
            input.dispose();
            predictionTensor.dispose();
            
            // Calculate confidence interval (simple approach using std dev)
            const stdDev = parseFloat(bet.std_dev || 3);
            const confidenceInterval = stdDev * 1.5; // ~90% confidence
            
            return {
                prediction: prediction,
                lower: prediction - confidenceInterval,
                upper: prediction + confidenceInterval,
                confidence: confidenceInterval
            };
        }
        
        // Ensemble prediction: combine ML + weighted average
        async function getEnsemblePrediction(bet) {
            const weightedAvg = parseFloat(bet.weighted_avg || bet.adjusted_projection);
            
            // If ML not trained yet, just use weighted average
            if (!mlModelTrained || trackedBets.filter(b => b.actualResult).length < 10) {
                return {
                    prediction: weightedAvg,
                    method: 'weighted_avg',
                    confidence: parseFloat(bet.std_dev || 3) * 1.5,
                    mlUsed: false
                };
            }
            
            // Get ML prediction
            const mlPred = await getMLPrediction(bet);
            
            if (!mlPred) {
                return {
                    prediction: weightedAvg,
                    method: 'weighted_avg',
                    confidence: parseFloat(bet.std_dev || 3) * 1.5,
                    mlUsed: false
                };
            }
            
            // Ensemble: 60% ML, 40% weighted average (ML gets more weight as it improves)
            const dataPoints = trackedBets.filter(b => b.actualResult).length;
            const mlWeight = Math.min(0.7, 0.3 + (dataPoints / 100)); // Max 70% weight for ML
            const avgWeight = 1 - mlWeight;
            
            const ensemble = (mlPred.prediction * mlWeight) + (weightedAvg * avgWeight);
            
            return {
                prediction: ensemble,
                mlPrediction: mlPred.prediction,
                weightedAvg: weightedAvg,
                mlWeight: mlWeight,
                method: 'ensemble',
                confidence: mlPred.confidence,
                lower: ensemble - mlPred.confidence,
                upper: ensemble + mlPred.confidence,
                mlUsed: true
            };
        }
        
        window.switchSport = function(sport) {
            console.log('üîÑ Switching to:', sport);
            window.currentSport = sport;
            
            // Update button styles
            document.querySelectorAll('.sport-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(sport + '-btn').classList.add('active');
            
            // Update sport labels in Quick Scan tab
            const sportIcon = document.getElementById('sport-icon');
            const sportName = document.getElementById('sport-name');
            
            // Update sport labels in By Game tab
            const gameSportIcon = document.getElementById('game-sport-icon');
            const gameSportName = document.getElementById('game-sport-name');
            const gameSearchLabel = document.getElementById('game-search-label');
            const gameSearchInput = document.getElementById('game-search');
            
            // Update sport labels in Manual Entry tab
            const manualSportIcon = document.getElementById('manual-sport-icon');
            const manualSportName = document.getElementById('manual-sport-name');
            const manualPlayerInput = document.getElementById('manual-player');
            const manualOpponentInput = document.getElementById('manual-opponent');
            const manualOpponentLabel = document.getElementById('manual-opponent-label');
            const manualOpponentHelp = document.getElementById('manual-opponent-help');
            const manualHomeInput = document.getElementById('manual-home-team');
            const manualHomeLabel = document.getElementById('manual-home-label');
            const manualHomeHelp = document.getElementById('manual-home-help');
            const manualRecentInput = document.getElementById('manual-recent-games');
            const manualRecentLabel = document.getElementById('manual-recent-label');
            const manualRecentHelp = document.getElementById('manual-recent-help');
            const manualPropType = document.getElementById('manual-prop-type');
            const autoFetchSection = document.getElementById('auto-fetch-section');
            
            // Update sport labels in Moneyline tab
            const moneylineSportIcon = document.getElementById('moneyline-sport-icon');
            const moneylineSportName = document.getElementById('moneyline-sport-name');
            const mlAwayTeam = document.getElementById('ml-away-team');
            const mlHomeTeam = document.getElementById('ml-home-team');
            
            // Update sport labels in Custom tab
            const customSportIcon = document.getElementById('custom-sport-icon');
            const customSportName = document.getElementById('custom-sport-name');
            const customPlayerInput = document.getElementById('custom-players');
            const customPropsSelect = document.getElementById('custom-props');
            
            // Update sport labels in Multi-Player tab
            const mpPropsSelect = document.getElementById('mp-props');
            
            if (sport === 'nfl') {
                if (sportIcon) sportIcon.textContent = 'üèà';
                if (sportName) sportName.textContent = 'NFL';
                if (gameSportIcon) gameSportIcon.textContent = 'üèà';
                if (gameSportName) gameSportName.textContent = 'NFL';
                if (gameSearchLabel) gameSearchLabel.textContent = 'Enter Game (e.g., "Colts vs 49ers" or "IND SF")';
                if (gameSearchInput) gameSearchInput.placeholder = 'Colts vs 49ers';
                if (manualSportIcon) manualSportIcon.textContent = 'üèà';
                if (manualSportName) manualSportName.textContent = 'NFL';
                if (customSportIcon) customSportIcon.textContent = 'üèà';
                if (customSportName) customSportName.textContent = 'NFL';
                if (manualPlayerInput) manualPlayerInput.placeholder = 'Jonathan Taylor';
                if (manualOpponentInput) manualOpponentInput.placeholder = 'PHI, DAL, KC';
                if (manualOpponentLabel) manualOpponentLabel.textContent = 'Opponent (optional - for defense adjustment)';
                if (manualOpponentHelp) manualOpponentHelp.textContent = 'Enter NFL team abbreviation to adjust projection based on defensive strength';
                if (manualHomeInput) {
                    manualHomeInput.placeholder = 'Atlanta Falcons';
                    manualHomeInput.style.display = 'block';
                    manualHomeInput.previousElementSibling.style.display = 'block'; // Show label
                    if (manualHomeHelp) manualHomeHelp.style.display = 'block';
                }
                if (manualRecentInput) manualRecentInput.placeholder = '73, 53, 89, 81, 30, 64, 103';
                if (manualRecentLabel) manualRecentLabel.textContent = 'Recent Games (last 7 games)';
                if (manualRecentHelp) {
                    manualRecentHelp.innerHTML = 'Get stats from <a href="https://www.pro-football-reference.com" target="_blank" style="color: #3b82f6; text-decoration: underline;">Pro-Football-Reference</a> ‚Üí Search player ‚Üí Game Logs ‚Üí Copy last 7 games';
                }
                if (moneylineSportIcon) moneylineSportIcon.textContent = 'üèà';
                if (moneylineSportName) moneylineSportName.textContent = 'NFL';
                if (mlAwayTeam) mlAwayTeam.placeholder = 'Carolina Panthers';
                if (mlHomeTeam) mlHomeTeam.placeholder = 'Tampa Bay Buccaneers';
                
                // Update prop type dropdown for NFL
                if (manualPropType) {
                    manualPropType.innerHTML = `
                        <option value="pass_yds">Passing Yards</option>
                        <option value="pass_tds">Passing TDs</option>
                        <option value="rush_yds">Rushing Yards</option>
                        <option value="rush_tds">Rushing TDs</option>
                        <option value="receptions">Receptions</option>
                        <option value="reception_yds">Receiving Yards</option>
                        <option value="rec_tds">Receiving TDs</option>
                    `;
                }
                
                // Hide opponent dropdown for NFL (NBA only for now)
                const opponentSelect = document.getElementById('manual-opponent-team');
                if (opponentSelect && opponentSelect.parentElement) {
                    opponentSelect.parentElement.style.display = 'none';
                }
                
                // Update Alt Lines opponent dropdown for NFL
                const altOpponentSelect = document.getElementById('alt-opponent-team');
                if (altOpponentSelect) {
                    altOpponentSelect.innerHTML = `
                        <option value="">-- Select Opponent --</option>
                        <option value="ARI">Arizona Cardinals</option>
                        <option value="ATL">Atlanta Falcons</option>
                        <option value="BAL">Baltimore Ravens</option>
                        <option value="BUF">Buffalo Bills</option>
                        <option value="CAR">Carolina Panthers</option>
                        <option value="CHI">Chicago Bears</option>
                        <option value="CIN">Cincinnati Bengals</option>
                        <option value="CLE">Cleveland Browns</option>
                        <option value="DAL">Dallas Cowboys</option>
                        <option value="DEN">Denver Broncos</option>
                        <option value="DET">Detroit Lions</option>
                        <option value="GB">Green Bay Packers</option>
                        <option value="HOU">Houston Texans</option>
                        <option value="IND">Indianapolis Colts</option>
                        <option value="JAX">Jacksonville Jaguars</option>
                        <option value="KC">Kansas City Chiefs</option>
                        <option value="LV">Las Vegas Raiders</option>
                        <option value="LAC">LA Chargers</option>
                        <option value="LAR">LA Rams</option>
                        <option value="MIA">Miami Dolphins</option>
                        <option value="MIN">Minnesota Vikings</option>
                        <option value="NE">New England Patriots</option>
                        <option value="NO">New Orleans Saints</option>
                        <option value="NYG">New York Giants</option>
                        <option value="NYJ">New York Jets</option>
                        <option value="PHI">Philadelphia Eagles</option>
                        <option value="PIT">Pittsburgh Steelers</option>
                        <option value="SF">San Francisco 49ers</option>
                        <option value="SEA">Seattle Seahawks</option>
                        <option value="TB">Tampa Bay Buccaneers</option>
                        <option value="TEN">Tennessee Titans</option>
                        <option value="WAS">Washington Commanders</option>
                    `;
                }
                
                // Update Custom tab for NFL
                if (customPlayerInput) {
                    customPlayerInput.placeholder = 'Lamar Jackson, Saquon Barkley, CeeDee Lamb';
                }
                if (customPropsSelect) {
                    customPropsSelect.innerHTML = `
                        <option value="player_pass_yds">Passing Yards</option>
                        <option value="player_pass_tds">Passing TDs</option>
                        <option value="player_rush_yds">Rushing Yards</option>
                        <option value="player_rush_tds">Rushing TDs</option>
                        <option value="player_receptions">Receptions</option>
                        <option value="player_reception_yds">Receiving Yards</option>
                        <option value="player_rec_tds">Receiving TDs</option>
                    `;
                }
                
                // Update Multi-Player tab for NFL
                if (mpPropsSelect) {
                    mpPropsSelect.innerHTML = `
                        <option value="pass_yds">Passing Yards</option>
                        <option value="pass_tds">Passing TDs</option>
                        <option value="rush_yds">Rushing Yards</option>
                        <option value="rush_tds">Rushing TDs</option>
                        <option value="receptions">Receptions</option>
                        <option value="reception_yds">Receiving Yards</option>
                        <option value="rec_tds">Receiving TDs</option>
                    `;
                }
                
                // Hide auto-fetch section for NFL (not implemented yet)
                if (autoFetchSection) {
                    autoFetchSection.style.display = 'none';
                }
                
                // Hide manual entry helper for NFL
                const manualHelper = document.getElementById('manual-entry-helper');
                if (manualHelper) {
                    manualHelper.style.display = 'none';
                }
                
            } else if (sport === 'nba') {
                if (sportIcon) sportIcon.textContent = 'üèÄ';
                if (sportName) sportName.textContent = 'NBA';
                if (gameSportIcon) gameSportIcon.textContent = 'üèÄ';
                if (gameSportName) gameSportName.textContent = 'NBA';
                if (gameSearchLabel) gameSearchLabel.textContent = 'Enter Game (e.g., "Lakers vs Celtics" or "LAL BOS")';
                if (gameSearchInput) gameSearchInput.placeholder = 'Lakers vs Celtics';
                if (manualSportIcon) manualSportIcon.textContent = 'üèÄ';
                if (manualSportName) manualSportName.textContent = 'NBA';
                if (customSportIcon) customSportIcon.textContent = 'üèÄ';
                if (customSportName) customSportName.textContent = 'NBA';
                if (manualPlayerInput) manualPlayerInput.placeholder = 'LeBron James';
                if (manualOpponentInput) manualOpponentInput.placeholder = 'BOS, GSW, MIA';
                if (manualOpponentLabel) manualOpponentLabel.textContent = 'Opponent (optional - for reference)';
                if (manualOpponentHelp) manualOpponentHelp.textContent = 'Enter NBA team abbreviation (not used for adjustments currently)';
                if (manualHomeInput) {
                    manualHomeInput.style.display = 'none';
                    manualHomeInput.previousElementSibling.style.display = 'none'; // Hide label
                    if (manualHomeHelp) manualHomeHelp.style.display = 'none';
                }
                if (manualRecentInput) manualRecentInput.placeholder = '25, 32, 28, 31, 27, 24, 30';
                if (manualRecentLabel) manualRecentLabel.textContent = 'Recent Games (last 7 games)';
                if (manualRecentHelp) {
                    manualRecentHelp.innerHTML = 'Get stats from <a href="https://www.basketball-reference.com" target="_blank" style="color: #3b82f6; text-decoration: underline;">Basketball-Reference</a> ‚Üí Search player ‚Üí Game Logs ‚Üí Copy last 7 games';
                }
                if (moneylineSportIcon) moneylineSportIcon.textContent = 'üèÄ';
                if (moneylineSportName) moneylineSportName.textContent = 'NBA';
                if (mlAwayTeam) mlAwayTeam.placeholder = 'Los Angeles Lakers';
                if (mlHomeTeam) mlHomeTeam.placeholder = 'Boston Celtics';
                
                // Update prop type dropdown for NBA
                if (manualPropType) {
                    manualPropType.innerHTML = `
                        <option value="points">Points</option>
                        <option value="rebounds">Rebounds</option>
                        <option value="assists">Assists</option>
                        <option value="threes">3-Pointers Made</option>
                        <option value="pts_rebs_asts">Pts + Rebs + Asts (PRA)</option>
                        <option value="pts_rebs">Pts + Rebs</option>
                        <option value="pts_asts">Pts + Asts</option>
                        <option value="rebs_asts">Rebs + Asts</option>
                        <option value="blocks">Blocks</option>
                        <option value="steals">Steals</option>
                    `;
                }
                
                // Show auto-fetch section for NBA
                if (autoFetchSection) {
                    autoFetchSection.style.display = 'none'; // Disabled due to CORS issues
                }
                
                // Show manual entry helper instead
                const manualHelper = document.getElementById('manual-entry-helper');
                if (manualHelper) {
                    manualHelper.style.display = 'block';
                }
                
                // Update opponent dropdown for NBA (Manual Entry)
                const opponentSelect = document.getElementById('manual-opponent-team');
                if (opponentSelect) {
                    if (opponentSelect.parentElement) {
                        opponentSelect.parentElement.style.display = 'block';
                    }
                    opponentSelect.innerHTML = '<option value="">-- Select Opponent (for defense adjustment) --</option>';
                    NBA_TEAMS.forEach(team => {
                        opponentSelect.innerHTML += `<option value="${team}">${team}</option>`;
                    });
                }
                
                // Update opponent dropdown for NBA (Alt Lines)
                const altOpponentSelect = document.getElementById('alt-opponent-team');
                if (altOpponentSelect) {
                    altOpponentSelect.innerHTML = `
                        <option value="">-- Select Opponent --</option>
                        <option value="ATL">Atlanta Hawks</option>
                        <option value="BOS">Boston Celtics</option>
                        <option value="BKN">Brooklyn Nets</option>
                        <option value="CHA">Charlotte Hornets</option>
                        <option value="CHI">Chicago Bulls</option>
                        <option value="CLE">Cleveland Cavaliers</option>
                        <option value="DAL">Dallas Mavericks</option>
                        <option value="DEN">Denver Nuggets</option>
                        <option value="DET">Detroit Pistons</option>
                        <option value="GSW">Golden State Warriors</option>
                        <option value="HOU">Houston Rockets</option>
                        <option value="IND">Indiana Pacers</option>
                        <option value="LAC">LA Clippers</option>
                        <option value="LAL">LA Lakers</option>
                        <option value="MEM">Memphis Grizzlies</option>
                        <option value="MIA">Miami Heat</option>
                        <option value="MIL">Milwaukee Bucks</option>
                        <option value="MIN">Minnesota Timberwolves</option>
                        <option value="NOP">New Orleans Pelicans</option>
                        <option value="NYK">New York Knicks</option>
                        <option value="OKC">Oklahoma City Thunder</option>
                        <option value="ORL">Orlando Magic</option>
                        <option value="PHI">Philadelphia 76ers</option>
                        <option value="PHX">Phoenix Suns</option>
                        <option value="POR">Portland Trail Blazers</option>
                        <option value="SAC">Sacramento Kings</option>
                        <option value="SAS">San Antonio Spurs</option>
                        <option value="TOR">Toronto Raptors</option>
                        <option value="UTA">Utah Jazz</option>
                        <option value="WAS">Washington Wizards</option>
                    `;
                }
                
                // Update Custom tab for NBA
                if (customPlayerInput) {
                    customPlayerInput.placeholder = 'LeBron James, Stephen Curry, Giannis Antetokounmpo';
                }
                if (customPropsSelect) {
                    customPropsSelect.innerHTML = `
                        <option value="player_points">Points</option>
                        <option value="player_rebounds">Rebounds</option>
                        <option value="player_assists">Assists</option>
                        <option value="player_threes">3-Pointers Made</option>
                        <option value="player_pts_rebs_asts">Pts + Rebs + Asts</option>
                        <option value="player_pts_rebs">Pts + Rebs</option>
                        <option value="player_pts_asts">Pts + Asts</option>
                        <option value="player_rebs_asts">Rebs + Asts</option>
                        <option value="player_blocks">Blocks</option>
                        <option value="player_steals">Steals</option>
                        <option value="player_turnovers">Turnovers</option>
                    `;
                }
                
                // Update Multi-Player tab for NBA
                if (mpPropsSelect) {
                    mpPropsSelect.innerHTML = `
                        <option value="points">Points</option>
                        <option value="rebounds">Rebounds</option>
                        <option value="assists">Assists</option>
                        <option value="threes">3-Pointers Made</option>
                        <option value="pts_rebs_asts">Pts + Rebs + Asts</option>
                        <option value="pts_rebs">Pts + Rebs</option>
                        <option value="pts_asts">Pts + Asts</option>
                        <option value="rebs_asts">Rebs + Asts</option>
                        <option value="blocks">Blocks</option>
                        <option value="steals">Steals</option>
                        <option value="turnovers">Turnovers</option>
                    `;
                }
            }
            
            // Clear all results
            const resultsDiv = document.getElementById('quick-results');
            if (resultsDiv) {
                resultsDiv.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #666;">
                        <h3 style="color: #333; margin-bottom: 10px;">Ready to scan ${sport.toUpperCase()} props!</h3>
                        <p>Click "Scan for Best Bets" to analyze ${sport.toUpperCase()} player props</p>
                    </div>
                `;
            }
            
            // Clear game results too
            const gameResultsDiv = document.getElementById('game-results');
            if (gameResultsDiv) {
                gameResultsDiv.innerHTML = '';
            }
            
            // Clear manual results
            const manualResultsDiv = document.getElementById('manual-results');
            if (manualResultsDiv) {
                manualResultsDiv.innerHTML = '';
            }
            
            // Update Manual Entry attempts/minutes sections visibility
            const attemptsSection = document.getElementById('manual-attempts-section');
            const minutesSection = document.getElementById('manual-minutes-section');
            if (sport === 'nfl') {
                if (attemptsSection) attemptsSection.style.display = 'block';
                if (minutesSection) minutesSection.style.display = 'none';
                // Trigger label update for current prop type
                if (typeof updateNFLAttemptsLabel === 'function') {
                    updateNFLAttemptsLabel();
                }
            } else {
                if (attemptsSection) attemptsSection.style.display = 'none';
                if (minutesSection) minutesSection.style.display = 'block';
                // Trigger NBA defense sections update
                if (typeof updateNBADefenseSections === 'function') {
                    updateNBADefenseSections();
                }
            }
            
            console.log('‚úÖ Switched to:', sport.toUpperCase());
        };
        
        const API_URL = 'http://localhost:5002';
        
        // Current sport tracker
        window.currentSport = 'nfl';
        let currentSport = 'nfl';
        
        // Function to update NFL attempts label based on prop type
        function updateNFLAttemptsLabel() {
            const propType = document.getElementById('manual-prop-type')?.value;
            const attemptsLabel = document.getElementById('manual-attempts-label');
            const attemptsHelp = document.getElementById('manual-attempts-help');
            const attemptsInput = document.getElementById('manual-recent-attempts');
            const completionsSection = document.getElementById('manual-completions-section');
            const completionsLabel = document.getElementById('manual-completions-label');
            const completionsInput = document.getElementById('manual-recent-completions');
            
            // Defense sections
            const defensePassSection = document.getElementById('defense-pass-section');
            const defenseRushSection = document.getElementById('defense-rush-section');
            
            // TD analyzer section
            const tdAnalyzerSection = document.getElementById('td-analyzer-section');
            
            // Line and odds section
            const lineOddsSection = document.getElementById('line-odds-section');
            
            if (!propType) return;
            
            // Hide all defense sections and TD analyzer first
            if (defensePassSection) defensePassSection.style.display = 'none';
            if (defenseRushSection) defenseRushSection.style.display = 'none';
            if (tdAnalyzerSection) tdAnalyzerSection.style.display = 'none';
            
            // Check if this is a TD prop
            const isTDProp = propType === 'rush_tds' || propType === 'rec_tds' || propType === 'pass_tds';
            
            // Only rushing and receiving TDs use the special TD analyzer (Anytime/First/2+/3+)
            // Passing TDs have normal O/U lines
            const useTDAnalyzer = propType === 'rush_tds' || propType === 'rec_tds';
            
            if (useTDAnalyzer) {
                // Show TD analyzer section for rush/rec TDs
                if (tdAnalyzerSection) tdAnalyzerSection.style.display = 'block';
                
                // Hide line/odds section (not applicable for rush/rec TD props)
                if (lineOddsSection) lineOddsSection.style.display = 'none';
                
                // Hide attempts/completions sections for TD props
                completionsSection.style.display = 'none';
                
                // Update label for TD input
                const recentLabel = document.getElementById('manual-recent-label');
                const recentHelp = document.getElementById('manual-recent-help');
                if (recentLabel) recentLabel.textContent = 'Recent Touchdowns (last 7 games)';
                if (recentHelp) recentHelp.innerHTML = 'Enter number of TDs scored in each of last 7 games (e.g., 0, 1, 0, 1, 1, 0, 2)';
                
            } else if (propType === 'pass_tds') {
                // Passing TDs use normal O/U format (like 1.5 TDs)
                if (lineOddsSection) lineOddsSection.style.display = 'block';
                
                const recentLabel = document.getElementById('manual-recent-label');
                const recentHelp = document.getElementById('manual-recent-help');
                if (recentLabel) recentLabel.textContent = 'Recent Passing TDs (last 7 games)';
                if (recentHelp) recentHelp.innerHTML = 'Enter passing TDs thrown in each of last 7 games (e.g., 2, 1, 3, 2, 1, 2, 2)';
                
                // No special attempts for pass TDs
                attemptsLabel.textContent = 'Pass Attempts (optional - for context)';
                attemptsInput.placeholder = '35, 38, 33, 42, 37, 36, 39';
                attemptsHelp.innerHTML = '<strong>üí° Pro Feature:</strong> Enter pass attempts for volume context';
                completionsSection.style.display = 'none';
                
            } else {
                // Not a TD prop - show normal fields
                if (lineOddsSection) lineOddsSection.style.display = 'block';
                
                const recentLabel = document.getElementById('manual-recent-label');
                const recentHelp = document.getElementById('manual-recent-help');
                if (recentLabel) recentLabel.textContent = 'Recent Games (last 7 games)';
                if (recentHelp) recentHelp.innerHTML = 'Get stats from <a href="https://www.pro-football-reference.com" target="_blank" style="color: #3b82f6; text-decoration: underline;">Pro-Football-Reference</a> ‚Üí Search player ‚Üí Game Logs ‚Üí Copy last 7 games';
                
                if (propType === 'pass_yds') {
                    // Passing yards
                    attemptsLabel.textContent = 'Pass Attempts (optional - for yards per attempt)';
                    attemptsInput.placeholder = '35, 38, 33, 42, 37, 36, 39';
                    attemptsHelp.innerHTML = '<strong>üí° Pro Feature:</strong> Enter pass attempts for each game to calculate yards per attempt';
                    completionsSection.style.display = 'block';
                    completionsLabel.textContent = 'Completions (optional - for yards per completion)';
                    completionsInput.placeholder = '23, 28, 22, 31, 25, 24, 27';
                    if (defensePassSection) defensePassSection.style.display = 'block';
                } else if (propType === 'rush_yds') {
                    // Rushing yards
                    attemptsLabel.textContent = 'Rush Attempts (optional - for yards per carry)';
                    attemptsInput.placeholder = '18, 22, 15, 25, 20, 19, 23';
                    attemptsHelp.innerHTML = '<strong>üí° Pro Feature:</strong> Enter rush attempts for each game to calculate yards per carry';
                    completionsSection.style.display = 'none';
                    if (defenseRushSection) defenseRushSection.style.display = 'block';
                } else if (propType === 'reception_yds') {
                    // Receiving yards
                    attemptsLabel.textContent = 'Targets (optional - for yards per target)';
                    attemptsInput.placeholder = '8, 10, 6, 12, 9, 7, 11';
                    attemptsHelp.innerHTML = '<strong>üí° Pro Feature:</strong> Enter targets for each game to calculate yards per target';
                    completionsSection.style.display = 'block';
                    completionsLabel.textContent = 'Receptions (optional - for yards per reception)';
                    completionsInput.placeholder = '5, 7, 4, 9, 6, 5, 8';
                    if (defensePassSection) defensePassSection.style.display = 'block';
                } else if (propType === 'receptions') {
                    // Receptions (just targets needed)
                    attemptsLabel.textContent = 'Targets (optional - for catch rate)';
                    attemptsInput.placeholder = '8, 10, 6, 12, 9, 7, 11';
                    attemptsHelp.innerHTML = '<strong>üí° Pro Feature:</strong> Enter targets for each game to calculate catch rate';
                    completionsSection.style.display = 'none';
                    if (defensePassSection) defensePassSection.style.display = 'block';
                } else {
                    // Other props
                    attemptsLabel.textContent = 'Attempts (optional)';
                    attemptsInput.placeholder = '20, 25, 18, 22, 21, 19, 23';
                    attemptsHelp.innerHTML = '<strong>üí° Pro Feature:</strong> Enter attempts for volume context';
                    completionsSection.style.display = 'none';
                }
            }
        }
        
        // Function to update NBA defense sections based on prop type
        function updateNBADefenseSections() {
            const propType = document.getElementById('manual-prop-type')?.value;
            
            // Defense sections
            const defensePointsSection = document.getElementById('defense-points-section');
            const defenseReboundsSection = document.getElementById('defense-rebounds-section');
            const defenseAssistsSection = document.getElementById('defense-assists-section');
            
            if (!propType) return;
            
            // Hide all NBA defense sections first
            if (defensePointsSection) defensePointsSection.style.display = 'none';
            if (defenseReboundsSection) defenseReboundsSection.style.display = 'none';
            if (defenseAssistsSection) defenseAssistsSection.style.display = 'none';
            
            // Show relevant defense section based on prop type
            if (propType === 'points' || propType.includes('pts')) {
                if (defensePointsSection) defensePointsSection.style.display = 'block';
            } else if (propType === 'rebounds' || propType.includes('rebs')) {
                if (defenseReboundsSection) defenseReboundsSection.style.display = 'block';
            } else if (propType === 'assists' || propType.includes('asts')) {
                if (defenseAssistsSection) defenseAssistsSection.style.display = 'block';
            } else if (propType === 'threes') {
                // 3-pointers - use points defense
                if (defensePointsSection) defensePointsSection.style.display = 'block';
            }
        }
        
        // Add event listener for prop type changes (on page load)
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize results display
            updateResultsDisplay();
            
            const propTypeSelect = document.getElementById('manual-prop-type');
            if (propTypeSelect) {
                propTypeSelect.addEventListener('change', function() {
                    const sport = window.currentSport || 'nfl';
                    if (sport === 'nfl') {
                        updateNFLAttemptsLabel();
                    } else {
                        updateNBADefenseSections();
                    }
                });
                // Call immediately to set initial state
                updateNFLAttemptsLabel();
            }
            
            // Update auto-fetch button text when player name changes
            const playerInput = document.getElementById('manual-player');
            if (playerInput) {
                playerInput.addEventListener('input', function() {
                    const playerName = this.value.trim() || 'Player';
                    const fetchPlayerName = document.getElementById('fetch-player-name');
                    if (fetchPlayerName) {
                        fetchPlayerName.textContent = playerName;
                    }
                    // Also update manual entry helper
                    const helperPlayerName = document.getElementById('helper-player-name');
                    if (helperPlayerName) {
                        helperPlayerName.textContent = playerName;
                    }
                });
            }
        });
        
        // Auto-fetch NBA stats from Basketball Reference (NO BACKEND NEEDED!)
        async function autoFetchNBAStats() {
            const player = document.getElementById('manual-player').value.trim();
            const propType = document.getElementById('manual-prop-type').value;
            const btn = document.getElementById('auto-fetch-btn');
            
            if (!player) {
                alert('Please enter a player name first');
                return;
            }
            
            if (!propType) {
                alert('Please select a prop type first');
                return;
            }
            
            // Disable button and show loading
            btn.disabled = true;
            btn.innerHTML = '‚è≥ Searching for player...';
            
            try {
                // Step 1: Search for player to get their ID
                const searchQuery = encodeURIComponent(player);
                const searchUrl = `https://www.basketball-reference.com/search/search.fcgi?search=${searchQuery}`;
                
                // Use corsproxy.io - more reliable than allorigins
                const corsProxy = 'https://corsproxy.io/?';
                
                btn.innerHTML = '‚è≥ Finding player on Basketball-Reference...';
                const searchResponse = await fetch(corsProxy + encodeURIComponent(searchUrl));
                const searchHtml = await searchResponse.text();
                
                // Extract player ID from search results or redirect
                let playerId = null;
                
                // Check if we got redirected to player page (direct match)
                if (searchHtml.includes('/players/') && searchHtml.includes('/gamelog/')) {
                    const playerMatch = searchHtml.match(/\/players\/([a-z]\/[a-z]+\d+)/);
                    if (playerMatch) {
                        playerId = playerMatch[1];
                        console.log('Direct match found:', playerId);
                    }
                }
                
                // If not redirected, parse search results
                if (!playerId) {
                    // Look for ALL player result links
                    const allMatches = searchHtml.match(/href="\/players\/([a-z]\/[a-z]+\d+)\.html"/g);
                    
                    if (allMatches && allMatches.length > 0) {
                        // Extract all player IDs
                        const playerIds = allMatches.map(match => {
                            const m = match.match(/\/players\/([a-z]\/[a-z]+\d+)/);
                            return m ? m[1] : null;
                        }).filter(id => id !== null);
                        
                        console.log('Found player IDs:', playerIds);
                        
                        // Prefer IDs that end with 01 (usually the main player)
                        // For Donovan Mitchell: mitchdo01 is current, mitchdo02 might be older
                        playerId = playerIds.find(id => id.endsWith('01')) || playerIds[0];
                        
                        console.log('Selected player ID:', playerId);
                    }
                }
                
                if (!playerId) {
                    throw new Error(`Could not find player "${player}". Try full name (e.g., "LeBron James")`);
                }
                
                console.log('Found player ID:', playerId);
                
                // Step 2: Fetch game log
                btn.innerHTML = '‚è≥ Fetching last 7 games...';
                const gamelogUrl = `https://www.basketball-reference.com/players/${playerId}/gamelog/2026`;
                console.log('Fetching game log from:', gamelogUrl);
                
                const gamelogResponse = await fetch(corsProxy + encodeURIComponent(gamelogUrl));
                const gamelogHtml = await gamelogResponse.text();
                
                // Parse game log table
                const parser = new DOMParser();
                const doc = parser.parseFromString(gamelogHtml, 'text/html');
                
                // Find the game log table - try multiple selectors
                let table = doc.querySelector('#pgl_basic');
                
                if (!table) {
                    // Try alternative selector
                    table = doc.querySelector('table.stats_table');
                }
                
                if (!table) {
                    // Try finding ANY table with game log data
                    const tables = doc.querySelectorAll('table');
                    console.log('Found tables:', tables.length);
                    
                    // Look for table with stat columns
                    for (let t of tables) {
                        const hasPts = t.querySelector('td[data-stat="pts"]');
                        if (hasPts) {
                            table = t;
                            console.log('Found game log table by pts column');
                            break;
                        }
                    }
                }
                
                if (!table) {
                    console.error('Available tables:', doc.querySelectorAll('table').length);
                    console.error('Page title:', doc.querySelector('title')?.textContent);
                    
                    // Try 2025 season as fallback
                    const gamelogUrl2025 = `https://www.basketball-reference.com/players/${playerId}/gamelog/2025`;
                    console.log('Trying 2025 season:', gamelogUrl2025);
                    
                    const response2025 = await fetch(corsProxy + encodeURIComponent(gamelogUrl2025));
                    const html2025 = await response2025.text();
                    const doc2025 = parser.parseFromString(html2025, 'text/html');
                    
                    table = doc2025.querySelector('#pgl_basic') || doc2025.querySelector('table.stats_table');
                    
                    if (!table) {
                        throw new Error('Game log table not found for 2025 or 2026 season');
                    }
                    
                    console.log('Using 2025 season data');
                }
                
                // VERIFY TABLE STRUCTURE - Check column headers
                const thead = table.querySelector('thead');
                if (thead) {
                    const headers = thead.querySelectorAll('th');
                    const headerTexts = Array.from(headers).map(h => h.textContent.trim());
                    console.log('Table headers:', headerTexts);
                    
                    // Verify we have the expected columns
                    const hasPTS = Array.from(headers).some(h => h.getAttribute('data-stat') === 'pts');
                    const hasMP = Array.from(headers).some(h => h.getAttribute('data-stat') === 'mp');
                    console.log('Has PTS column:', hasPTS);
                    console.log('Has MP column:', hasMP);
                }
                
                // Map prop types to column names
                const statColumns = {
                    'points': 'pts',
                    'assists': 'ast',
                    'rebounds': 'trb',
                    'threes': 'fg3',
                    'blocks': 'blk',
                    'steals': 'stl'
                };
                
                const statCol = statColumns[propType];
                if (!statCol) {
                    throw new Error(`Stat type "${propType}" not supported`);
                }
                
                // Extract last 7 games
                const tbody = table.querySelector('tbody');
                const rows = tbody.querySelectorAll('tr');
                
                const games = [];
                const minutes = [];
                
                let gamesFound = 0;
                console.log(`Total rows in table: ${rows.length}`);
                
                for (let row of rows) {
                    // Skip header rows (they have class 'thead')
                    if (row.classList.contains('thead')) {
                        console.log('Skipping header row');
                        continue;
                    }
                    
                    // Skip rows without a game number (playoff games, etc.)
                    const rankerCell = row.querySelector('th[data-stat="ranker"]');
                    if (!rankerCell || !rankerCell.textContent.trim()) {
                        console.log('Skipping row without game number');
                        continue;
                    }
                    
                    // Get stat value
                    const statCell = row.querySelector(`td[data-stat="${statCol}"]`);
                    if (!statCell || !statCell.textContent.trim()) {
                        console.log('Skipping row without stat data');
                        continue;
                    }
                    
                    const statValue = parseFloat(statCell.textContent.trim());
                    if (isNaN(statValue)) {
                        console.log('Skipping row with invalid stat:', statCell.textContent);
                        continue;
                    }
                    
                    // DEBUG: Log the entire row's data to see what we're getting
                    const dateCell = row.querySelector('td[data-stat="date_game"]');
                    const oppCell = row.querySelector('td[data-stat="opp_id"]');
                    const gameDate = dateCell ? dateCell.textContent.trim() : 'Unknown';
                    const opponent = oppCell ? oppCell.textContent.trim() : 'Unknown';
                    
                    games.push(statValue);
                    console.log(`Game ${gamesFound + 1} [${gameDate} vs ${opponent}]: ${statValue} ${propType}`);
                    
                    // Get minutes
                    const minCell = row.querySelector('td[data-stat="mp"]');
                    if (minCell && minCell.textContent.trim()) {
                        const minText = minCell.textContent.trim();
                        if (minText.includes(':')) {
                            const [mins, secs] = minText.split(':');
                            const totalMins = parseInt(mins) + (parseInt(secs) / 60);
                            minutes.push(Math.round(totalMins * 10) / 10);
                            console.log(`  Minutes: ${Math.round(totalMins * 10) / 10}`);
                        } else {
                            const minValue = parseFloat(minText);
                            if (!isNaN(minValue)) {
                                minutes.push(minValue);
                                console.log(`  Minutes: ${minValue}`);
                            } else {
                                minutes.push(0);
                                console.log(`  Minutes: 0 (invalid)`);
                            }
                        }
                    } else {
                        minutes.push(0);
                        console.log(`  Minutes: 0 (no data)`);
                    }
                    
                    gamesFound++;
                    
                    // Stop after 7 games
                    if (gamesFound >= 7) {
                        console.log('Found 7 games, stopping');
                        break;
                    }
                }
                
                if (games.length === 0) {
                    throw new Error('No recent games found. Player may be injured or not playing.');
                }
                
                console.log('Final games array:', games);
                console.log('Final minutes array:', minutes);
                
                // Auto-fill the form
                document.getElementById('manual-recent-games').value = games.join(', ');
                
                if (minutes.length > 0 && minutes.some(m => m > 0)) {
                    document.getElementById('manual-recent-minutes').value = minutes.join(', ');
                }
                
                // Show success message with details
                alert(`‚úÖ Stats fetched successfully!\n\nPlayer: ${player}\nGames: ${games.length}\nStats (most recent first): ${games.join(', ')}\n${minutes.length > 0 ? 'Minutes: ' + minutes.join(', ') : ''}\n\nSource: Basketball-Reference.com\n\n‚ö†Ô∏è IMPORTANT: Games are listed NEWEST to OLDEST (most recent game first). Please verify these match the player's actual last 7 games before analyzing.`);
                
            } catch (error) {
                console.error('Auto-fetch error:', error);
                alert(`‚ùå Error: ${error.message}\n\nPlease enter stats manually.`);
            } finally {
                // Re-enable button
                btn.disabled = false;
                btn.innerHTML = `üîç Auto-Fetch Stats for ${player}`;
            }
        }
        
        window.showTab = function(tab) {
            console.log('Switching to tab:', tab);
            
            try {
                // Hide all tab contents
                const allTabContents = document.querySelectorAll('.tab-content');
                console.log('Found tab contents:', allTabContents.length);
                allTabContents.forEach(el => el.classList.remove('active'));
                
                // Remove active class from all tab buttons
                const allTabs = document.querySelectorAll('.tab');
                console.log('Found tab buttons:', allTabs.length);
                allTabs.forEach(el => el.classList.remove('active'));
                
                // Show the selected tab content
                const tabContent = document.getElementById(tab + '-tab');
                console.log('Target tab content:', tab + '-tab', tabContent);
                if (tabContent) {
                    tabContent.classList.add('active');
                    console.log('Activated tab content');
                } else {
                    console.error('Tab content not found:', tab + '-tab');
                }
                
                // Find and activate the corresponding tab button by matching onclick
                allTabs.forEach(tabBtn => {
                    const onclick = tabBtn.getAttribute('onclick');
                    if (onclick && onclick.includes(`'${tab}'`)) {
                        tabBtn.classList.add('active');
                        console.log('Activated tab button');
                    }
                });
                
                // Update results displays when switching to results tab
                if (tab === 'results') {
                    updatePendingResultsDisplay();
                    updateRecentResultsDisplay();
                    updateStatsDisplay();
                }
                
                // Update analytics dashboard when switching to analytics tab
                if (tab === 'analytics') {
                    updateAnalyticsDashboard();
                }
            } catch (error) {
                console.error('Error in showTab:', error);
            }
        }
        
        // ==========================================
        // SMART SCANNER - Direct Odds API Integration
        // ==========================================
        
        const ODDS_API_BASE = 'https://api.the-odds-api.com/v4';
        const CALIBRATION_FACTOR = 0.854; // Your current calibration
        
        // Load/save API key
        function getOddsAPIKey() {
            const input = document.getElementById('odds-api-key');
            let key = input?.value || localStorage.getItem('oddsApiKey');
            if (key && input) {
                input.value = key;
                localStorage.setItem('oddsApiKey', key);
            }
            return key;
        }
        
        async function scanTodaysGames() {
            const apiKey = getOddsAPIKey();
            if (!apiKey) {
                alert('‚ö†Ô∏è Please enter your Odds API key first!\n\nGet a free key at: https://the-odds-api.com\n(500 requests/month free)');
                document.getElementById('odds-api-key').focus();
                return;
            }
            
            const resultsDiv = document.getElementById('quick-results');
            const btn = document.getElementById('scan-all-btn');
            const sport = window.currentSport || 'nfl';
            const sportKey = sport === 'nfl' ? 'americanfootball_nfl' : 'basketball_nba';
            
            btn.disabled = true;
            btn.textContent = '‚è≥ Scanning...';
            
            resultsDiv.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Fetching live ${sport.toUpperCase()} odds from The Odds API...</p>
                    <small style="display: block; margin-top: 10px; color: #6b7280;">This may take 30-60 seconds</small>
                </div>
            `;
            
            try {
                // Fetch player props for all games
                const propsUrl = `${ODDS_API_BASE}/sports/${sportKey}/events/latest/odds?apiKey=${apiKey}&regions=us&markets=player_points,player_rebounds,player_assists,player_threes&oddsFormat=american`;
                
                console.log('üì° Fetching props from Odds API...');
                const response = await fetch(propsUrl);
                
                if (!response.ok) {
                    throw new Error(`API Error: ${response.status} ${response.statusText}`);
                }
                
                const events = await response.json();
                console.log(`‚úÖ Fetched ${events.length} games`);
                
                if (events.length === 0) {
                    throw new Error('No games found for today');
                }
                
                // Analyze all props
                const allBets = [];
                const minHitRate = parseFloat(document.getElementById('scan-min-hit-rate').value) || 55;
                const minEdge = parseFloat(document.getElementById('scan-min-edge').value) || 10;
                
                for (const event of events) {
                    if (!event.bookmakers || event.bookmakers.length === 0) continue;
                    
                    for (const bookmaker of event.bookmakers) {
                        for (const market of bookmaker.markets) {
                            for (const outcome of market.outcomes) {
                                const analysis = await analyzeQuickProp(outcome, market, event);
                                if (analysis && analysis.calibratedHitRate >= minHitRate && analysis.trueEdge >= minEdge) {
                                    analysis.bookmaker = bookmaker.title;
                                    allBets.push(analysis);
                                }
                            }
                        }
                    }
                }
                
                // Sort by true edge
                allBets.sort((a, b) => b.trueEdge - a.trueEdge);
                
                if (allBets.length === 0) {
                    resultsDiv.innerHTML = `
                        <div style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 8px; padding: 20px; text-align: center;">
                            <h3 style="color: #92400e; margin: 0 0 10px 0;">‚ö†Ô∏è No Qualifying Bets Found</h3>
                            <p style="color: #78350f; margin: 0; font-size: 14px;">
                                No props met your criteria (${minHitRate}% min hit rate, ${minEdge}% min edge)
                            </p>
                            <small style="display: block; margin-top: 10px; color: #78350f;">
                                Try lowering your minimum requirements
                            </small>
                        </div>
                    `;
                } else {
                    displaySmartScanResults(allBets);
                }
                
            } catch (error) {
                console.error('Scan error:', error);
                resultsDiv.innerHTML = `
                    <div style="background: #fee2e2; border: 2px solid #dc2626; border-radius: 8px; padding: 20px;">
                        <h3 style="color: #991b1b; margin: 0 0 10px 0;">‚ùå Error</h3>
                        <p style="color: #7f1d1d; margin: 0; font-size: 14px;">${error.message}</p>
                        <small style="display: block; margin-top: 10px; color: #7f1d1d;">
                            Check that your API key is correct and you haven't exceeded rate limits
                        </small>
                    </div>
                `;
            } finally {
                btn.disabled = false;
                btn.textContent = 'üîç Scan All Games Tonight';
            }
        }
        
        async function analyzeQuickProp(outcome, market, event) {
            // Extract player and prop info
            const playerName = outcome.description || outcome.name;
            const line = outcome.point;
            const odds = outcome.price;
            const propType = market.key; // e.g., 'player_points'
            
            if (!line || !odds) return null;
            
            // Simple projection (would need real stats for accuracy)
            // For now, use a basic heuristic
            const projection = line * 1.05; // Assume 5% above line as placeholder
            const rawHitRate = projection > line ? 60 : 40; // Placeholder
            
            // Apply calibration
            const calibratedHitRate = rawHitRate * CALIBRATION_FACTOR;
            
            // Calculate implied probability
            const impliedProb = odds > 0 ? 100 / (odds + 100) * 100 : Math.abs(odds) / (Math.abs(odds) + 100) * 100;
            
            // Calculate true edge
            const trueEdge = calibratedHitRate - impliedProb;
            
            return {
                player: playerName,
                propType: propType.replace('player_', ''),
                line: line,
                bet: 'OVER',
                odds: odds,
                projection: projection.toFixed(1),
                rawHitRate: rawHitRate.toFixed(1),
                calibratedHitRate: calibratedHitRate.toFixed(1),
                impliedProb: impliedProb.toFixed(1),
                trueEdge: trueEdge.toFixed(1),
                game: `${event.away_team} @ ${event.home_team}`
            };
        }
        
        function displaySmartScanResults(bets) {
            const resultsDiv = document.getElementById('quick-results');
            
            let html = `
                <div style="background: #d1fae5; border: 2px solid #10b981; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                    <h3 style="color: #065f46; margin: 0 0 5px 0;">‚úÖ Found ${bets.length} Qualifying Bets</h3>
                    <p style="color: #047857; margin: 0; font-size: 13px;">
                        Sorted by true edge (after 85.4% calibration applied)
                    </p>
                </div>
            `;
            
            bets.forEach((bet, index) => {
                const edgeColor = parseFloat(bet.trueEdge) > 15 ? '#10b981' : parseFloat(bet.trueEdge) > 10 ? '#f59e0b' : '#6b7280';
                
                html += `
                    <div style="background: white; border: 2px solid #e5e7eb; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <div>
                                <strong style="font-size: 16px; color: #1f2937;">${index + 1}. ${bet.player}</strong>
                                <div style="font-size: 13px; color: #6b7280; margin-top: 3px;">${bet.game}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 18px; font-weight: bold; color: ${edgeColor};">+${bet.trueEdge}%</div>
                                <div style="font-size: 11px; color: #9ca3af;">True Edge</div>
                            </div>
                        </div>
                        
                        <div style="font-size: 15px; font-weight: 600; color: #3b82f6; margin-bottom: 10px;">
                            ${bet.bet} ${bet.line} ${bet.propType}
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-bottom: 10px; font-size: 12px;">
                            <div>
                                <div style="color: #9ca3af;">Projection</div>
                                <strong>${bet.projection}</strong>
                            </div>
                            <div>
                                <div style="color: #9ca3af;">Hit Rate</div>
                                <strong>${bet.calibratedHitRate}%</strong>
                                <span style="font-size: 10px; color: #9ca3af;">(${bet.rawHitRate}% raw)</span>
                            </div>
                            <div>
                                <div style="color: #9ca3af;">Odds</div>
                                <strong>${bet.odds > 0 ? '+' : ''}${bet.odds}</strong>
                            </div>
                        </div>
                        
                        <div style="font-size: 11px; color: #6b7280; margin-bottom: 10px;">
                            ${bet.bookmaker} ‚Ä¢ Implied: ${bet.impliedProb}%
                        </div>
                        
                        <button onclick='addQuickBetToParlay(${JSON.stringify(bet).replace(/'/g, "\\'")})'
                                style="width: 100%; padding: 10px; background: #8b5cf6; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">
                            ‚ûï Add to Parlay
                        </button>
                    </div>
                `;
            });
            
            resultsDiv.innerHTML = html;
        }
        
        function addQuickBetToParlay(bet) {
            // Convert to standard bet format
            const standardBet = {
                player: bet.player,
                prop_type: bet.propType,
                bet: bet.bet,
                line: parseFloat(bet.line),
                odds: parseInt(bet.odds),
                bookmaker: bet.bookmaker,
                adjusted_projection: bet.projection,
                hit_rate: bet.calibratedHitRate,
                true_edge: bet.trueEdge,
                manual_games: false
            };
            
            // Add to parlay
            currentParlay.push(standardBet);
            localStorage.setItem('currentParlay', JSON.stringify(currentParlay));
            updateParlayDisplay();
            
            // Add to AI pool
            addToAIPool(standardBet);
            
            alert(`‚úÖ Added to parlay!\n\n${bet.player} ${bet.bet} ${bet.line} ${bet.propType}\n\nGo to Parlay Builder tab to see your parlay.`);
            showTab('parlay');
        }
        
        async function scanSpecificGame() {
            alert('üöß Specific game scanner coming soon!\n\nFor now, use "Scan All Games" to see all available props, or use Manual Entry for specific players.');
        }
        
        async function runQuickScan() {
            // Redirect to new Smart Scanner
            await scanTodaysGames();
        }
        
        // Game Analysis Mode Switcher
        let currentGameMode = 'manual'; // Default to manual since API often unavailable
        let todaysGames = [];
        let currentGameBets = [];
        
        function switchGameMode(mode) {
            currentGameMode = mode;
            
            const todayBtn = document.getElementById('mode-today-btn');
            const manualBtn = document.getElementById('mode-manual-btn');
            const todayMode = document.getElementById('today-games-mode');
            const manualMode = document.getElementById('manual-games-mode');
            
            if (mode === 'today') {
                // Style buttons
                todayBtn.style.background = '#3b82f6';
                todayBtn.style.color = 'white';
                todayBtn.style.borderColor = '#3b82f6';
                
                manualBtn.style.background = 'white';
                manualBtn.style.color = '#6b7280';
                manualBtn.style.borderColor = '#e5e7eb';
                
                // Show/hide modes
                todayMode.style.display = 'block';
                manualMode.style.display = 'none';
            } else {
                // Style buttons
                manualBtn.style.background = '#3b82f6';
                manualBtn.style.color = 'white';
                manualBtn.style.borderColor = '#3b82f6';
                
                todayBtn.style.background = 'white';
                todayBtn.style.color = '#6b7280';
                todayBtn.style.borderColor = '#e5e7eb';
                
                // Show/hide modes
                todayMode.style.display = 'none';
                manualMode.style.display = 'block';
            }
        }
        
        async function loadTodaysGames() {
            const select = document.getElementById('game-select');
            const btn = document.getElementById('load-games-btn');
            const sport = window.currentSport || 'nba';
            
            btn.disabled = true;
            btn.textContent = '‚è≥ Loading...';
            select.innerHTML = '<option value="">Loading games...</option>';
            
            try {
                // Try to load from API
                const response = await fetch(`${API_URL}/api/${sport}/today-games`, {
                    method: 'GET',
                    headers: {'Content-Type': 'application/json'},
                    timeout: 5000
                });
                
                if (!response.ok) {
                    throw new Error('API server not responding');
                }
                
                const data = await response.json();
                
                if (data.success && data.games && data.games.length > 0) {
                    todaysGames = data.games;
                    
                    select.innerHTML = '<option value="">-- Select a game --</option>';
                    data.games.forEach((game, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.textContent = game.matchup || `${game.away_team} @ ${game.home_team}`;
                        select.appendChild(option);
                    });
                    
                    document.getElementById('analyze-game-btn').disabled = false;
                    
                } else {
                    throw new Error('No games found for today');
                }
                
            } catch (error) {
                // Auto-switch to manual mode with helpful message
                select.innerHTML = '<option value="">Not available - use Manual Mode instead</option>';
                
                // Show helpful info box instead of alert
                const resultsDiv = document.getElementById('game-results');
                resultsDiv.innerHTML = `
                    <div style="background: #fef3c7; border: 2px solid #f59e0b; border-radius: 12px; padding: 20px; margin-top: 20px;">
                        <h3 style="margin: 0 0 15px 0; color: #92400e;">‚ö†Ô∏è Automatic Game Loading Not Available</h3>
                        <p style="color: #78350f; margin-bottom: 15px; line-height: 1.6;">
                            The API server isn't running or today's games aren't available. 
                            <strong>Please use Manual Entry mode instead.</strong>
                        </p>
                        <button onclick="switchGameMode('manual')" style="background: #3b82f6; color: white; border: none; padding: 12px 24px; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;">
                            ‚úçÔ∏è Switch to Manual Entry Mode
                        </button>
                    </div>
                `;
                
                console.log('API Error:', error.message);
            } finally {
                btn.disabled = false;
                btn.textContent = 'üîÑ Load Today\'s Games';
            }
        }
        
        async function analyzeSelectedGame() {
            const select = document.getElementById('game-select');
            const gameIndex = parseInt(select.value);
            const minEdge = parseFloat(document.getElementById('game-min-edge').value) || 3;
            const resultsDiv = document.getElementById('game-results');
            const btn = document.getElementById('analyze-game-btn');
            const sport = window.currentSport || 'nba';
            
            if (isNaN(gameIndex) || !todaysGames[gameIndex]) {
                alert('Please select a game first');
                return;
            }
            
            const game = todaysGames[gameIndex];
            
            btn.disabled = true;
            btn.textContent = '‚è≥ Analyzing...';
            
            resultsDiv.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Analyzing ${game.matchup || `${game.away_team} @ ${game.home_team}`}...</p>
                    <small>This may take 30-60 seconds</small>
                </div>
            `;
            
            try {
                // Call API to analyze game
                const response = await fetch(`${API_URL}/api/${sport}/analyze-game`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        game_id: game.id || game.event_id,
                        away_team: game.away_team,
                        home_team: game.home_team,
                        min_edge: minEdge
                    })
                });
                
                const data = await response.json();
                
                if (data.success && data.bets && data.bets.length > 0) {
                    currentGameBets = data.bets;
                    
                    const sportIcon = sport === 'nfl' ? 'üèà' : 'üèÄ';
                    resultsDiv.innerHTML = `
                        <div style="background: #e0f2fe; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <strong>${sportIcon} ${game.matchup || `${game.away_team} @ ${game.home_team}`}</strong><br>
                            <small>${data.bets.length} edges found with ${minEdge}%+ edge</small>
                        </div>
                    `;
                    
                    // Display bets
                    displayBets(data.bets, resultsDiv, true);
                    
                    // Enable parlay builder
                    document.getElementById('build-parlay-btn').disabled = false;
                    
                } else {
                    resultsDiv.innerHTML = `
                        <div class="empty-state">
                            <h3>No Edges Found</h3>
                            <p>No bets found with ${minEdge}%+ edge for this game.</p>
                            <small>Try lowering the minimum edge or try a different game</small>
                        </div>
                    `;
                }
                
            } catch (error) {
                resultsDiv.innerHTML = `
                    <div class="empty-state">
                        <h3>‚ùå Error</h3>
                        <p>${error.message}</p>
                        <p style="margin-top: 10px;">Try switching to <strong>Manual Entry</strong> mode and adding players yourself.</p>
                    </div>
                `;
            } finally {
                btn.disabled = false;
                btn.textContent = 'üìä Analyze This Game';
            }
        }
        
        function buildParlaysFromGame() {
            if (!currentGameBets || currentGameBets.length === 0) {
                alert('No bets available to build parlays. Analyze a game first!');
                return;
            }
            
            const numParlays = parseInt(document.getElementById('num-parlays').value) || 3;
            const legsPerParlay = parseInt(document.getElementById('parlay-legs').value) || 3;
            
            if (currentGameBets.length < legsPerParlay) {
                alert(`Not enough bets! Found ${currentGameBets.length} bets, but you requested ${legsPerParlay} legs per parlay.\n\nLower the minimum edge or select fewer legs.`);
                return;
            }
            
            // Sort bets by edge
            const sortedBets = [...currentGameBets].sort((a, b) => parseFloat(b.true_edge || b.edge_percent || 0) - parseFloat(a.true_edge || a.edge_percent || 0));
            
            // Build parlays
            const parlays = [];
            for (let i = 0; i < numParlays; i++) {
                const startIndex = i * legsPerParlay;
                if (startIndex + legsPerParlay > sortedBets.length) break;
                
                const legs = sortedBets.slice(startIndex, startIndex + legsPerParlay);
                parlays.push(legs);
            }
            
            // Display parlays
            displayAutoParlays(parlays);
        }
        
        function displayAutoParlays(parlays) {
            const resultsDiv = document.getElementById('parlay-results');
            
            let html = `
                <div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; padding: 20px; border-radius: 12px; margin-bottom: 20px;">
                    <h3 style="margin: 0 0 10px 0;">üé∞ Auto-Built Parlays (${parlays.length})</h3>
                    <p style="margin: 0; opacity: 0.9; font-size: 14px;">Based on highest true edge combinations</p>
                </div>
            `;
            
            parlays.forEach((legs, parlayIndex) => {
                // Calculate combined probability and odds
                let combinedProb = 1.0;
                let totalOdds = 1.0;
                
                legs.forEach(bet => {
                    const hitRate = parseFloat(bet.hit_rate) / 100;
                    combinedProb *= hitRate;
                    
                    const odds = parseInt(bet.odds);
                    const decimal = odds > 0 ? (odds / 100 + 1) : (100 / Math.abs(odds) + 1);
                    totalOdds *= decimal;
                });
                
                const americanOdds = totalOdds >= 2 ? Math.round((totalOdds - 1) * 100) : Math.round(-100 / (totalOdds - 1));
                const payout = americanOdds > 0 ? americanOdds : (100 / Math.abs(americanOdds)) * 100;
                
                html += `
                    <div style="background: white; border: 2px solid #e5e7eb; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h4 style="margin: 0; color: #1f2937;">Parlay #${parlayIndex + 1}</h4>
                            <div style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); color: white; padding: 8px 16px; border-radius: 20px; font-weight: bold;">
                                ${americanOdds > 0 ? '+' : ''}${americanOdds}
                            </div>
                        </div>
                        
                        <div style="display: grid; gap: 12px; margin-bottom: 15px;">
                `;
                
                legs.forEach(bet => {
                    html += `
                        <div style="background: #f9fafb; padding: 12px; border-radius: 8px; border-left: 4px solid #3b82f6;">
                            <strong>${bet.player}</strong> ${bet.bet} ${bet.line} ${formatPropTypeLabel(bet.prop_type)}<br>
                            <small style="color: #6b7280;">
                                ${bet.odds > 0 ? '+' : ''}${bet.odds} ‚Ä¢ 
                                ${bet.hit_rate}% hit rate ‚Ä¢ 
                                ${parseFloat(bet.true_edge || bet.edge_percent) > 0 ? '+' : ''}${(bet.true_edge || bet.edge_percent)}% edge
                            </small>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                        
                        <div style="background: #f0fdf4; padding: 15px; border-radius: 8px; border-left: 4px solid #22c55e;">
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center;">
                                <div>
                                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 4px;">Win Probability</div>
                                    <div style="font-size: 20px; font-weight: bold; color: #1f2937;">${(combinedProb * 100).toFixed(1)}%</div>
                                </div>
                                <div>
                                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 4px;">$100 Pays</div>
                                    <div style="font-size: 20px; font-weight: bold; color: #22c55e;">$${payout.toFixed(2)}</div>
                                </div>
                                <div>
                                    <div style="font-size: 12px; color: #6b7280; margin-bottom: 4px;">Expected Value</div>
                                    <div style="font-size: 20px; font-weight: bold; color: ${(combinedProb * payout - (1 - combinedProb) * 100) > 0 ? '#22c55e' : '#ef4444'};">
                                        $${((combinedProb * payout - (1 - combinedProb) * 100)).toFixed(2)}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            resultsDiv.innerHTML = html;
        }
        
        // Multi-Player Analysis System (Manual Mode)
        let multiPlayerList = [];
        let multiPlayerResults = [];
        
        function addPlayerToAnalysis() {
            const player = document.getElementById('mp-player').value;
            const recentGames = document.getElementById('mp-recent-games').value;
            const propsSelect = document.getElementById('mp-props');
            const selectedProps = Array.from(propsSelect.selectedOptions).map(opt => opt.value);
            
            if (!player || !recentGames || selectedProps.length === 0) {
                alert('Please fill in player name, recent games, and select at least one prop');
                return;
            }
            
            // Parse games
            const games = recentGames.split(',').map(g => parseFloat(g.trim())).filter(g => !isNaN(g));
            if (games.length === 0) {
                alert('Invalid games format. Use comma-separated numbers (e.g., 25, 32, 28)');
                return;
            }
            
            // Add to list
            multiPlayerList.push({
                player: player,
                games: games,
                props: selectedProps
            });
            
            // Update display
            updatePlayerList();
            
            // Clear inputs
            document.getElementById('mp-player').value = '';
            document.getElementById('mp-recent-games').value = '';
            propsSelect.selectedIndex = -1;
            
            // Enable analyze button
            document.getElementById('analyze-all-btn').disabled = false;
            
            // Update player count
            document.getElementById('player-count').textContent = multiPlayerList.length + 1;
        }
        
        function updatePlayerList() {
            const container = document.getElementById('player-list');
            
            if (multiPlayerList.length === 0) {
                container.innerHTML = '';
                return;
            }
            
            const sport = window.currentSport || 'nfl';
            const sportIcon = sport === 'nfl' ? 'üèà' : 'üèÄ';
            
            let html = `
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <strong>${sportIcon} Players to Analyze (${multiPlayerList.length})</strong>
                        <button onclick="clearPlayerList()" style="padding: 5px 10px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                            Clear All
                        </button>
                    </div>
                    <div style="display: grid; gap: 10px;">
            `;
            
            multiPlayerList.forEach((p, index) => {
                const propLabels = p.props.map(prop => formatPropTypeLabel(prop.replace('player_', ''))).join(', ');
                html += `
                    <div style="background: white; padding: 12px; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <strong>${p.player}</strong><br>
                            <small style="color: #666;">${propLabels} ‚Ä¢ ${p.games.length} games: ${p.games.join(', ')}</small>
                        </div>
                        <button onclick="removePlayer(${index})" style="padding: 5px 10px; background: #f87171; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                            Remove
                        </button>
                    </div>
                `;
            });
            
            html += `
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
        }
        
        function removePlayer(index) {
            multiPlayerList.splice(index, 1);
            updatePlayerList();
            document.getElementById('player-count').textContent = multiPlayerList.length + 1;
            
            if (multiPlayerList.length === 0) {
                document.getElementById('analyze-all-btn').disabled = true;
                document.getElementById('build-parlay-btn').disabled = true;
            }
        }
        
        function clearPlayerList() {
            if (!confirm(`Remove all ${multiPlayerList.length} players?`)) {
                return;
            }
            multiPlayerList = [];
            multiPlayerResults = [];
            updatePlayerList();
            document.getElementById('game-results').innerHTML = '';
            document.getElementById('parlay-results').innerHTML = '';
            document.getElementById('analyze-all-btn').disabled = true;
            document.getElementById('build-parlay-btn').disabled = true;
            document.getElementById('player-count').textContent = '1';
        }
        
        async function analyzeAllPlayers() {
            const resultsDiv = document.getElementById('game-results');
            const btn = document.getElementById('analyze-all-btn');
            const sport = window.currentSport || 'nfl';
            
            if (multiPlayerList.length === 0) {
                alert('Please add at least one player first');
                return;
            }
            
            btn.disabled = true;
            btn.textContent = '‚è≥ Analyzing...';
            
            resultsDiv.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Analyzing ${multiPlayerList.length} players...</p>
                </div>
            `;
            
            try {
                multiPlayerResults = [];
                let totalBets = 0;
                
                // Analyze each player
                for (const playerData of multiPlayerList) {
                    for (const propType of playerData.props) {
                        // Calculate projection
                        const weights = playerData.games.map((_, i) => i + 1);
                        const weightedSum = playerData.games.reduce((sum, game, i) => sum + game * weights[i], 0);
                        const projection = weightedSum / weights.reduce((a, b) => a + b, 0);
                        
                        // Calculate stats
                        const simpleAvg = playerData.games.reduce((sum, val) => sum + val, 0) / playerData.games.length;
                        const stdDev = calculateStdDev(playerData.games);
                        const cv = (stdDev / simpleAvg) * 100;
                        
                        // Store result
                        multiPlayerResults.push({
                            player: playerData.player,
                            prop_type: propType.replace('player_', ''),
                            projection: projection,
                            simple_avg: simpleAvg,
                            std_dev: stdDev,
                            cv: cv,
                            games: playerData.games,
                            sport: sport
                        });
                        
                        totalBets++;
                    }
                }
                
                // Display results
                const sportIcon = sport === 'nfl' ? 'üèà' : 'üèÄ';
                let html = `
                    <div style="background: #e0f2fe; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <strong>${sportIcon} Analysis Complete</strong><br>
                        <small>${multiPlayerList.length} players ‚Ä¢ ${totalBets} prop projections</small>
                    </div>
                `;
                
                // Group by player
                const grouped = {};
                multiPlayerResults.forEach(result => {
                    if (!grouped[result.player]) {
                        grouped[result.player] = [];
                    }
                    grouped[result.player].push(result);
                });
                
                // Display each player's results
                Object.keys(grouped).forEach(player => {
                    html += `
                        <div style="background: white; border: 1px solid #e5e7eb; border-radius: 8px; padding: 20px; margin-bottom: 15px;">
                            <h3 style="margin: 0 0 15px 0; color: #1f2937;">${player}</h3>
                            <div style="display: grid; gap: 12px;">
                    `;
                    
                    grouped[player].forEach(result => {
                        const propLabel = formatPropTypeLabel(result.prop_type);
                        const volatilityWarning = result.cv > 40 ? ' ‚ö†Ô∏è' : '';
                        
                        html += `
                            <div style="background: #f9fafb; padding: 15px; border-radius: 6px; border-left: 4px solid ${result.cv > 40 ? '#f59e0b' : '#10b981'};">
                                <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                                    <div>
                                        <strong style="font-size: 16px;">${propLabel}${volatilityWarning}</strong><br>
                                        <span style="font-size: 24px; font-weight: bold; color: #1f2937;">${result.projection.toFixed(1)}</span>
                                        <span style="font-size: 14px; color: #6b7280;"> projected</span>
                                    </div>
                                    <button onclick="useForManualEntry('${player}', '${result.prop_type}', '${result.games.join(',')}')" 
                                            style="padding: 8px 12px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600;">
                                        üìä Analyze in Manual Entry
                                    </button>
                                </div>
                                <div style="font-size: 13px; color: #6b7280; margin-top: 10px;">
                                    Simple Avg: ${result.simple_avg.toFixed(1)} | 
                                    Std Dev: ¬±${result.std_dev.toFixed(1)} | 
                                    CV: ${result.cv.toFixed(0)}%${result.cv > 40 ? ' (High Volatility)' : ''}
                                </div>
                                <div style="font-size: 12px; color: #9ca3af; margin-top: 8px;">
                                    Recent: ${result.games.join(', ')}
                                </div>
                            </div>
                        `;
                    });
                    
                    html += `
                            </div>
                        </div>
                    `;
                });
                
                html += `
                    <div style="background: #fef3c7; padding: 15px; border-radius: 8px; border-left: 4px solid #f59e0b; font-size: 14px;">
                        <strong>üí° Next Steps:</strong>
                        <ol style="margin: 10px 0 0 20px; line-height: 1.8;">
                            <li>Click "üìä Analyze in Manual Entry" to get specific line recommendations with odds</li>
                            <li>Or use the projections to manually check lines on your sportsbook</li>
                            <li>High volatility (‚ö†Ô∏è) players may be less reliable - bet smaller or skip</li>
                        </ol>
                    </div>
                `;
                
                resultsDiv.innerHTML = html;
                
                // Enable parlay builder (optional - could build from projections)
                // document.getElementById('build-parlay-btn').disabled = false;
                
            } catch (error) {
                resultsDiv.innerHTML = `
                    <div class="empty-state">
                        <h3>‚ùå Error</h3>
                        <p>${error.message}</p>
                    </div>
                `;
            } finally {
                btn.disabled = false;
                btn.textContent = 'üìä Analyze All Players';
            }
        }
        
        function useForManualEntry(player, propType, gamesStr) {
            // Switch to Manual Entry tab
            showTab('manual');
            
            // Fill in the form
            document.getElementById('manual-player').value = player;
            document.getElementById('manual-prop-type').value = propType;
            document.getElementById('manual-recent-games').value = gamesStr;
            
            // Scroll to top
            window.scrollTo(0, 0);
            
            // Show notification
            alert(`‚úÖ ${player}'s data loaded into Manual Entry!\n\nNow enter:\n- Line (e.g., 24.5)\n- Odds (e.g., -110)\n- Bookmaker\n\nThen click Analyze to get specific recommendations.`);
        }
        
        function buildParlaysFromMultiPlayer() {
            alert('Parlay builder will be available once you analyze specific lines in Manual Entry tab');
        }
        
        // Custom Scan Functions
        async function runCustomScan() {
            const playersInput = document.getElementById('custom-players').value;
            const propsSelect = document.getElementById('custom-props');
            const minEdge = parseFloat(document.getElementById('custom-min-edge').value) || 3;
            const resultsDiv = document.getElementById('custom-results');
            const btn = document.getElementById('custom-scan-btn');
            
            if (!playersInput) {
                alert('Please enter player names');
                return;
            }
            
            // Parse players
            const playerNames = playersInput.split(',').map(p => p.trim());
            
            // Get selected props
            const selectedProps = Array.from(propsSelect.selectedOptions).map(o => o.value);
            if (selectedProps.length === 0) {
                alert('Please select at least one prop type');
                return;
            }
            
            // Build players array
            const players = playerNames.map(name => ({
                name: name,
                props: selectedProps
            }));
            
            btn.disabled = true;
            btn.textContent = '‚è≥ Analyzing...';
            
            resultsDiv.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Analyzing ${playerNames.length} players...</p>
                </div>
            `;
            
            try {
                const response = await fetch(`${API_URL}/api/scan-best-bets`, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        players: players,
                        min_edge: minEdge
                    })
                });
                
                const data = await response.json();
                
                if (data.success && data.bets.length > 0) {
                    displayBets(data.bets, resultsDiv);
                } else {
                    resultsDiv.innerHTML = `
                        <div class="empty-state">
                            <h3>No Edges Found</h3>
                            <p>No bets found with ${minEdge}%+ edge for these players.</p>
                        </div>
                    `;
                }
            } catch (error) {
                resultsDiv.innerHTML = `
                    <div class="empty-state">
                        <h3>‚ùå Error</h3>
                        <p>${error.message}</p>
                    </div>
                `;
            } finally {
                btn.disabled = false;
                btn.textContent = 'üîç Analyze Players';
            }
        }
        
        async function displayBets(bets, container, append = false) {
            const now = new Date();
            const timestamp = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
            
            // Bets already have reliability calculated by backend - no extra API calls needed!
            const html = bets.map(bet => {
                const confidenceClass = `confidence-${bet.confidence.toLowerCase()}`;
                const edgeColor = bet.edge > 0 ? '#4ade80' : '#f87171';
                const reliability = bet.reliability;
                
                return `
                    <div class="bet-card">
                        <div class="bet-header">
                            <div class="player-name">${bet.player}</div>
                            <div style="display: flex; gap: 8px;">
                                ${reliability ? `
                                    <div style="padding: 6px 12px; background: ${reliability.color}; border-radius: 6px; color: white; font-size: 12px; font-weight: 600;">
                                        ${reliability.rating}
                                    </div>
                                ` : `
                                    <div class="confidence-badge ${confidenceClass}">${bet.confidence}</div>
                                `}
                                <button onclick="editBet('${bet.player}', '${bet.prop_type}', '${bet.bet}', ${bet.line}, '${bet.bookmaker}', ${bet.odds})" 
                                        style="padding: 6px 12px; background: rgba(255,255,255,0.3); border: none; border-radius: 6px; color: white; font-size: 12px; cursor: pointer; font-weight: 600;">
                                    ‚úèÔ∏è Edit
                                </button>
                            </div>
                        </div>
                        <div style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">
                            ${bet.bet} ${bet.line} ${bet.prop_type.replace('player_', '').replace('_', ' ')}
                        </div>
                        <div style="font-size: 16px; opacity: 0.9;">
                            ${bet.odds > 0 ? '+' : ''}${bet.odds} at ${bet.bookmaker}
                        </div>
                        <div style="font-size: 11px; opacity: 0.7; margin-top: 5px;">
                            üì° Odds as of ${timestamp}
                        </div>
                        
                        ${reliability ? `
                        <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 8px; margin: 12px 0; font-size: 13px;">
                            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-bottom: 8px;">
                                <div>
                                    <div style="opacity: 0.8; font-size: 11px;">Reliability</div>
                                    <div style="font-weight: bold; font-size: 16px;">${reliability.reliability_score}/100</div>
                                </div>
                                <div>
                                    <div style="opacity: 0.8; font-size: 11px;">Consistency</div>
                                    <div style="font-weight: bold; font-size: 16px;">${reliability.consistency.consistency_score}/100</div>
                                </div>
                            </div>
                            <div style="opacity: 0.7; font-size: 11px; line-height: 1.4;">
                                ${reliability.consistency.hit_rate > 0 ? `
                                    CV: ${reliability.consistency.coefficient_variation}% ‚Ä¢ 
                                    ${reliability.consistency.hit_rate}% hit rate over ${reliability.consistency.mean} avg
                                ` : `
                                    ‚ö†Ô∏è Insufficient game history - projection may be unreliable
                                `}
                            </div>
                            ${reliability.reliability_score < 55 ? `
                                <div style="margin-top: 8px; padding: 8px; background: rgba(239, 68, 68, 0.2); border-radius: 6px; font-size: 11px;">
                                    <strong>‚ö†Ô∏è Low Reliability:</strong> Avoid in parlays. High edge but insufficient data or player role issues.
                                </div>
                            ` : ''}
                        </div>
                        ` : ''}
                        
                        <div class="bet-details">
                            <div class="bet-stat">
                                <div class="bet-stat-label">Projection</div>
                                <div class="bet-stat-value">${bet.weighted_avg}</div>
                            </div>
                            <div class="bet-stat">
                                <div class="bet-stat-label">Edge</div>
                                <div class="bet-stat-value" style="color: ${edgeColor};">
                                    ${bet.edge > 0 ? '+' : ''}${bet.edge} (${bet.edge_percent > 0 ? '+' : ''}${bet.edge_percent}%)
                                </div>
                            </div>
                            <div class="bet-stat">
                                <div class="bet-stat-label">Hit Rate</div>
                                <div class="bet-stat-value">${bet.hit_rate}%</div>
                            </div>
                            <div class="bet-stat">
                                <div class="bet-stat-label">Confidence</div>
                                <div class="bet-stat-value">${bet.confidence}</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            if (append) {
                container.innerHTML += html;
            } else {
                container.innerHTML = html;
            }
        }
        
        
        function editBet(player, propType, overUnder, line, bookmaker, odds) {
            // Switch to manual entry tab
            showTab('manual');
            document.querySelectorAll('.tab').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.tab')[2].classList.add('active'); // Manual tab is 3rd
            
            // Pre-fill the form
            document.getElementById('manual-player').value = player;
            document.getElementById('manual-prop-type').value = propType.replace('player_', '');
            document.getElementById('manual-over-under').value = overUnder.toLowerCase();
            document.getElementById('manual-line').value = line;
            document.getElementById('manual-bookmaker').value = bookmaker;
            document.getElementById('manual-odds').value = odds;
            
            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
            
            // Highlight the form briefly
            const form = document.querySelector('#manual-tab .card');
            form.style.boxShadow = '0 0 30px rgba(102, 126, 234, 0.5)';
            setTimeout(() => {
                form.style.boxShadow = '0 10px 30px rgba(0,0,0,0.2)';
            }, 1000);
        }
        
        let comparisonBets = [];
        let manualParlayBets = [];  // Storage for manual parlay bets
        
        
        // ========================================
        // TD PROP ANALYSIS FUNCTION
        // ========================================
        async function analyzeTDProp(player, opponent, tdGames, propType, line, overOdds, underOdds, bookmaker, sport, resultsDiv, btn) {
            try {
                // Get TD-specific odds inputs
                const anytimeOdds = parseInt(document.getElementById('td-anytime-odds')?.value) || null;
                const firstOdds = parseInt(document.getElementById('td-first-odds')?.value) || null;
                const twoPlusOdds = parseInt(document.getElementById('td-twoplus-odds')?.value) || null;
                const threePlusOdds = parseInt(document.getElementById('td-threeplus-odds')?.value) || null;
                
                // Calculate TD frequency
                const totalGames = tdGames.length;
                const totalTDs = tdGames.reduce((sum, tds) => sum + tds, 0);
                const avgTDs = totalTDs / totalGames;
                
                // Calculate historical frequency distribution
                const tdCounts = {0: 0, 1: 0, 2: 0, '3+': 0};
                tdGames.forEach(tds => {
                    if (tds === 0) tdCounts[0]++;
                    else if (tds === 1) tdCounts[1]++;
                    else if (tds === 2) tdCounts[2]++;
                    else tdCounts['3+']++;
                });
                
                // Poisson distribution function
                function poissonProb(lambda, k) {
                    // P(X = k) = (Œª^k * e^-Œª) / k!
                    let result = Math.pow(lambda, k) * Math.exp(-lambda);
                    for (let i = 1; i <= k; i++) {
                        result /= i;
                    }
                    return result;
                }
                
                // Calculate Poisson probabilities
                const lambda = avgTDs;
                const poissonProbs = {
                    0: poissonProb(lambda, 0),
                    1: poissonProb(lambda, 1),
                    2: poissonProb(lambda, 2),
                    3: poissonProb(lambda, 3),
                    '4+': 1 - poissonProb(lambda, 0) - poissonProb(lambda, 1) - poissonProb(lambda, 2) - poissonProb(lambda, 3)
                };
                
                // Calculate cumulative probabilities
                const prob1Plus = 1 - poissonProbs[0]; // Anytime TD
                const prob2Plus = 1 - poissonProbs[0] - poissonProbs[1]; // 2+ TDs
                const prob3Plus = 1 - poissonProbs[0] - poissonProbs[1] - poissonProbs[2]; // 3+ TDs
                
                // Calculate First TD probability (rough estimate)
                // Assumes team scores ~2.5 TDs/game and player gets their share
                const teamTDsPerGame = 2.5;
                const playerTDShare = avgTDs / teamTDsPerGame; // Player's share of team TDs
                const probFirstTD = prob1Plus * playerTDShare * 0.6; // Rough approximation
                
                // Analyze each bet type
                const bets = [];
                
                if (anytimeOdds) {
                    const impliedProb = anytimeOdds < 0 ? Math.abs(anytimeOdds) / (Math.abs(anytimeOdds) + 100) : 100 / (anytimeOdds + 100);
                    const edge = (prob1Plus - impliedProb) * 100;
                    const isGoodBet = edge > 0;
                    
                    bets.push({
                        type: 'Anytime TD',
                        odds: anytimeOdds,
                        trueProb: prob1Plus,
                        impliedProb: impliedProb,
                        edge: edge,
                        isGoodBet: isGoodBet,
                        historicalFreq: (totalGames - tdCounts[0]) / totalGames
                    });
                }
                
                if (firstOdds) {
                    const impliedProb = firstOdds < 0 ? Math.abs(firstOdds) / (Math.abs(firstOdds) + 100) : 100 / (firstOdds + 100);
                    const edge = (probFirstTD - impliedProb) * 100;
                    const isGoodBet = edge > 0;
                    
                    bets.push({
                        type: 'First TD',
                        odds: firstOdds,
                        trueProb: probFirstTD,
                        impliedProb: impliedProb,
                        edge: edge,
                        isGoodBet: isGoodBet,
                        warning: 'First TD is very difficult to predict - use with caution'
                    });
                }
                
                if (twoPlusOdds) {
                    const impliedProb = twoPlusOdds < 0 ? Math.abs(twoPlusOdds) / (Math.abs(twoPlusOdds) + 100) : 100 / (twoPlusOdds + 100);
                    const edge = (prob2Plus - impliedProb) * 100;
                    const isGoodBet = edge > 0;
                    
                    bets.push({
                        type: '2+ TDs',
                        odds: twoPlusOdds,
                        trueProb: prob2Plus,
                        impliedProb: impliedProb,
                        edge: edge,
                        isGoodBet: isGoodBet,
                        historicalFreq: (tdCounts[2] + tdCounts['3+']) / totalGames
                    });
                }
                
                if (threePlusOdds) {
                    const impliedProb = threePlusOdds < 0 ? Math.abs(threePlusOdds) / (Math.abs(threePlusOdds) + 100) : 100 / (threePlusOdds + 100);
                    const edge = (prob3Plus - impliedProb) * 100;
                    const isGoodBet = edge > 0;
                    
                    bets.push({
                        type: '3+ TDs',
                        odds: threePlusOdds,
                        trueProb: prob3Plus,
                        impliedProb: impliedProb,
                        edge: edge,
                        isGoodBet: isGoodBet,
                        historicalFreq: tdCounts['3+'] / totalGames
                    });
                }
                
                // Sort bets by edge (best to worst)
                bets.sort((a, b) => b.edge - a.edge);
                
                // Generate results HTML
                let html = `
                    <div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <h3 style="margin: 0 0 15px 0; color: #92400e;">${player} - TD Analysis</h3>
                        
                        <div style="background: white; padding: 15px; border-radius: 6px; margin-bottom: 15px;">
                            <h4 style="margin: 0 0 10px 0; color: #92400e; font-size: 14px;">üìä Historical TD Distribution (Last ${totalGames} Games)</h4>
                            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; font-size: 12px;">
                                <div style="text-align: center; padding: 8px; background: #fffbeb; border-radius: 4px;">
                                    <div style="font-size: 18px; font-weight: bold; color: #92400e;">${tdCounts[0]}</div>
                                    <div style="color: #78350f;">0 TDs</div>
                                    <div style="color: #78350f; font-size: 11px;">${((tdCounts[0]/totalGames)*100).toFixed(1)}%</div>
                                </div>
                                <div style="text-align: center; padding: 8px; background: #fffbeb; border-radius: 4px;">
                                    <div style="font-size: 18px; font-weight: bold; color: #92400e;">${tdCounts[1]}</div>
                                    <div style="color: #78350f;">1 TD</div>
                                    <div style="color: #78350f; font-size: 11px;">${((tdCounts[1]/totalGames)*100).toFixed(1)}%</div>
                                </div>
                                <div style="text-align: center; padding: 8px; background: #fffbeb; border-radius: 4px;">
                                    <div style="font-size: 18px; font-weight: bold; color: #92400e;">${tdCounts[2]}</div>
                                    <div style="color: #78350f;">2 TDs</div>
                                    <div style="color: #78350f; font-size: 11px;">${((tdCounts[2]/totalGames)*100).toFixed(1)}%</div>
                                </div>
                                <div style="text-align: center; padding: 8px; background: #fffbeb; border-radius: 4px;">
                                    <div style="font-size: 18px; font-weight: bold; color: #92400e;">${tdCounts['3+']}</div>
                                    <div style="color: #78350f;">3+ TDs</div>
                                    <div style="color: #78350f; font-size: 11px;">${((tdCounts['3+']/totalGames)*100).toFixed(1)}%</div>
                                </div>
                            </div>
                            <div style="margin-top: 10px; padding: 8px; background: #fef3c7; border-radius: 4px; font-size: 12px; color: #92400e;">
                                <strong>Average:</strong> ${avgTDs.toFixed(2)} TDs per game<br>
                                <strong>Recent TDs:</strong> ${tdGames.join(', ')}
                            </div>
                        </div>
                        
                        <h4 style="margin: 15px 0 10px 0; color: #92400e; font-size: 14px;">üéØ Bet Analysis (Sorted by Edge)</h4>
                `;
                
                // Display each bet
                bets.forEach((bet, index) => {
                    const betClass = bet.isGoodBet ? 'good-bet' : 'bad-bet';
                    const betIcon = bet.isGoodBet ? '‚úÖ' : '‚ùå';
                    const edgeColor = bet.edge > 10 ? '#059669' : bet.edge > 0 ? '#65a30d' : '#dc2626';
                    
                    html += `
                        <div style="background: white; padding: 12px; border-radius: 6px; margin-bottom: 10px; border-left: 4px solid ${bet.isGoodBet ? '#10b981' : '#ef4444'};">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <strong style="color: #92400e; font-size: 15px;">${betIcon} ${bet.type} (${bet.odds > 0 ? '+' : ''}${bet.odds})</strong>
                                <span style="background: ${edgeColor}; color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: bold;">
                                    ${bet.edge > 0 ? '+' : ''}${bet.edge.toFixed(1)}% Edge
                                </span>
                            </div>
                            <div style="font-size: 12px; color: #78350f; line-height: 1.6;">
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                                    <div><strong>True Probability:</strong> ${(bet.trueProb * 100).toFixed(1)}%</div>
                                    <div><strong>Implied Probability:</strong> ${(bet.impliedProb * 100).toFixed(1)}%</div>
                                </div>
                                ${bet.historicalFreq !== undefined ? `<div style="margin-top: 5px;"><strong>Historical Hit Rate:</strong> ${(bet.historicalFreq * 100).toFixed(1)}% (${Math.round(bet.historicalFreq * totalGames)} of ${totalGames} games)</div>` : ''}
                                <div style="margin-top: 8px; padding: 6px; background: ${bet.isGoodBet ? '#d1fae5' : '#fee2e2'}; border-radius: 4px; font-weight: 600;">
                                    ${bet.isGoodBet ? '‚úÖ POSITIVE VALUE - Consider betting' : '‚ùå NEGATIVE VALUE - Skip this bet'}
                                </div>
                                ${bet.warning ? `<div style="margin-top: 5px; padding: 6px; background: #fef3c7; border-radius: 4px; font-size: 11px;"><strong>‚ö†Ô∏è</strong> ${bet.warning}</div>` : ''}
                                
                                <button onclick="addTDToParlay('${player.replace(/'/g, "\\'")}', '${propType}', '${bet.type}', ${bet.odds}, ${(bet.trueProb * 100).toFixed(1)}, ${bet.edge.toFixed(1)}, '${bookmaker}')" 
                                    style="width: 100%; margin-top: 10px; padding: 8px; background: #10b981; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 13px;"
                                    onmouseover="this.style.background='#059669'" 
                                    onmouseout="this.style.background='#10b981'">
                                    ‚ûï Add ${bet.type} to Parlay
                                </button>
                            </div>
                        </div>
                    `;
                });
                
                html += `
                        <div style="margin-top: 15px; padding: 12px; background: #dbeafe; border-radius: 6px; font-size: 12px; color: #1e40af;">
                            <strong>üí° How we calculated this:</strong><br>
                            ‚Ä¢ Used Poisson distribution with Œª = ${avgTDs.toFixed(2)} (average TDs per game)<br>
                            ‚Ä¢ Compared true probability vs implied probability from odds<br>
                            ‚Ä¢ Positive edge = Your probability is higher than bookmaker's<br>
                            ${opponent ? `‚Ä¢ Defense adjustment based on ${opponent} could further refine these probabilities` : ''}
                        </div>
                    </div>
                `;
                
                resultsDiv.innerHTML = html;
                
                // Store bet for tracking
                const bestBet = bets[0];
                if (bestBet && bestBet.isGoodBet) {
                    window.currentManualBet = {
                        player: player,
                        opponent: opponent,
                        prop_type: propType,
                        line: bestBet.type,
                        bookmaker: bookmaker,
                        bet: 'YES',
                        odds: bestBet.odds,
                        projection: (bestBet.trueProb * 100).toFixed(1) + '%',
                        edge: bestBet.edge.toFixed(1) + '%',
                        games: tdGames,
                        is_td_prop: true,
                        td_analysis: bets
                    };
                }
                
            } catch (error) {
                console.error('TD Analysis Error:', error);
                resultsDiv.innerHTML = `<div class="error">Error analyzing TD prop: ${error.message}</div>`;
            } finally {
                btn.disabled = false;
                btn.textContent = 'üìä Analyze This Bet';
            }
        }
        
        async function analyzeManualBet() {
            const player = document.getElementById('manual-player').value;
            const opponent = document.getElementById('manual-opponent').value;
            const recentGamesInput = document.getElementById('manual-recent-games').value;
            const propType = document.getElementById('manual-prop-type').value;
            const line = parseFloat(document.getElementById('manual-line').value);
            const bookmaker = document.getElementById('manual-bookmaker').value;
            const overOdds = parseInt(document.getElementById('manual-over-odds').value);
            const underOdds = parseInt(document.getElementById('manual-under-odds').value);
            const resultsDiv = document.getElementById('manual-results');
            const btn = document.getElementById('manual-analyze-btn');
            const sport = window.currentSport || 'nfl';
            
            // Get minutes inputs early so they're available for bet object later
            const recentMinutesInput = document.getElementById('manual-recent-minutes')?.value;
            const tonightMinutesInput = document.getElementById('manual-tonight-minutes')?.value;
            
            // Get shot attempt inputs (NBA only)
            const recentFGAInput = document.getElementById('manual-recent-fga')?.value;
            const recent3PAInput = document.getElementById('manual-recent-3pa')?.value;
            
            // Check if this is a TD prop that uses the special analyzer
            const useTDAnalyzer = propType === 'rush_tds' || propType === 'rec_tds';
            
            // Validation - different for rush/rec TD props vs regular props (including pass TDs)
            if (useTDAnalyzer) {
                // Rush/Rec TD props only need player and bookmaker
                if (!player || !bookmaker) {
                    alert('Please fill in player name and sportsbook');
                    return;
                }
                // Check if at least one TD odds field is filled
                const anytimeOdds = parseInt(document.getElementById('td-anytime-odds')?.value);
                const firstOdds = parseInt(document.getElementById('td-first-odds')?.value);
                const twoPlusOdds = parseInt(document.getElementById('td-twoplus-odds')?.value);
                const threePlusOdds = parseInt(document.getElementById('td-threeplus-odds')?.value);
                
                if (isNaN(anytimeOdds) && isNaN(firstOdds) && isNaN(twoPlusOdds) && isNaN(threePlusOdds)) {
                    alert('Please enter odds for at least one TD bet type (Anytime, First, 2+, or 3+)');
                    return;
                }
            } else {
                // Regular props (including pass TDs) need line and odds
                if (!player || !line || !bookmaker || (!overOdds && !underOdds)) {
                    alert('Please fill in player, line, bookmaker, and at least one set of odds');
                    return;
                }
            }
            
            btn.disabled = true;
            btn.textContent = '‚è≥ Analyzing...';
            
            resultsDiv.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Analyzing ${player}'s ${sport.toUpperCase()} stats${opponent ? ' vs ' + opponent.toUpperCase() : ''}...</p>
                </div>
            `;
            
            try {
                let games;
                
                // Get recent games (manual input or fetch)
                if (recentGamesInput && recentGamesInput.trim()) {
                    games = recentGamesInput.split(',').map(g => parseFloat(g.trim())).filter(g => !isNaN(g));
                    if (games.length === 0) {
                        throw new Error('Invalid recent games format. Use comma-separated numbers (e.g., 73, 53, 89)');
                    }
                } else if (sport === 'nba') {
                    throw new Error('For NBA, please enter recent game stats manually (e.g., 25, 32, 28, 31, 27)');
                } else {
                    // Fetch from API for NFL
                    const statsResponse = await fetch(`${API_URL}/api/get-player-stats`, {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            player_name: player,
                            stat_type: propType,
                            num_games: 7
                        })
                    });
                    
                    const statsData = await statsResponse.json();
                    if (!statsData.success) {
                        throw new Error('Could not fetch player stats');
                    }
                    games = statsData.games;
                }
                
                // ========================================
                // TOUCHDOWN PROPS - SEPARATE ANALYSIS
                // ========================================
                // Only rush_tds and rec_tds use special TD analyzer
                // pass_tds uses regular O/U analysis
                const useTDAnalyzer = propType === 'rush_tds' || propType === 'rec_tds';
                
                if (useTDAnalyzer) {
                    // Handle rush/rec TD analysis separately
                    await analyzeTDProp(player, opponent, games, propType, line, overOdds, underOdds, bookmaker, sport, resultsDiv, btn);
                    return;
                }
                
                // ========================================
                // REGULAR PROPS (YARDS/POINTS/PASS TDS/ETC)
                // ========================================
                
                // Calculate weighted average (recent games weighted more)
                const weights = games.map((_, i) => i + 1);
                const weightedSum = games.reduce((sum, game, i) => sum + game * weights[i], 0);
                let baseProjection = weightedSum / weights.reduce((a, b) => a + b, 0);
                let projection = baseProjection;
                
                // ========================================
                // SANITY CHECKS - Detect obviously wrong data entry
                // ========================================
                const sanityCheckLimits = {
                    // NFL
                    'pass_yds': { max: 500, min: 50, typical: [150, 350] },
                    'rush_yds': { max: 250, min: 0, typical: [30, 150] },
                    'reception_yds': { max: 200, min: 0, typical: [30, 120] },
                    'receptions': { max: 18, min: 0, typical: [3, 12] },
                    'pass_tds': { max: 6, min: 0, typical: [1, 3] },
                    'rush_tds': { max: 4, min: 0, typical: [0, 2] },
                    'rec_tds': { max: 3, min: 0, typical: [0, 2] },
                    // NBA
                    'points': { max: 60, min: 0, typical: [10, 35] },
                    'rebounds': { max: 25, min: 0, typical: [4, 15] },
                    'assists': { max: 18, min: 0, typical: [2, 12] },
                    'pts+rebs+asts': { max: 80, min: 0, typical: [20, 50] },
                    'threes': { max: 12, min: 0, typical: [0, 5] }
                };
                
                const limits = sanityCheckLimits[propType];
                if (limits && baseProjection > limits.max) {
                    const warning = `
                        <div style="background: #fee2e2; border-left: 4px solid #dc2626; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                            <h3 style="color: #991b1b; margin: 0 0 10px 0;">‚ö†Ô∏è UNREALISTIC PROJECTION DETECTED</h3>
                            <p style="color: #7f1d1d; font-size: 14px; margin-bottom: 10px;">
                                <strong>Projection: ${baseProjection.toFixed(1)} ${propType}</strong>
                            </p>
                            <p style="color: #7f1d1d; font-size: 13px; margin-bottom: 10px;">
                                This projection seems unrealistic. The maximum ever recorded for this stat type is around <strong>${limits.max}</strong>, 
                                and typical performances range from <strong>${limits.typical[0]}-${limits.typical[1]}</strong>.
                            </p>
                            <div style="background: white; padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                                <strong style="color: #991b1b;">Your entered stats:</strong><br>
                                <code style="background: #fef2f2; padding: 4px 8px; border-radius: 4px; color: #7f1d1d;">${games.join(', ')}</code>
                            </div>
                            <p style="color: #7f1d1d; font-size: 13px; font-weight: 600; margin-bottom: 8px;">
                                ‚ùå Possible issues:
                            </p>
                            <ul style="color: #7f1d1d; font-size: 12px; margin: 0; padding-left: 20px;">
                                <li>Wrong column copied (e.g., minutes instead of ${propType})</li>
                                <li>Included totals row instead of individual games</li>
                                <li>Data from wrong player</li>
                                <li>Extra digits/decimal point error</li>
                            </ul>
                            <p style="color: #991b1b; font-size: 13px; font-weight: 600; margin: 15px 0 5px 0;">
                                ‚úÖ Please double-check your data and try again.
                            </p>
                        </div>
                    `;
                    resultsDiv.innerHTML = warning;
                    btn.disabled = false;
                    btn.textContent = 'üìä Analyze This Bet';
                    return;
                }
                
                // Also check if projection is wildly different from the line
                if (line && Math.abs(baseProjection - line) > line * 2) {
                    const warningPercent = ((Math.abs(baseProjection - line) / line) * 100).toFixed(0);
                    const warning = `
                        <div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                            <h3 style="color: #92400e; margin: 0 0 10px 0;">‚ö†Ô∏è PROJECTION FAR FROM LINE</h3>
                            <p style="color: #78350f; font-size: 14px; margin-bottom: 10px;">
                                Your projection (<strong>${baseProjection.toFixed(1)}</strong>) is <strong>${warningPercent}%</strong> away from the line (<strong>${line}</strong>).
                            </p>
                            <div style="background: white; padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                                <strong style="color: #92400e;">Your entered stats:</strong><br>
                                <code style="background: #fffbeb; padding: 4px 8px; border-radius: 4px; color: #78350f;">${games.join(', ')}</code>
                            </div>
                            <p style="color: #78350f; font-size: 13px; margin-bottom: 8px;">
                                This could indicate a data entry error. Please verify:
                            </p>
                            <ul style="color: #78350f; font-size: 12px; margin: 0 0 15px 0; padding-left: 20px;">
                                <li>Correct stat column (not minutes, attempts, etc.)</li>
                                <li>Correct player (not teammate with similar name)</li>
                                <li>Recent games (last 7, not random selection)</li>
                                <li>No extra zeros or decimal errors</li>
                            </ul>
                            <p style="color: #78350f; font-size: 13px; font-weight: 600;">
                                If data is correct, you may have found a <span style="color: #059669;">MASSIVE EDGE ‚úÖ</span> or the line is wrong!
                            </p>
                            <button onclick="document.getElementById('confirm-analysis').style.display='block'; this.style.display='none';" 
                                style="width: 100%; padding: 10px; background: #f59e0b; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; margin-top: 10px;">
                                ‚ö†Ô∏è I've verified my data - Continue anyway
                            </button>
                            <div id="confirm-analysis" style="display: none; margin-top: 10px;">
                                <button onclick="location.reload()" 
                                    style="width: 48%; padding: 10px; background: #ef4444; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; margin-right: 4%;">
                                    ‚ùå Re-enter data
                                </button>
                                <button onclick="continueAnalysisWithWarning()" 
                                    style="width: 48%; padding: 10px; background: #10b981; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer;">
                                    ‚úÖ Continue
                                </button>
                            </div>
                        </div>
                    `;
                    
                    // Show warning but allow user to continue if they confirm
                    const shouldContinue = await new Promise((resolve) => {
                        resultsDiv.innerHTML = warning;
                        window.continueAnalysisWithWarning = () => resolve(true);
                        // Auto-reject after showing warning for 30 seconds
                        setTimeout(() => resolve(false), 30000);
                    });
                    
                    if (!shouldContinue) {
                        btn.disabled = false;
                        btn.textContent = 'üìä Analyze This Bet';
                        return;
                    }
                }
                
                // NBA: Per-minute calculation if minutes provided
                let perMinuteInfo = null;
                if (sport === 'nba') {
                    const excludeOutliers = document.getElementById('manual-exclude-outliers')?.checked;
                    
                    if (recentMinutesInput && recentMinutesInput.trim()) {
                        const minutes = recentMinutesInput.split(',').map(m => parseFloat(m.trim())).filter(m => !isNaN(m) && m > 0);
                        
                        if (minutes.length === games.length) {
                            // Calculate per-minute rates
                            const gamesWithMinutes = games.map((stat, i) => ({
                                stat: stat,
                                minutes: minutes[i],
                                rate: stat / minutes[i]
                            }));
                            
                            // Calculate average rate for outlier detection
                            const rates = gamesWithMinutes.map(g => g.rate);
                            const meanRate = rates.reduce((a, b) => a + b, 0) / rates.length;
                            const stdDevRate = Math.sqrt(rates.reduce((sum, r) => sum + Math.pow(r - meanRate, 2), 0) / rates.length);
                            
                            // Filter outliers if requested
                            let filteredGames = gamesWithMinutes;
                            let excludedCount = 0;
                            if (excludeOutliers && gamesWithMinutes.length > 3) {
                                filteredGames = gamesWithMinutes.filter(g => {
                                    const zScore = Math.abs(g.rate - meanRate) / stdDevRate;
                                    if (zScore > 2) {
                                        excludedCount++;
                                        return false;
                                    }
                                    return true;
                                });
                            }
                            
                            // Calculate per-minute rate from filtered games
                            const totalStats = filteredGames.reduce((sum, g) => sum + g.stat, 0);
                            const totalMinutes = filteredGames.reduce((sum, g) => sum + g.minutes, 0);
                            const perMinuteRate = totalStats / totalMinutes;
                            const avgMinutes = totalMinutes / filteredGames.length;
                            
                            // Determine tonight's minutes
                            const tonightMinutes = tonightMinutesInput && !isNaN(parseFloat(tonightMinutesInput)) 
                                ? parseFloat(tonightMinutesInput) 
                                : avgMinutes;
                            
                            baseProjection = perMinuteRate * tonightMinutes;
                            projection = baseProjection;
                            
                            perMinuteInfo = {
                                rate: perMinuteRate,
                                avgMinutes: avgMinutes,
                                tonightMinutes: tonightMinutes,
                                excludedCount: excludedCount
                            };
                        }
                    }
                }
                
                // NFL: Per-attempt calculation if attempts provided
                let perAttemptInfo = null;
                if (sport === 'nfl') {
                    const recentAttemptsInput = document.getElementById('manual-recent-attempts')?.value;
                    const recentCompletionsInput = document.getElementById('manual-recent-completions')?.value;
                    const tonightAttemptsInput = document.getElementById('manual-tonight-attempts')?.value;
                    const excludeOutliers = document.getElementById('manual-exclude-outliers-nfl')?.checked;
                    
                    // Check if we should use completions/receptions instead of attempts
                    const useCompletions = recentCompletionsInput && recentCompletionsInput.trim() && 
                                          (propType === 'pass_yds' || propType === 'reception_yds');
                    
                    if ((recentAttemptsInput && recentAttemptsInput.trim()) || useCompletions) {
                        const attempts = recentAttemptsInput ? 
                            recentAttemptsInput.split(',').map(a => parseFloat(a.trim())).filter(a => !isNaN(a) && a > 0) : 
                            [];
                        const completions = useCompletions ? 
                            recentCompletionsInput.split(',').map(c => parseFloat(c.trim())).filter(c => !isNaN(c) && c > 0) :
                            [];
                        
                        // Prioritize completions/receptions for yards calculation if available
                        const usingCompletions = completions.length === games.length && attempts.length === games.length;
                        const primaryMetric = usingCompletions ? completions : attempts;
                        const metricName = usingCompletions ? 
                            (propType === 'pass_yds' ? 'completion' : 'reception') : 
                            (propType === 'pass_yds' ? 'attempt' : propType === 'rush_yds' ? 'carry' : 'target');
                        
                        if (primaryMetric.length === games.length) {
                            // Calculate per-attempt/completion rates
                            const gamesWithAttempts = games.map((stat, i) => ({
                                stat: stat,
                                attempts: primaryMetric[i],
                                rate: stat / primaryMetric[i]
                            }));
                            
                            // Calculate average rate for outlier detection
                            const rates = gamesWithAttempts.map(g => g.rate);
                            const meanRate = rates.reduce((a, b) => a + b, 0) / rates.length;
                            const stdDevRate = Math.sqrt(rates.reduce((sum, r) => sum + Math.pow(r - meanRate, 2), 0) / rates.length);
                            
                            // Filter outliers if requested
                            let filteredGames = gamesWithAttempts;
                            let excludedCount = 0;
                            if (excludeOutliers && gamesWithAttempts.length > 3) {
                                filteredGames = gamesWithAttempts.filter(g => {
                                    const zScore = Math.abs(g.rate - meanRate) / stdDevRate;
                                    if (zScore > 2) {
                                        excludedCount++;
                                        return false;
                                    }
                                    return true;
                                });
                            }
                            
                            // Calculate per-attempt/completion rate from filtered games
                            const totalStats = filteredGames.reduce((sum, g) => sum + g.stat, 0);
                            const totalPrimaryMetric = filteredGames.reduce((sum, g) => sum + g.attempts, 0);
                            const perAttemptRate = totalStats / totalPrimaryMetric;
                            const avgPrimaryMetric = totalPrimaryMetric / filteredGames.length;
                            
                            // If using completions/receptions, calculate completion/catch rate
                            let completionRate = null;
                            let tonightCompletions = avgPrimaryMetric;
                            
                            if (usingCompletions) {
                                // Calculate completion/catch rate (completions/attempts or receptions/targets)
                                const totalCompletions = filteredGames.reduce((sum, g, idx) => sum + completions[idx], 0);
                                const totalAttempts = filteredGames.reduce((sum, g, idx) => sum + attempts[idx], 0);
                                completionRate = totalCompletions / totalAttempts;
                                
                                // Determine tonight's attempts
                                const tonightAttempts = tonightAttemptsInput && !isNaN(parseFloat(tonightAttemptsInput)) 
                                    ? parseFloat(tonightAttemptsInput) 
                                    : (totalAttempts / filteredGames.length);
                                
                                // Calculate tonight's expected completions/receptions
                                tonightCompletions = tonightAttempts * completionRate;
                            } else {
                                // Using attempts/carries/targets directly
                                tonightCompletions = tonightAttemptsInput && !isNaN(parseFloat(tonightAttemptsInput)) 
                                    ? parseFloat(tonightAttemptsInput) 
                                    : avgPrimaryMetric;
                            }
                            
                            baseProjection = perAttemptRate * tonightCompletions;
                            projection = baseProjection;
                            
                            perAttemptInfo = {
                                rate: perAttemptRate,
                                avgAttempts: usingCompletions ? (attempts.reduce((a,b) => a+b) / attempts.length) : avgPrimaryMetric,
                                tonightAttempts: tonightCompletions,
                                excludedCount: excludedCount,
                                metricName: metricName,
                                completionRate: completionRate,
                                usingCompletions: usingCompletions
                            };
                        }
                    }
                }
                
                // Get context adjustments
                const opponentTeam = document.getElementById('manual-opponent-team')?.value || '';
                const hasInjury = document.getElementById('manual-injury-adjustment')?.checked || false;
                const isStarter = document.getElementById('manual-starter-adjustment')?.checked || false;
                
                // Track all adjustments for display
                let adjustments = [];
                let totalAdjustment = 0;
                
                // CONTEXT ADJUSTMENTS (NBA ONLY FOR NOW)
                if (sport === 'nba') {
                    // 1. OPPONENT DEFENSE ADJUSTMENT
                    if (opponentTeam && opponentTeam.trim()) {
                        const playerName = player.toLowerCase().trim();
                        const position = PLAYER_POSITIONS[playerName] || null;
                        
                        let defenseAdj = 0;
                        
                        // Points adjustment by position
                        if (propType === 'points' && position) {
                            const key = `points_${position}`;
                            defenseAdj = NBA_DEFENSE_ADJ[key]?.[opponentTeam] || 0;
                            
                            if (defenseAdj !== 0) {
                                projection += defenseAdj;
                                totalAdjustment += defenseAdj;
                                adjustments.push({
                                    type: 'Opponent Defense',
                                    value: defenseAdj,
                                    explanation: `${opponentTeam} ${defenseAdj > 0 ? 'allows' : 'limits'} ${Math.abs(defenseAdj).toFixed(1)} ${defenseAdj > 0 ? 'more' : 'fewer'} PPG to ${position}s`
                                });
                            }
                        }
                        // Three-pointers adjustment
                        else if (propType === 'threes') {
                            defenseAdj = NBA_DEFENSE_ADJ.threes?.[opponentTeam] || 0;
                            
                            if (defenseAdj !== 0) {
                                projection += defenseAdj;
                                totalAdjustment += defenseAdj;
                                adjustments.push({
                                    type: 'Opponent 3PT Defense',
                                    value: defenseAdj,
                                    explanation: `${opponentTeam} ${defenseAdj > 0 ? 'allows' : 'limits'} ${Math.abs(defenseAdj).toFixed(1)} ${defenseAdj > 0 ? 'more' : 'fewer'} 3PM per game`
                                });
                            }
                        }
                        // Rebounds adjustment by position
                        else if (propType === 'rebounds' && position) {
                            const key = `rebounds_${position}`;
                            defenseAdj = NBA_DEFENSE_ADJ[key]?.[opponentTeam] || 0;
                            
                            if (defenseAdj !== 0) {
                                projection += defenseAdj;
                                totalAdjustment += defenseAdj;
                                adjustments.push({
                                    type: 'Opponent Rebounding',
                                    value: defenseAdj,
                                    explanation: `${opponentTeam} ${defenseAdj > 0 ? 'allows' : 'limits'} ${Math.abs(defenseAdj).toFixed(1)} ${defenseAdj > 0 ? 'more' : 'fewer'} rebounds to ${position}s`
                                });
                            }
                        }
                        // Assists adjustment
                        else if (propType === 'assists') {
                            defenseAdj = NBA_DEFENSE_ADJ.assists?.[opponentTeam] || 0;
                            
                            if (defenseAdj !== 0) {
                                projection += defenseAdj;
                                totalAdjustment += defenseAdj;
                                adjustments.push({
                                    type: 'Opponent Pace',
                                    value: defenseAdj,
                                    explanation: `${opponentTeam} ${defenseAdj > 0 ? 'plays faster pace' : 'plays slower pace'} (${Math.abs(defenseAdj).toFixed(1)} assists/game)`
                                });
                            }
                        }
                    }
                    
                    // 2. TEAMMATE INJURY ADJUSTMENT
                    if (hasInjury) {
                        const usageBump = baseProjection * 0.20; // 20% increase
                        projection += usageBump;
                        totalAdjustment += usageBump;
                        adjustments.push({
                            type: 'Teammate Injury',
                            value: usageBump,
                            explanation: `Key teammate out ‚Üí +20% usage rate (+${usageBump.toFixed(1)} ${propType})`
                        });
                    }
                    
                    // 3. STARTER ADJUSTMENT
                    if (isStarter) {
                        const starterBump = baseProjection * 0.40; // 40% increase for bench-to-starter
                        projection += starterBump;
                        totalAdjustment += starterBump;
                        adjustments.push({
                            type: 'Starting Tonight',
                            value: starterBump,
                            explanation: `BENCH PLAYER starting tonight ‚Üí +40% opportunity (+${starterBump.toFixed(1)} ${propType})`
                        });
                    }
                    
                    // 4. HOME/AWAY ADJUSTMENT
                    const homeAway = document.getElementById('manual-home-away')?.value || 'neutral';
                    if (homeAway === 'home') {
                        const homeBump = baseProjection * 0.05; // 5% home boost
                        projection += homeBump;
                        totalAdjustment += homeBump;
                        adjustments.push({
                            type: 'Home Court',
                            value: homeBump,
                            explanation: `Playing at home ‚Üí +5% boost (+${homeBump.toFixed(1)} ${propType})`
                        });
                    } else if (homeAway === 'away') {
                        const awayPenalty = baseProjection * -0.05; // 5% away penalty
                        projection += awayPenalty;
                        totalAdjustment += awayPenalty;
                        adjustments.push({
                            type: 'Away Game',
                            value: awayPenalty,
                            explanation: `Playing away ‚Üí -5% penalty (${awayPenalty.toFixed(1)} ${propType})`
                        });
                    }
                    
                    // 5. REST DAYS ADJUSTMENT
                    const restDays = parseInt(document.getElementById('manual-rest-days')?.value || '2');
                    if (restDays === 0) {
                        const fatiguePenalty = baseProjection * -0.12; // 12% back-to-back penalty
                        projection += fatiguePenalty;
                        totalAdjustment += fatiguePenalty;
                        adjustments.push({
                            type: 'Back-to-Back',
                            value: fatiguePenalty,
                            explanation: `Back-to-back game ‚Üí -12% fatigue (${fatiguePenalty.toFixed(1)} ${propType})`
                        });
                    } else if (restDays === 1) {
                        const restPenalty = baseProjection * -0.05; // 5% one day rest penalty
                        projection += restPenalty;
                        totalAdjustment += restPenalty;
                        adjustments.push({
                            type: '1 Day Rest',
                            value: restPenalty,
                            explanation: `Only 1 day rest ‚Üí -5% fatigue (${restPenalty.toFixed(1)} ${propType})`
                        });
                    } else if (restDays >= 3) {
                        const restBoost = baseProjection * 0.05; // 5% well-rested boost
                        projection += restBoost;
                        totalAdjustment += restBoost;
                        adjustments.push({
                            type: 'Well Rested',
                            value: restBoost,
                            explanation: `3+ days rest ‚Üí +5% boost (+${restBoost.toFixed(1)} ${propType})`
                        });
                    }
                    
                    // 6. BLOWOUT RISK ADJUSTMENT
                    const gameSpread = parseFloat(document.getElementById('manual-game-spread')?.value || 0);
                    const playerTeamFavored = (document.getElementById('manual-team-favored')?.value || 'neutral') === 'player';
                    
                    const isLargeSpread = Math.abs(gameSpread) >= 10;
                    const isHugeSpread = Math.abs(gameSpread) >= 15;
                    
                    if (isLargeSpread && playerTeamFavored) {
                        // Player's team heavily favored - blowout rest risk
                        let blowoutPenalty;
                        let riskPercent;
                        if (isHugeSpread) {
                            blowoutPenalty = baseProjection * -0.12; // 12% for -15+
                            riskPercent = 60;
                        } else {
                            blowoutPenalty = baseProjection * -0.05; // 5% for -10 to -14.5
                            riskPercent = 40;
                        }
                        projection += blowoutPenalty;
                        totalAdjustment += blowoutPenalty;
                        adjustments.push({
                            type: 'Blowout Risk',
                            value: blowoutPenalty,
                            explanation: `${riskPercent}% blowout risk (${Math.abs(gameSpread)} pt favorite) ‚Üí likely sits 4th quarter (${blowoutPenalty.toFixed(1)} ${propType})`
                        });
                    } else if (isLargeSpread && !playerTeamFavored) {
                        // Player's team heavy underdog
                        let underdogPenalty;
                        if (isHugeSpread) {
                            underdogPenalty = baseProjection * -0.08; // 8% for +15+
                        } else {
                            underdogPenalty = baseProjection * -0.03; // 3% for +10 to +14.5
                        }
                        projection += underdogPenalty;
                        totalAdjustment += underdogPenalty;
                        adjustments.push({
                            type: 'Heavy Underdog',
                            value: underdogPenalty,
                            explanation: `${Math.abs(gameSpread)} pt underdog ‚Üí limited competitive minutes (${underdogPenalty.toFixed(1)} ${propType})`
                        });
                    }
                }
                
                // ========================================
                // NEW: DEFENSIVE STATS ADJUSTMENTS
                // ========================================
                if (sport === 'nfl') {
                    if (propType === 'pass_yds' || propType === 'reception_yds') {
                        // Pass defense adjustment
                        const defenseRankInput = document.getElementById('defense-pass-rank')?.value;
                        const defenseRankExact = document.getElementById('defense-pass-rank-exact')?.value;
                        const defenseYardsInput = document.getElementById('defense-pass-yards-last7')?.value;
                        
                        let yardsBasedAdj = null;
                        let rankBasedAdj = null;
                        
                        // Calculate yards-based adjustment if yards provided
                        if (defenseYardsInput && defenseYardsInput.trim()) {
                            const yardsArray = defenseYardsInput.split(',').map(y => parseFloat(y.trim())).filter(y => !isNaN(y));
                            if (yardsArray.length > 0) {
                                const avgAllowed = yardsArray.reduce((a, b) => a + b) / yardsArray.length;
                                const leagueAvg = 220;
                                const pctVsLeague = (avgAllowed / leagueAvg) - 1;
                                yardsBasedAdj = {
                                    percentage: pctVsLeague,
                                    avgAllowed: avgAllowed,
                                    leagueAvg: leagueAvg
                                };
                            }
                        }
                        
                        // Calculate rank-based adjustment if rank provided
                        if (defenseRankInput || defenseRankExact) {
                            let rank = defenseRankExact ? defenseRankExact.trim() : defenseRankInput;
                            let rankAdj = 0;
                            const rankNum = parseInt(rank);
                            
                            if (!isNaN(rankNum) && rankNum >= 1 && rankNum <= 32) {
                                if (rankNum <= 5) rankAdj = -0.20;
                                else if (rankNum <= 10) rankAdj = -0.12;
                                else if (rankNum <= 15) rankAdj = -0.06;
                                else if (rankNum <= 20) rankAdj = 0.00;
                                else if (rankNum <= 25) rankAdj = 0.06;
                                else rankAdj = 0.15;
                                rankBasedAdj = { percentage: rankAdj, rank: rankNum, isExact: true };
                            } else if (rank) {
                                const adjustMap = {'1-5': -0.20, '6-10': -0.12, '11-15': -0.06, '16-20': 0.00, '21-25': 0.06, '26-32': 0.15};
                                rankAdj = adjustMap[rank] || 0;
                                if (rankAdj !== 0) {
                                    rankBasedAdj = { percentage: rankAdj, rank: rank, isExact: false };
                                }
                            }
                        }
                        
                        // Apply adjustment
                        if (yardsBasedAdj && rankBasedAdj) {
                            const adjustmentYards = projection * yardsBasedAdj.percentage;
                            projection += adjustmentYards;
                            totalAdjustment += adjustmentYards;
                            adjustments.push({
                                type: 'Pass Defense', 
                                value: adjustmentYards, 
                                explanation: `Opp allows ${yardsBasedAdj.avgAllowed.toFixed(0)} pass yds/game vs ${yardsBasedAdj.leagueAvg} avg (${(yardsBasedAdj.percentage * 100).toFixed(1)}% ${yardsBasedAdj.percentage > 0 ? 'easier' : 'harder'}) [Rank: ${rankBasedAdj.isExact ? '#' + rankBasedAdj.rank : rankBasedAdj.rank}]`
                            });
                        } else if (yardsBasedAdj) {
                            const adjustmentYards = projection * yardsBasedAdj.percentage;
                            projection += adjustmentYards;
                            totalAdjustment += adjustmentYards;
                            adjustments.push({
                                type: 'Pass Defense', 
                                value: adjustmentYards, 
                                explanation: `Opp allows ${yardsBasedAdj.avgAllowed.toFixed(0)} pass yds/game vs ${yardsBasedAdj.leagueAvg} avg (${(yardsBasedAdj.percentage * 100).toFixed(1)}% ${yardsBasedAdj.percentage > 0 ? 'easier' : 'harder'})`
                            });
                        } else if (rankBasedAdj) {
                            const adjustmentYards = projection * rankBasedAdj.percentage;
                            projection += adjustmentYards;
                            totalAdjustment += adjustmentYards;
                            adjustments.push({
                                type: 'Pass Defense', 
                                value: adjustmentYards, 
                                explanation: `Opp pass defense rank ${rankBasedAdj.isExact ? '#' + rankBasedAdj.rank : rankBasedAdj.rank} (${(rankBasedAdj.percentage * 100).toFixed(0)}% adj)`
                            });
                        }
                    } else if (propType === 'rush_yds') {
                        const defenseRankInput = document.getElementById('defense-rush-rank')?.value;
                        const defenseRankExact = document.getElementById('defense-rush-rank-exact')?.value;
                        const defenseYardsInput = document.getElementById('defense-rush-yards-last7')?.value;
                        
                        console.log('üõ°Ô∏è DEFENSE DEBUG:', {
                            defenseRankInput,
                            defenseRankExact,
                            defenseYardsInput,
                            currentProjection: projection
                        });
                        
                        let yardsBasedAdj = null;
                        let rankBasedAdj = null;
                        
                        // Calculate yards-based adjustment if yards provided
                        if (defenseYardsInput && defenseYardsInput.trim()) {
                            const yardsArray = defenseYardsInput.split(',').map(y => parseFloat(y.trim())).filter(y => !isNaN(y));
                            if (yardsArray.length > 0) {
                                const avgAllowed = yardsArray.reduce((a, b) => a + b) / yardsArray.length;
                                const leagueAvg = 110;
                                const pctVsLeague = (avgAllowed / leagueAvg) - 1;
                                yardsBasedAdj = {
                                    percentage: pctVsLeague,
                                    avgAllowed: avgAllowed,
                                    leagueAvg: leagueAvg
                                };
                                console.log('üõ°Ô∏è YARDS-BASED CALC:', yardsBasedAdj);
                            }
                        }
                        
                        // Calculate rank-based adjustment if rank provided
                        if (defenseRankInput || defenseRankExact) {
                            let rank = defenseRankExact ? defenseRankExact.trim() : defenseRankInput;
                            let rankAdj = 0;
                            
                            const rankNum = parseInt(rank);
                            console.log('üõ°Ô∏è RANK PARSING:', { rank, rankNum, isValid: !isNaN(rankNum) });
                            
                            if (!isNaN(rankNum) && rankNum >= 1 && rankNum <= 32) {
                                if (rankNum <= 5) rankAdj = -0.20;
                                else if (rankNum <= 10) rankAdj = -0.12;
                                else if (rankNum <= 15) rankAdj = -0.06;
                                else if (rankNum <= 20) rankAdj = 0.00;
                                else if (rankNum <= 25) rankAdj = 0.06;
                                else rankAdj = 0.15;
                                rankBasedAdj = {
                                    percentage: rankAdj,
                                    rank: rankNum,
                                    isExact: true
                                };
                            } else if (rank) {
                                const adjustMap = {'1-5': -0.20, '6-10': -0.12, '11-15': -0.06, '16-20': 0.00, '21-25': 0.06, '26-32': 0.15};
                                rankAdj = adjustMap[rank] || 0;
                                if (rankAdj !== 0) {
                                    rankBasedAdj = {
                                        percentage: rankAdj,
                                        rank: rank,
                                        isExact: false
                                    };
                                }
                            }
                            console.log('üõ°Ô∏è RANK-BASED CALC:', rankBasedAdj);
                        }
                        
                        // Apply adjustment based on what data is available
                        if (yardsBasedAdj && rankBasedAdj) {
                            // BOTH provided - use yards primarily but show both
                            const adjustmentYards = projection * yardsBasedAdj.percentage;
                            projection += adjustmentYards;
                            totalAdjustment += adjustmentYards;
                            adjustments.push({
                                type: 'Run Defense', 
                                value: adjustmentYards, 
                                explanation: `Opp allows ${yardsBasedAdj.avgAllowed.toFixed(0)} rush yds/game vs ${yardsBasedAdj.leagueAvg} avg (${(yardsBasedAdj.percentage * 100).toFixed(1)}% ${yardsBasedAdj.percentage > 0 ? 'easier' : 'harder'}) [Rank: ${rankBasedAdj.isExact ? '#' + rankBasedAdj.rank : rankBasedAdj.rank}]`
                            });
                            console.log('üõ°Ô∏è USING YARDS (with rank context):', { adjustmentYards, finalProjection: projection });
                        } else if (yardsBasedAdj) {
                            // Only yards provided
                            const adjustmentYards = projection * yardsBasedAdj.percentage;
                            projection += adjustmentYards;
                            totalAdjustment += adjustmentYards;
                            adjustments.push({
                                type: 'Run Defense', 
                                value: adjustmentYards, 
                                explanation: `Opp allows ${yardsBasedAdj.avgAllowed.toFixed(0)} rush yds/game vs ${yardsBasedAdj.leagueAvg} avg (${(yardsBasedAdj.percentage * 100).toFixed(1)}% ${yardsBasedAdj.percentage > 0 ? 'easier' : 'harder'})`
                            });
                            console.log('üõ°Ô∏è USING YARDS ONLY:', { adjustmentYards, finalProjection: projection });
                        } else if (rankBasedAdj) {
                            // Only rank provided
                            const adjustmentYards = projection * rankBasedAdj.percentage;
                            projection += adjustmentYards;
                            totalAdjustment += adjustmentYards;
                            adjustments.push({
                                type: 'Run Defense', 
                                value: adjustmentYards, 
                                explanation: `Opp run defense rank ${rankBasedAdj.isExact ? '#' + rankBasedAdj.rank : rankBasedAdj.rank} (${(rankBasedAdj.percentage * 100).toFixed(0)}% adj)`
                            });
                            console.log('üõ°Ô∏è USING RANK ONLY:', { adjustmentYards, finalProjection: projection });
                        }
                    }
                } else if (sport === 'nba') {
                    if (propType === 'points' || propType.includes('pts')) {
                        const defenseRankInput = document.getElementById('defense-points-rank')?.value;
                        const defenseRankExact = document.getElementById('defense-points-rank-exact')?.value;
                        const defenseStatsInput = document.getElementById('defense-points-last7')?.value;
                        
                        if (defenseStatsInput && defenseStatsInput.trim()) {
                            const statsArray = defenseStatsInput.split(',').map(s => parseFloat(s.trim())).filter(s => !isNaN(s));
                            if (statsArray.length > 0) {
                                const avgAllowed = statsArray.reduce((a, b) => a + b) / statsArray.length;
                                const leagueAvg = 114;
                                const pctVsLeague = (avgAllowed / leagueAvg) - 1;
                                const adjustmentPts = projection * pctVsLeague;
                                projection += adjustmentPts;
                                totalAdjustment += adjustmentPts;
                                adjustments.push({type: 'Points Defense', value: adjustmentPts, explanation: `Opp allows ${avgAllowed.toFixed(1)} pts/game vs ${leagueAvg} avg (${(pctVsLeague * 100).toFixed(1)}% ${pctVsLeague > 0 ? 'easier' : 'harder'})`});
                            }
                        } else if (defenseRankInput || defenseRankExact) {
                            let rank = defenseRankExact ? defenseRankExact.trim() : defenseRankInput;
                            let rankAdj = 0;
                            
                            const rankNum = parseInt(rank);
                            if (!isNaN(rankNum) && rankNum >= 1 && rankNum <= 30) {
                                if (rankNum <= 5) rankAdj = -0.20;
                                else if (rankNum <= 10) rankAdj = -0.12;
                                else if (rankNum <= 15) rankAdj = -0.06;
                                else if (rankNum <= 20) rankAdj = 0.00;
                                else if (rankNum <= 25) rankAdj = 0.06;
                                else rankAdj = 0.15;
                            } else {
                                const adjustMap = {'1-5': -0.20, '6-10': -0.12, '11-15': -0.06, '16-20': 0.00, '21-25': 0.06, '26-30': 0.15};
                                rankAdj = adjustMap[rank] || 0;
                            }
                            
                            if (rankAdj !== 0) {
                                const adjustmentPts = projection * rankAdj;
                                projection += adjustmentPts;
                                totalAdjustment += adjustmentPts;
                                adjustments.push({type: 'Points Defense', value: adjustmentPts, explanation: `Opp defense rank ${!isNaN(rankNum) ? '#' + rankNum : rank} (${(rankAdj * 100).toFixed(0)}% adj)`});
                            }
                        }
                    } else if (propType === 'rebounds' || propType.includes('rebs')) {
                        const defenseRankInput = document.getElementById('defense-rebounds-rank')?.value;
                        const defenseRankExact = document.getElementById('defense-rebounds-rank-exact')?.value;
                        const defenseStatsInput = document.getElementById('defense-rebounds-last7')?.value;
                        
                        if (defenseStatsInput && defenseStatsInput.trim()) {
                            const statsArray = defenseStatsInput.split(',').map(s => parseFloat(s.trim())).filter(s => !isNaN(s));
                            if (statsArray.length > 0) {
                                const avgAllowed = statsArray.reduce((a, b) => a + b) / statsArray.length;
                                const leagueAvg = 44;
                                const pctVsLeague = (avgAllowed / leagueAvg) - 1;
                                const adjustmentRebs = projection * pctVsLeague;
                                projection += adjustmentRebs;
                                totalAdjustment += adjustmentRebs;
                                adjustments.push({type: 'Rebounds Defense', value: adjustmentRebs, explanation: `Opp allows ${avgAllowed.toFixed(1)} rebs/game vs ${leagueAvg} avg (${(pctVsLeague * 100).toFixed(1)}% ${pctVsLeague > 0 ? 'easier' : 'harder'})`});
                            }
                        } else if (defenseRankInput || defenseRankExact) {
                            let rank = defenseRankExact ? defenseRankExact.trim() : defenseRankInput;
                            let rankAdj = 0;
                            
                            const rankNum = parseInt(rank);
                            if (!isNaN(rankNum) && rankNum >= 1 && rankNum <= 30) {
                                if (rankNum <= 5) rankAdj = -0.20;
                                else if (rankNum <= 10) rankAdj = -0.12;
                                else if (rankNum <= 15) rankAdj = -0.06;
                                else if (rankNum <= 20) rankAdj = 0.00;
                                else if (rankNum <= 25) rankAdj = 0.06;
                                else rankAdj = 0.15;
                            } else {
                                const adjustMap = {'1-5': -0.20, '6-10': -0.12, '11-15': -0.06, '16-20': 0.00, '21-25': 0.06, '26-30': 0.15};
                                rankAdj = adjustMap[rank] || 0;
                            }
                            
                            if (rankAdj !== 0) {
                                const adjustmentRebs = projection * rankAdj;
                                projection += adjustmentRebs;
                                totalAdjustment += adjustmentRebs;
                                adjustments.push({type: 'Rebounds Defense', value: adjustmentRebs, explanation: `Opp defense rank ${!isNaN(rankNum) ? '#' + rankNum : rank} (${(rankAdj * 100).toFixed(0)}% adj)`});
                            }
                        }
                    } else if (propType === 'assists' || propType.includes('asts')) {
                        const defenseRankInput = document.getElementById('defense-assists-rank')?.value;
                        const defenseRankExact = document.getElementById('defense-assists-rank-exact')?.value;
                        const defenseStatsInput = document.getElementById('defense-assists-last7')?.value;
                        
                        if (defenseStatsInput && defenseStatsInput.trim()) {
                            const statsArray = defenseStatsInput.split(',').map(s => parseFloat(s.trim())).filter(s => !isNaN(s));
                            if (statsArray.length > 0) {
                                const avgAllowed = statsArray.reduce((a, b) => a + b) / statsArray.length;
                                const leagueAvg = 26;
                                const pctVsLeague = (avgAllowed / leagueAvg) - 1;
                                const adjustmentAsts = projection * pctVsLeague;
                                projection += adjustmentAsts;
                                totalAdjustment += adjustmentAsts;
                                adjustments.push({type: 'Assists Defense', value: adjustmentAsts, explanation: `Opp allows ${avgAllowed.toFixed(1)} asts/game vs ${leagueAvg} avg (${(pctVsLeague * 100).toFixed(1)}% ${pctVsLeague > 0 ? 'easier' : 'harder'})`});
                            }
                        } else if (defenseRankInput || defenseRankExact) {
                            let rank = defenseRankExact ? defenseRankExact.trim() : defenseRankInput;
                            let rankAdj = 0;
                            
                            const rankNum = parseInt(rank);
                            if (!isNaN(rankNum) && rankNum >= 1 && rankNum <= 30) {
                                if (rankNum <= 5) rankAdj = -0.20;
                                else if (rankNum <= 10) rankAdj = -0.12;
                                else if (rankNum <= 15) rankAdj = -0.06;
                                else if (rankNum <= 20) rankAdj = 0.00;
                                else if (rankNum <= 25) rankAdj = 0.06;
                                else rankAdj = 0.15;
                            } else {
                                const adjustMap = {'1-5': -0.20, '6-10': -0.12, '11-15': -0.06, '16-20': 0.00, '21-25': 0.06, '26-30': 0.15};
                                rankAdj = adjustMap[rank] || 0;
                            }
                            
                            if (rankAdj !== 0) {
                                const adjustmentAsts = projection * rankAdj;
                                projection += adjustmentAsts;
                                totalAdjustment += adjustmentAsts;
                                adjustments.push({type: 'Assists Defense', value: adjustmentAsts, explanation: `Opp defense rank ${!isNaN(rankNum) ? '#' + rankNum : rank} (${(rankAdj * 100).toFixed(0)}% adj)`});
                            }
                        }
                    }
                }
                
                // Show adjustment explanation if any adjustments were made
                const adjExplanation = document.getElementById('adjustment-explanation');
                if (adjExplanation && adjustments.length > 0) {
                    adjExplanation.style.display = 'block';
                    adjExplanation.innerHTML = `
                        <strong style="color: #059669;">‚úÖ Adjustments Applied:</strong><br>
                        ${adjustments.map(adj => 
                            `‚Ä¢ <strong>${adj.type}:</strong> ${adj.value > 0 ? '+' : ''}${adj.value.toFixed(1)} - ${adj.explanation}`
                        ).join('<br>')}
                        <br><br>
                        <strong>Total Adjustment:</strong> ${totalAdjustment > 0 ? '+' : ''}${totalAdjustment.toFixed(1)} ${propType}
                    `;
                } else if (adjExplanation) {
                    adjExplanation.style.display = 'none';
                }
                
                // ========================================
                // MACHINE LEARNING ENSEMBLE PREDICTION
                // ========================================
                let mlPrediction = null;
                let finalProjection = projection;
                
                if (mlModelTrained || trackedBets.filter(b => b.actualResult).length >= 10) {
                    try {
                        // Prepare bet object for ML
                        const betForML = {
                            weighted_avg: projection,
                            simple_avg: simpleAvg,
                            std_dev: calculateStdDev(games),
                            opponent_adjustment: adjustments.find(a => a.type.includes('Opponent'))?.value || 0,
                            injury_adjustment: adjustments.find(a => a.type === 'Teammate Injury')?.value || 0,
                            starter_adjustment: adjustments.find(a => a.type === 'Starting Tonight')?.value || 0,
                            line: line,
                            cv: (calculateStdDev(games) / (games.reduce((sum, val) => sum + val, 0) / games.length)) * 100,
                            games: games,
                            prop_type: propType
                        };
                        
                        mlPrediction = await getEnsemblePrediction(betForML);
                        
                        if (mlPrediction && mlPrediction.mlUsed) {
                            finalProjection = mlPrediction.prediction;
                            
                            // Update adjustment explanation to show ML
                            if (adjExplanation) {
                                const mlInfo = `
                                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(5, 150, 105, 0.3);">
                                        <strong style="color: #8b5cf6;">ü§ñ ML Enhancement:</strong><br>
                                        ‚Ä¢ Ensemble Prediction: ${finalProjection.toFixed(1)} ${propType}<br>
                                        ‚Ä¢ ML Component (${(mlPrediction.mlWeight * 100).toFixed(0)}%): ${mlPrediction.mlPrediction.toFixed(1)}<br>
                                        ‚Ä¢ Statistical Component (${((1-mlPrediction.mlWeight) * 100).toFixed(0)}%): ${mlPrediction.weightedAvg.toFixed(1)}<br>
                                        ‚Ä¢ 90% Confidence Range: ${mlPrediction.lower.toFixed(1)} - ${mlPrediction.upper.toFixed(1)}<br>
                                        <small style="opacity: 0.8;">Trained on ${trackedBets.filter(b => b.actualResult).length} tracked bets</small>
                                    </div>
                                `;
                                adjExplanation.innerHTML += mlInfo;
                            }
                        }
                    } catch (error) {
                        console.log('ML prediction failed, using statistical model:', error);
                    }
                }
                
                // Use ML-enhanced projection for all calculations
                projection = finalProjection;
                
                // Calculate volatility metrics
                const simpleAvg = games.reduce((sum, val) => sum + val, 0) / games.length;
                const stdDev = calculateStdDev(games);
                const cv = (stdDev / simpleAvg) * 100;
                
                // üéØ SHOOTING EFFICIENCY ANALYSIS (if shot attempts provided)
                let shootingAnalysis = null;
                if (sport === 'nba') {
                    // Process FGA for points props
                    if ((propType === 'points' || propType.includes('pts')) && recentFGAInput && recentFGAInput.trim()) {
                        const fgaGames = recentFGAInput.split(',').map(a => parseFloat(a.trim())).filter(a => !isNaN(a) && a > 0);
                        if (fgaGames.length === games.length) {
                            // Calculate shooting efficiency
                            const avgFGA = fgaGames.reduce((sum, val) => sum + val, 0) / fgaGames.length;
                            const avgPoints = games.reduce((sum, val) => sum + val, 0) / games.length;
                            const pointsPerAttempt = avgPoints / avgFGA;
                            
                            // Calculate points-per-attempt range (NOT FG% - we don't know 2s vs 3s)
                            const ptsPerAttemptByGame = games.map((pts, i) => pts / fgaGames[i]);
                            const minPtsPerAttempt = Math.min(...ptsPerAttemptByGame);
                            const maxPtsPerAttempt = Math.max(...ptsPerAttemptByGame);
                            const avgPtsPerAttempt = ptsPerAttemptByGame.reduce((sum, val) => sum + val, 0) / ptsPerAttemptByGame.length;
                            
                            // Calculate variance in outcomes based on shooting
                            const lowNightPoints = avgFGA * pointsPerAttempt * 0.7; // 30% worse shooting
                            const highNightPoints = avgFGA * pointsPerAttempt * 1.3; // 30% better shooting
                            
                            shootingAnalysis = {
                                type: 'FGA',
                                avgAttempts: avgFGA,
                                pointsPerAttempt: pointsPerAttempt,
                                ptsPerAttemptRange: { min: minPtsPerAttempt, max: maxPtsPerAttempt },
                                projectedRange: { low: lowNightPoints, high: highNightPoints },
                                varianceWarning: (maxPtsPerAttempt / minPtsPerAttempt) > 1.5 // High variance if 50%+ spread
                            };
                        }
                    }
                    
                    // Process 3PA for threes props
                    if ((propType === 'threes' || propType.includes('3pt')) && recent3PAInput && recent3PAInput.trim()) {
                        const tpaGames = recent3PAInput.split(',').map(a => parseFloat(a.trim())).filter(a => !isNaN(a) && a > 0);
                        if (tpaGames.length === games.length) {
                            // Calculate 3P shooting efficiency
                            const avgTPA = tpaGames.reduce((sum, val) => sum + val, 0) / tpaGames.length;
                            const avgThrees = games.reduce((sum, val) => sum + val, 0) / games.length;
                            const threePPercent = avgThrees / avgTPA;
                            
                            // Calculate 3P% range
                            const tpPercentages = games.map((makes, i) => makes / tpaGames[i]);
                            const minTP = Math.min(...tpPercentages);
                            const maxTP = Math.max(...tpPercentages);
                            
                            // How many attempts needed to beat line?
                            const attemptsNeeded = Math.ceil(line / threePPercent);
                            const percentNeeded = (line / avgTPA) * 100;
                            
                            shootingAnalysis = {
                                type: '3PA',
                                avgAttempts: avgTPA,
                                threesPerAttempt: threePPercent,
                                avg3PPercent: threePPercent * 100,
                                tpRange: { min: minTP * 100, max: maxTP * 100 },
                                attemptsNeeded: attemptsNeeded,
                                percentNeeded: percentNeeded,
                                volumeRisk: avgTPA < attemptsNeeded, // Doesn't take enough shots
                                varianceWarning: (maxTP / minTP) > 1.8 // High variance in 3P%
                            };
                        }
                    }
                }
                
                // Calculate hit rates for BOTH over and under
                const hitsOver = games.filter(g => g > line).length;
                const hitsUnder = games.filter(g => g < line).length;
                const overHitRate = (hitsOver / games.length) * 100;
                const underHitRate = (hitsUnder / games.length) * 100;
                
                // Calculate edge for projection vs line
                const projectionEdge = projection - line;
                const projectionEdgePercent = (Math.abs(projectionEdge) / line) * 100;
                
                // Analyze OVER bet (if odds provided)
                let overAnalysis = null;
                if (overOdds) {
                    const overImpliedProb = overOdds < 0 ? (Math.abs(overOdds) / (Math.abs(overOdds) + 100)) : (100 / (overOdds + 100));
                    
                    // Use adjusted hit rate (like in alt lines analyzer)
                    const historicalOverRate = (games.filter(g => g > line).length / games.length);
                    const adjustedOverRate = calculateAdjustedHitRate(line, projection, stdDev, games);
                    let overHitRate = adjustedOverRate * 100;
                    
                    // CRITICAL FIX: Cap at 95% (nothing is 100% certain)
                    if (overHitRate > 95) {
                        overHitRate = 95;
                    }
                    
                    const overTrueEdge = overHitRate - (overImpliedProb * 100);
                    
                    overAnalysis = {
                        side: 'OVER',
                        odds: overOdds,
                        hitRate: overHitRate,
                        historicalHitRate: Math.min(historicalOverRate * 100, 95),
                        wasAdjusted: Math.abs(historicalOverRate * 100 - overHitRate) > 2,
                        impliedProb: overImpliedProb * 100,
                        trueEdge: overTrueEdge,
                        projectionFavor: projection > line,
                        projectionDistance: projection - line
                    };
                }
                
                // Analyze UNDER bet (if odds provided)
                let underAnalysis = null;
                if (underOdds) {
                    const underImpliedProb = underOdds < 0 ? (Math.abs(underOdds) / (Math.abs(underOdds) + 100)) : (100 / (underOdds + 100));
                    
                    // Use adjusted hit rate (inverse of over since we're above line now)
                    const historicalUnderRate = (games.filter(g => g < line).length / games.length);
                    // For UNDER, we want P(X < line), which is 1 - P(X > line)
                    const adjustedOverRate = calculateAdjustedHitRate(line, projection, stdDev, games);
                    const adjustedUnderRate = 1 - adjustedOverRate;
                    let underHitRate = adjustedUnderRate * 100;
                    
                    // CRITICAL FIX: Cap at 95% (nothing is 100% certain)
                    if (underHitRate > 95) {
                        underHitRate = 95;
                    }
                    
                    const underTrueEdge = underHitRate - (underImpliedProb * 100);
                    
                    underAnalysis = {
                        side: 'UNDER',
                        odds: underOdds,
                        hitRate: underHitRate,
                        historicalHitRate: Math.min(historicalUnderRate * 100, 95),
                        wasAdjusted: Math.abs(historicalUnderRate * 100 - underHitRate) > 2,
                        impliedProb: underImpliedProb * 100,
                        trueEdge: underTrueEdge,
                        projectionFavor: projection < line,
                        projectionDistance: line - projection
                    };
                }
                
                // Determine best bet - PRIORITIZE PROJECTION
                let recommendedBet;
                
                if (overAnalysis && underAnalysis) {
                    // Both odds provided
                    
                    // RULE 1: If projection is clearly above or below line, ALWAYS follow projection
                    // "Clearly" = more than 0.5 away from line
                    if (Math.abs(projectionEdge) > 0.5) {
                        // Projection is decisive - follow it!
                        if (projection > line) {
                            recommendedBet = overAnalysis;
                        } else {
                            recommendedBet = underAnalysis;
                        }
                    } else {
                        // RULE 2: Projection is VERY close to line (within 0.5)
                        // Only NOW use true edge as tiebreaker
                        if (overAnalysis.trueEdge > underAnalysis.trueEdge) {
                            recommendedBet = overAnalysis;
                        } else if (underAnalysis.trueEdge > overAnalysis.trueEdge) {
                            recommendedBet = underAnalysis;
                        } else {
                            // Even true edges are similar - pick side projection favors
                            recommendedBet = projection >= line ? overAnalysis : underAnalysis;
                        }
                    }
                } else {
                    // Only one provided
                    recommendedBet = overAnalysis || underAnalysis;
                }
                
                // Determine recommendation strength
                let recommendation, confidence;
                // projectionEdgePercent already declared above
                const trueEdge = recommendedBet.trueEdge;
                const projectionSupportsRec = (recommendedBet.side === 'OVER' && projection > line) || 
                                             (recommendedBet.side === 'UNDER' && projection < line);
                
                if (projectionSupportsRec && projectionEdgePercent >= 8 && recommendedBet.hitRate >= 60 && trueEdge >= 10) {
                    recommendation = `STRONG ${recommendedBet.side}`;
                    confidence = 'High';
                } else if (projectionSupportsRec && projectionEdgePercent >= 5 && recommendedBet.hitRate >= 55 && trueEdge >= 5) {
                    recommendation = `GOOD ${recommendedBet.side}`;
                    confidence = 'High';
                } else if (projectionSupportsRec && (projectionEdgePercent >= 3 || trueEdge >= 5) && recommendedBet.hitRate >= 50) {
                    recommendation = `BET ${recommendedBet.side}`;
                    confidence = 'Medium';
                } else if (projectionSupportsRec && (projectionEdgePercent >= 2 || trueEdge >= 3)) {
                    recommendation = `LEAN ${recommendedBet.side}`;
                    confidence = 'Low';
                } else if (trueEdge >= 5 && recommendedBet.hitRate >= 55) {
                    // True edge is good even if projection doesn't strongly support
                    recommendation = `LEAN ${recommendedBet.side}`;
                    confidence = 'Low';
                } else {
                    recommendation = 'PASS - Edge too small';
                    confidence = 'Low';
                }
                
                
                // Add comparison note if both odds provided
                let comparisonNote = '';
                if (overAnalysis && underAnalysis) {
                    const other = recommendedBet.side === 'OVER' ? underAnalysis : overAnalysis;
                    comparisonNote = `\n\n${other.side} has ${other.trueEdge.toFixed(1)}% true edge vs ${recommendedBet.trueEdge.toFixed(1)}% for ${recommendedBet.side}`;
                }
                
                // Build bet object
                const bet = {
                    player: player,
                    prop_type: propType,
                    bet: recommendedBet.side,
                    line: line,
                    odds: recommendedBet.odds,
                    bookmaker: bookmaker,
                    base_projection: baseProjection.toFixed(1),
                    adjusted_projection: projection.toFixed(1),
                    total_adjustment: totalAdjustment.toFixed(1),
                    adjustments: adjustments,
                    weighted_avg: projection.toFixed(1),
                    simple_avg: simpleAvg.toFixed(1),
                    std_dev: stdDev.toFixed(1),
                    cv: cv.toFixed(1),
                    hit_rate: recommendedBet.hitRate.toFixed(1),
                    historical_hit_rate: recommendedBet.historicalHitRate.toFixed(1),
                    was_adjusted: recommendedBet.wasAdjusted,
                    edge: (recommendedBet.side === 'OVER' ? projectionEdge : -projectionEdge).toFixed(1),
                    edge_percent: (recommendedBet.side === 'OVER' ? projectionEdgePercent : -projectionEdgePercent).toFixed(1),
                    true_edge: recommendedBet.trueEdge.toFixed(1),
                    implied_prob: recommendedBet.impliedProb.toFixed(1),
                    recommendation: recommendation,
                    confidence: confidence,
                    projection_supports: projectionSupportsRec,
                    projection_distance: Math.abs(recommendedBet.projectionDistance).toFixed(1),
                    games: games,
                    manual_games: !!recentGamesInput,
                    recent_minutes: recentMinutesInput ? recentMinutesInput.split(',').map(m => parseFloat(m.trim())).filter(m => !isNaN(m) && m > 0) : null,
                    tonight_minutes: tonightMinutesInput && !isNaN(parseFloat(tonightMinutesInput)) ? parseFloat(tonightMinutesInput) : null,
                    opponent: opponentTeam || null,
                    opponent_team: opponentTeam || null,
                    has_injury: hasInjury,
                    is_starter: isStarter,
                    comparison_note: comparisonNote,
                    other_side: overAnalysis && underAnalysis ? (recommendedBet.side === 'OVER' ? underAnalysis : overAnalysis) : null,
                    shooting_analysis: shootingAnalysis  // Add shooting efficiency data
                };
                
                displayManualBet(bet, resultsDiv);
                
                btn.disabled = false;
                btn.textContent = 'üìä Analyze This Bet';
                
            } catch (error) {
                resultsDiv.innerHTML = `
                    <div class="empty-state">
                        <h3>‚ùå Error</h3>
                        <p>${error.message}</p>
                    </div>
                `;
                btn.disabled = false;
                btn.textContent = 'üìä Analyze This Bet';
            }
        }
        
        function formatPropTypeLabel(propType) {
            const labels = {
                // NFL
                'rush_yds': 'Rushing Yards',
                'reception_yds': 'Receiving Yards',
                'pass_yds': 'Passing Yards',
                'receptions': 'Receptions',
                'pass_tds': 'Passing TDs',
                'rush_tds': 'Rushing TDs',
                // NBA
                'points': 'Points',
                'rebounds': 'Rebounds',
                'assists': 'Assists',
                'threes': '3-Pointers Made',
                'pts_rebs_asts': 'Pts + Rebs + Asts',
                'pts_rebs': 'Pts + Rebs',
                'pts_asts': 'Pts + Asts',
                'rebs_asts': 'Rebs + Asts',
                'steals': 'Steals',
                'blocks': 'Blocks',
                'turnovers': 'Turnovers'
            };
            return labels[propType] || propType.replace('_', ' ').toUpperCase();
        }
        
        // Statistical helper functions
        function calculateMean(values) {
            return values.reduce((sum, val) => sum + val, 0) / values.length;
        }
        
        function calculateStdDev(values) {
            const mean = calculateMean(values);
            const squareDiffs = values.map(val => Math.pow(val - mean, 2));
            const variance = squareDiffs.reduce((sum, val) => sum + val, 0) / values.length;
            return Math.sqrt(variance);
        }
        
        function normalCDF(z) {
            // Approximation of cumulative distribution function for normal distribution
            // Returns P(Z <= z) for standard normal distribution
            const t = 1 / (1 + 0.2316419 * Math.abs(z));
            const d = 0.3989423 * Math.exp(-z * z / 2);
            const probability = d * t * (0.3193815 + t * (-0.3565638 + t * (1.781478 + t * (-1.821256 + t * 1.330274))));
            return z > 0 ? 1 - probability : probability;
        }
        
        function calculateAdjustedHitRate(line, projection, stdDev, games) {
            // Calculate historical hit rate
            const historicalHitRate = (games.filter(g => g > line).length / games.length);
            
            // If we have very few games, rely more on historical
            if (games.length < 5) {
                return historicalHitRate;
            }
            
            // Calculate distance from projection in standard deviations (z-score)
            const distance = line - projection;
            const zScore = stdDev > 0 ? distance / stdDev : 0;
            
            // If line is close to projection (within 0.5 std dev), use historical
            if (Math.abs(zScore) < 0.5) {
                return historicalHitRate;
            }
            
            // For lines far from projection, use probability distribution
            // P(X > line) = 1 - P(X <= line) = 1 - normalCDF(zScore)
            const theoreticalHitRate = 1 - normalCDF(zScore);
            
            // Blend theoretical and historical based on how far from projection
            // Further away = more weight on theoretical
            const blendFactor = Math.min(Math.abs(zScore) / 2, 0.8); // Max 80% theoretical
            
            const adjustedRate = theoreticalHitRate * blendFactor + historicalHitRate * (1 - blendFactor);
            
            // Return bounded between 0-100%
            return Math.max(0, Math.min(1, adjustedRate));
        }
        
        async function analyzeAltLines() {
            const player = document.getElementById('alt-player').value;
            const propType = document.getElementById('alt-prop-type').value;
            const recentGamesInput = document.getElementById('alt-recent-games').value;
            const linesInput = document.getElementById('alt-lines').value;
            const adjustedProjectionInput = document.getElementById('alt-adjusted-projection').value;
            const resultsDiv = document.getElementById('alt-results');
            const btn = document.getElementById('alt-analyze-btn');
            
            if (!player || !recentGamesInput || !linesInput) {
                alert('Please fill in player name, recent games, and at least one alternate line');
                return;
            }
            
            btn.disabled = true;
            btn.textContent = '‚è≥ Analyzing...';
            
            try {
                // Parse recent games
                const games = recentGamesInput.split(',').map(g => parseFloat(g.trim())).filter(g => !isNaN(g));
                if (games.length === 0) {
                    throw new Error('Invalid recent games format');
                }
                
                // Parse alt lines
                const lines = linesInput.trim().split('\n').map(line => {
                    const parts = line.trim().split(/\s+/);
                    if (parts.length !== 2) return null;
                    return {
                        line: parseFloat(parts[0]),
                        odds: parseInt(parts[1])
                    };
                }).filter(l => l && !isNaN(l.line) && !isNaN(l.odds));
                
                if (lines.length === 0) {
                    throw new Error('Invalid lines format. Use "line odds" format (e.g., "50 -850")');
                }
                
                // Parse minutes if provided
                const recentMinutesInput = document.getElementById('alt-recent-minutes')?.value;
                const tonightMinutesInput = document.getElementById('alt-tonight-minutes')?.value;
                const excludeOutliers = document.getElementById('alt-exclude-outliers')?.checked;
                
                let minutes = [];
                let usingPerMinute = false;
                
                if (recentMinutesInput && recentMinutesInput.trim()) {
                    minutes = recentMinutesInput.split(',').map(m => parseFloat(m.trim())).filter(m => !isNaN(m));
                    
                    if (minutes.length === games.length) {
                        usingPerMinute = true;
                    } else if (minutes.length > 0) {
                        alert(`Warning: Minutes count (${minutes.length}) doesn't match games count (${games.length}). Ignoring minutes.`);
                        minutes = [];
                    }
                }
                
                // Calculate base projection (with or without per-minute)
                let baseProjection;
                let perMinuteRate = null;
                let avgMinutes = null;
                let excludedGames = [];
                
                if (usingPerMinute) {
                    // Calculate per-minute rates
                    const gamesWithMinutes = games.map((stat, i) => ({
                        stat: stat,
                        minutes: minutes[i],
                        rate: stat / minutes[i]
                    }));
                    
                    // Calculate average rate for outlier detection
                    const rates = gamesWithMinutes.map(g => g.rate);
                    const meanRate = rates.reduce((a, b) => a + b, 0) / rates.length;
                    const stdDevRate = Math.sqrt(rates.reduce((sum, r) => sum + Math.pow(r - meanRate, 2), 0) / rates.length);
                    
                    // Filter outliers if requested
                    let filteredGames = gamesWithMinutes;
                    if (excludeOutliers && gamesWithMinutes.length > 3) {
                        filteredGames = gamesWithMinutes.filter(g => {
                            const zScore = Math.abs(g.rate - meanRate) / stdDevRate;
                            if (zScore > 2) {
                                excludedGames.push(g);
                                return false;
                            }
                            return true;
                        });
                    }
                    
                    // Calculate per-minute rate from filtered games
                    const totalStats = filteredGames.reduce((sum, g) => sum + g.stat, 0);
                    const totalMinutes = filteredGames.reduce((sum, g) => sum + g.minutes, 0);
                    perMinuteRate = totalStats / totalMinutes;
                    avgMinutes = totalMinutes / filteredGames.length;
                    
                    // Determine tonight's minutes
                    const tonightMinutes = tonightMinutesInput && !isNaN(parseFloat(tonightMinutesInput)) 
                        ? parseFloat(tonightMinutesInput) 
                        : avgMinutes;
                    
                    baseProjection = perMinuteRate * tonightMinutes;
                    
                    console.log('Per-minute calculation:', {
                        perMinuteRate: perMinuteRate.toFixed(3),
                        avgMinutes: avgMinutes.toFixed(1),
                        tonightMinutes: tonightMinutes.toFixed(1),
                        baseProjection: baseProjection.toFixed(1),
                        excludedGames: excludedGames.length
                    });
                    
                } else {
                    // Standard weighted average
                    const weights = games.map((_, i) => i + 1);
                    const weightedSum = games.reduce((sum, game, i) => sum + game * weights[i], 0);
                    baseProjection = weightedSum / weights.reduce((a, b) => a + b, 0);
                }
                
                // Apply context adjustments
                let adjustmentLog = [];
                let totalAdjustmentFactor = 1.0;
                
                // Opponent defense adjustment
                const opponentTeam = document.getElementById('alt-opponent-team')?.value;
                const playerName = player.toLowerCase().trim();
                const playerPosition = PLAYER_POSITIONS[playerName];
                
                console.log('DEBUG: Opponent adjustment check:');
                console.log('  opponentTeam:', opponentTeam);
                console.log('  playerName:', playerName);
                console.log('  playerPosition:', playerPosition);
                console.log('  propType:', propType);
                
                if (opponentTeam && playerPosition) {
                    // Determine prop-specific adjustment key
                    let defenseKey = null;
                    if (propType === 'points' || propType.includes('pts')) {
                        defenseKey = `points_${playerPosition}`;
                    } else if (propType === 'rebounds' || propType.includes('reb')) {
                        defenseKey = `rebounds_${playerPosition}`;
                    } else if (propType === 'assists' || propType.includes('ast')) {
                        defenseKey = 'assists';
                    } else if (propType === 'threes' || propType === '3pm') {
                        defenseKey = 'threes';
                    }
                    
                    console.log('  defenseKey:', defenseKey);
                    console.log('  NBA_DEFENSE_ADJ[defenseKey]:', NBA_DEFENSE_ADJ[defenseKey]);
                    
                    if (defenseKey && NBA_DEFENSE_ADJ[defenseKey] && NBA_DEFENSE_ADJ[defenseKey][opponentTeam] !== undefined) {
                        const defenseAdj = NBA_DEFENSE_ADJ[defenseKey][opponentTeam];
                        console.log('  APPLYING defenseAdj:', defenseAdj);
                        baseProjection += defenseAdj;
                        adjustmentLog.push(`${defenseAdj > 0 ? '+' : ''}${defenseAdj.toFixed(1)} (vs ${opponentTeam} ${playerPosition} defense)`);
                    } else {
                        console.log('  NOT APPLYING - defense data not found');
                    }
                } else {
                    console.log('  NOT APPLYING - missing opponent or position');
                }
                
                // Home/Away adjustment
                const homeAway = document.getElementById('alt-home-away')?.value || 'neutral';
                if (homeAway === 'home') {
                    totalAdjustmentFactor *= 1.05;
                    adjustmentLog.push('+5% (Home court advantage)');
                } else if (homeAway === 'away') {
                    totalAdjustmentFactor *= 0.95;
                    adjustmentLog.push('-5% (Away game penalty)');
                }
                
                // Rest days adjustment
                const restDays = parseInt(document.getElementById('alt-rest-days')?.value || '2');
                if (restDays === 0) {
                    totalAdjustmentFactor *= 0.88;
                    adjustmentLog.push('-12% (Back-to-back game fatigue)');
                } else if (restDays === 1) {
                    totalAdjustmentFactor *= 0.95;
                    adjustmentLog.push('-5% (1 day rest)');
                } else if (restDays >= 3) {
                    totalAdjustmentFactor *= 1.05;
                    adjustmentLog.push('+5% (Well rested 3+ days)');
                }
                
                // ========================================
                // BLOWOUT RISK DETECTOR
                // ========================================
                const gameSpread = parseFloat(document.getElementById('alt-game-spread')?.value || 0);
                const playerTeamFavored = (document.getElementById('alt-team-favored')?.value || 'neutral') === 'player';
                
                // Blowout thresholds
                const isLargeSpread = Math.abs(gameSpread) >= 10;
                const isHugeSpread = Math.abs(gameSpread) >= 15;
                
                let blowoutRisk = 0;
                let blowoutAdjustment = 1.0;
                
                if (isLargeSpread && playerTeamFavored) {
                    // Player's team is heavily favored - blowout rest risk
                    if (isHugeSpread) {
                        blowoutRisk = 60; // 60% chance of blowout if -15 or more
                        blowoutAdjustment = 0.88; // 12% reduction for likely rest
                        adjustmentLog.push(`-12% (High blowout risk: -${Math.abs(gameSpread)} spread)`);
                    } else {
                        blowoutRisk = 40; // 40% chance if -10 to -14.5
                        blowoutAdjustment = 0.95; // 5% reduction
                        adjustmentLog.push(`-5% (Moderate blowout risk: -${Math.abs(gameSpread)} spread)`);
                    }
                    totalAdjustmentFactor *= blowoutAdjustment;
                } else if (isLargeSpread && !playerTeamFavored) {
                    // Player's team is heavy underdog - garbage time opportunity
                    if (isHugeSpread) {
                        blowoutRisk = 60;
                        blowoutAdjustment = 0.92; // Slight reduction (less playing time as underdog)
                        adjustmentLog.push(`-8% (Heavy underdog: +${Math.abs(gameSpread)} spread, limited minutes likely)`);
                    } else {
                        blowoutRisk = 40;
                        blowoutAdjustment = 0.97;
                        adjustmentLog.push(`-3% (Underdog: +${Math.abs(gameSpread)} spread)`);
                    }
                    totalAdjustmentFactor *= blowoutAdjustment;
                }
                
                // Apply adjustments to base projection
                if (totalAdjustmentFactor !== 1.0) {
                    const unadjustedBase = baseProjection;
                    baseProjection = baseProjection * totalAdjustmentFactor;
                    adjustmentLog.unshift(`Base: ${unadjustedBase.toFixed(1)} ‚Üí ${baseProjection.toFixed(1)}`);
                }
                
                // Use adjusted projection if provided, otherwise use base
                const projection = adjustedProjectionInput && !isNaN(parseFloat(adjustedProjectionInput)) 
                    ? parseFloat(adjustedProjectionInput) 
                    : baseProjection;
                
                const usingAdjusted = projection !== baseProjection;
                
                // Calculate simple average and standard deviation
                const simpleAvg = calculateMean(games);
                const stdDev = calculateStdDev(games);
                const coefficientOfVariation = (stdDev / simpleAvg) * 100;
                
                // Analyze each line with adjusted hit rates
                const analyses = lines.map(({ line, odds }) => {
                    // Historical hit rate (raw data)
                    const hitsOver = games.filter(g => g > line).length;
                    let historicalHitRate = (hitsOver / games.length) * 100;
                    
                    // Adjusted hit rate based on distance from projection
                    const adjustedHitRateDecimal = calculateAdjustedHitRate(line, projection, stdDev, games);
                    let hitRate = adjustedHitRateDecimal * 100;
                    
                    // CRITICAL FIX: Cap hit rate at 95% (nothing is 100% certain)
                    let confidenceWarning = null;
                    if (hitRate > 95) {
                        confidenceWarning = "‚ö†Ô∏è Hit rate capped at 95% - no bet is 100% certain in sports";
                        hitRate = 95;
                    } else if (hitRate > 90) {
                        confidenceWarning = "‚ö†Ô∏è Very high confidence - verify game context (injuries, minutes, matchup)";
                    }
                    
                    // Additional warning if projection is way off from line
                    const projectionCushion = Math.abs(projection - line);
                    const cushionPercent = (projectionCushion / line) * 100;
                    if (cushionPercent > 50 && hitRate > 85) {
                        confidenceWarning = (confidenceWarning ? confidenceWarning + " | " : "") + 
                            `‚ö†Ô∏è Projection ${cushionPercent.toFixed(0)}% from line - double check data entry`;
                    }
                    
                    // Cap historical hit rate too
                    if (historicalHitRate > 95) {
                        historicalHitRate = 95;
                    }
                    
                    const impliedProb = odds < 0 
                        ? (Math.abs(odds) / (Math.abs(odds) + 100)) * 100
                        : (100 / (odds + 100)) * 100;
                    
                    const trueEdge = hitRate - impliedProb;
                    const edge = projection - line;
                    const edgePercent = (edge / line) * 100;
                    
                    // Calculate EV for $100 bet using ADJUSTED hit rate
                    const payout = odds > 0 ? odds : (100 / Math.abs(odds)) * 100;
                    const ev = (hitRate / 100) * payout - ((100 - hitRate) / 100) * 100;
                    
                    // Calculate distance from projection for warnings
                    const distanceFromProjection = line - projection;
                    const zScore = stdDev > 0 ? distanceFromProjection / stdDev : 0;
                    
                    // Determine if adjustment was made
                    const wasAdjusted = Math.abs(historicalHitRate - hitRate) > 2; // >2% difference
                    
                    return {
                        line,
                        odds,
                        hitRate,
                        historicalHitRate,
                        impliedProb,
                        trueEdge,
                        edge,
                        edgePercent,
                        ev,
                        projection,
                        distanceFromProjection,
                        zScore,
                        wasAdjusted,
                        confidenceWarning
                    };
                });
                
                // Sort by EV (best value first)
                analyses.sort((a, b) => b.ev - a.ev);
                
                // Find best bet
                const bestBet = analyses[0];
                const hasPositiveEV = analyses.some(a => a.ev > 0);
                
                // Display results
                let html = `
                    <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 12px; margin-bottom: 15px;">
                        <h3 style="margin-bottom: 10px;">${player} - ${formatPropTypeLabel(propType)}</h3>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-top: 15px;">
                            <div>
                                <div style="opacity: 0.8; font-size: 12px;">Projection</div>
                                <div style="font-size: 24px; font-weight: bold;">${projection.toFixed(1)}</div>
                                <div style="opacity: 0.7; font-size: 11px;">${usingAdjusted ? `Context-Adjusted` : 'Weighted Avg'}</div>
                                ${usingAdjusted ? `<div style="opacity: 0.6; font-size: 10px; margin-top: 2px;">Base: ${baseProjection.toFixed(1)}</div>` : ''}
                            </div>
                            <div>
                                <div style="opacity: 0.8; font-size: 12px;">95% Range</div>
                                <div style="font-size: 20px; font-weight: bold;">${(projection - stdDev * 2).toFixed(1)}-${(projection + stdDev * 2).toFixed(1)}</div>
                                <div style="opacity: 0.7; font-size: 11px;">Confidence interval</div>
                            </div>
                            <div>
                                <div style="opacity: 0.8; font-size: 12px;">Std Dev</div>
                                <div style="font-size: 24px; font-weight: bold;">${stdDev.toFixed(1)}</div>
                                <div style="opacity: 0.7; font-size: 11px;">Volatility measure</div>
                            </div>
                            <div>
                                <div style="opacity: 0.8; font-size: 12px;">Sample Size</div>
                                <div style="font-size: 24px; font-weight: bold; color: ${games.length < 10 ? '#fbbf24' : games.length < 15 ? '#60a5fa' : '#10b981'}">${games.length} games</div>
                                <div style="opacity: 0.7; font-size: 11px;">${games.length < 10 ? '‚ö†Ô∏è Small' : games.length < 15 ? '‚úì Moderate' : '‚úì Good'}</div>
                            </div>
                        </div>
                        ${games.length < 10 ? `
                        <div style="background: rgba(251, 191, 36, 0.2); border-left: 4px solid #fbbf24; padding: 12px; border-radius: 6px; margin-top: 15px; font-size: 13px;">
                            ‚ö†Ô∏è <strong>SMALL SAMPLE WARNING:</strong> Only ${games.length} games tracked. Projections less reliable with under 10 games. 
                            Consider betting smaller or waiting for more data. Confidence interval: ${(projection - stdDev * 2).toFixed(1)} to ${(projection + stdDev * 2).toFixed(1)}.
                        </div>
                        ` : ''}
                        ${usingAdjusted ? `
                        <div style="background: rgba(139, 92, 246, 0.2); border-left: 4px solid #8b5cf6; padding: 12px; border-radius: 6px; margin-top: 15px; font-size: 13px;">
                            üí° <strong>Using Context-Adjusted Projection:</strong> ${projection.toFixed(1)} (${projection > baseProjection ? '+' : ''}${(projection - baseProjection).toFixed(1)} from base ${baseProjection.toFixed(1)}). 
                            All hit rates and edges calculated using this adjusted projection for accuracy.
                        </div>
                        ` : ''}
                        ${adjustmentLog.length > 0 ? `
                        <div style="background: rgba(16, 185, 129, 0.15); border-left: 4px solid #10b981; padding: 12px; border-radius: 6px; margin-top: 15px; font-size: 12px;">
                            <strong>‚öôÔ∏è Applied Adjustments:</strong><br>
                            ${adjustmentLog.map(log => `<div style="margin-top: 4px; opacity: 0.9;">‚Ä¢ ${log}</div>`).join('')}
                        </div>
                        ` : ''}
                        ${usingPerMinute ? `
                        <div style="background: rgba(99, 102, 241, 0.15); border-left: 4px solid #6366f1; padding: 12px; border-radius: 6px; margin-top: 15px; font-size: 12px;">
                            <strong>üéØ Per-Minute Projection Active:</strong><br>
                            <div style="margin-top: 4px; opacity: 0.9;">‚Ä¢ Rate: ${perMinuteRate.toFixed(3)} per minute</div>
                            <div style="margin-top: 4px; opacity: 0.9;">‚Ä¢ Avg Minutes: ${avgMinutes.toFixed(1)} min/game</div>
                            ${tonightMinutesInput ? `<div style="margin-top: 4px; opacity: 0.9;">‚Ä¢ Tonight's Projection: ${parseFloat(tonightMinutesInput).toFixed(1)} minutes ‚Üí ${baseProjection.toFixed(1)} ${formatPropTypeLabel(propType).toLowerCase()}</div>` : ''}
                            ${excludedGames.length > 0 ? `<div style="margin-top: 4px; opacity: 0.9; color: #f59e0b;">‚Ä¢ Excluded ${excludedGames.length} outlier game(s) (>2 SD from mean rate)</div>` : ''}
                        </div>
                        ` : ''}
                        ${coefficientOfVariation > 40 ? `
                        <div style="background: rgba(255, 193, 7, 0.3); border-left: 4px solid #ffc107; padding: 12px; border-radius: 6px; margin-top: 15px; font-size: 13px;">
                            ‚ö†Ô∏è <strong>HIGH VOLATILITY WARNING:</strong> This player's stats vary by ${coefficientOfVariation.toFixed(0)}% (CV). 
                            Performance is inconsistent - hit rates may be less reliable. Consider reducing bet size.
                        </div>
                        ` : ''}
                    </div>
                `;
                
                if (hasPositiveEV) {
                    const bestBetWarning = bestBet.distanceFromProjection > stdDev ? 
                        ` <span style="font-size: 12px; opacity: 0.85;">‚ö†Ô∏è ${Math.abs(bestBet.distanceFromProjection).toFixed(1)} ${bestBet.distanceFromProjection > 0 ? 'above' : 'below'} projection</span>` : '';
                    
                    // Get calibrated hit rate if available
                    const calibratedHitRate = getCalibratedHitRate(bestBet.hitRate);
                    const hitRateDisplay = calibratedHitRate 
                        ? `<span style="text-decoration: line-through; opacity: 0.6;">${bestBet.hitRate.toFixed(1)}%</span> ‚Üí <strong>${calibratedHitRate.toFixed(1)}%</strong> calibrated`
                        : `${bestBet.hitRate.toFixed(1)}% hit rate`;
                    
                    html += `
                        <div style="background: #22c55e; color: white; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <strong>üéØ BEST VALUE:</strong> OVER ${bestBet.line} at ${bestBet.odds > 0 ? '+' : ''}${bestBet.odds}${bestBetWarning}
                            <br>
                            <span style="font-size: 14px; opacity: 0.9;">
                                ${hitRateDisplay} | ${bestBet.trueEdge > 0 ? '+' : ''}${bestBet.trueEdge.toFixed(1)}% true edge | $${bestBet.ev.toFixed(2)} EV per $100
                            </span>
                            ${calibratedHitRate ? `<br><span style="font-size: 11px; opacity: 0.75;">üìä Based on ${trackedBets.filter(b => b.hit_rate && b.actualResult && !b.excludeFromML).length} tracked bets</span>` : ''}
                        </div>
                    `;
                } else {
                    html += `
                        <div style="background: #f59e0b; color: white; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <strong>‚ö†Ô∏è NO POSITIVE VALUE FOUND</strong>
                            <br>
                            <span style="font-size: 14px; opacity: 0.9;">
                                All lines have negative expected value individually. However, you can still add them to parlays for custom combinations.
                            </span>
                            <br>
                            <span style="font-size: 12px; opacity: 0.8; margin-top: 8px; display: inline-block;">
                                üí° TIP: Negative EV bets can become positive when combined in uncorrelated parlays. Use "‚ûï Add ‚ö†Ô∏è" buttons below.
                            </span>
                        </div>
                    `;
                }
                
                // Table of all lines
                html += `
                    <div style="background: white; border-radius: 8px; overflow: hidden;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background: #f1f5f9;">
                                    <th style="padding: 12px; text-align: left; border-bottom: 2px solid #cbd5e1;">Line</th>
                                    <th style="padding: 12px; text-align: left; border-bottom: 2px solid #cbd5e1;">Odds</th>
                                    <th style="padding: 12px; text-align: center; border-bottom: 2px solid #cbd5e1;">Hit Rate</th>
                                    <th style="padding: 12px; text-align: center; border-bottom: 2px solid #cbd5e1;">Implied</th>
                                    <th style="padding: 12px; text-align: center; border-bottom: 2px solid #cbd5e1;">True Edge</th>
                                    <th style="padding: 12px; text-align: center; border-bottom: 2px solid #cbd5e1;">EV ($100)</th>
                                    <th style="padding: 12px; text-align: center; border-bottom: 2px solid #cbd5e1;">Rating</th>
                                    <th style="padding: 12px; text-align: center; border-bottom: 2px solid #cbd5e1;">Action</th>
                                </tr>
                            </thead>
                            <tbody>
                `;
                
                analyses.forEach((analysis, index) => {
                    const rowBg = index % 2 === 0 ? '#f8fafc' : 'white';
                    const isEV = analysis.ev > 0;
                    const edgeColor = analysis.trueEdge < 0 ? '#ef4444' : analysis.trueEdge > 10 ? '#22c55e' : '#f59e0b';
                    
                    let rating, ratingColor;
                    if (analysis.ev > 10) {
                        rating = 'üî• Excellent';
                        ratingColor = '#22c55e';
                    } else if (analysis.ev > 5) {
                        rating = '‚úÖ Good';
                        ratingColor = '#3b82f6';
                    } else if (analysis.ev > 0) {
                        rating = '‚ö° Fair';
                        ratingColor = '#f59e0b';
                    } else if (analysis.ev > -5) {
                        rating = '‚ö†Ô∏è Poor';
                        ratingColor = '#f97316';
                    } else {
                        rating = '‚ùå Bad';
                        ratingColor = '#ef4444';
                    }
                    
                    // Determine warnings
                    let warnings = [];
                    if (Math.abs(analysis.distanceFromProjection) > stdDev) {
                        warnings.push(analysis.distanceFromProjection > 0 ? '‚¨ÜÔ∏è Above projection' : '‚¨áÔ∏è Below projection');
                    }
                    if (analysis.wasAdjusted) {
                        warnings.push('üìä Adjusted');
                    }
                    if (Math.abs(analysis.zScore) > 1.5) {
                        warnings.push('‚ö†Ô∏è High variance');
                    }
                    
                    const warningText = warnings.length > 0 ? `<br><span style="font-size: 10px; opacity: 0.7;">${warnings.join(' ‚Ä¢ ')}</span>` : '';
                    
                    // Tooltip for adjusted hit rate
                    const hitRateDisplay = analysis.wasAdjusted ? 
                        `<span title="Historical: ${analysis.historicalHitRate.toFixed(1)}% ‚Üí Adjusted: ${analysis.hitRate.toFixed(1)}%" style="cursor: help; border-bottom: 1px dotted #666;">${analysis.hitRate.toFixed(1)}%*</span>` :
                        `${analysis.hitRate.toFixed(1)}%`;
                    
                    html += `
                        <tr style="background: ${rowBg};">
                            <td style="padding: 12px; font-weight: bold;">
                                OVER ${analysis.line}${warningText}
                            </td>
                            <td style="padding: 12px;">${analysis.odds > 0 ? '+' : ''}${analysis.odds}</td>
                            <td style="padding: 12px; text-align: center;">${hitRateDisplay}</td>
                            <td style="padding: 12px; text-align: center;">${analysis.impliedProb.toFixed(1)}%</td>
                            <td style="padding: 12px; text-align: center; color: ${edgeColor}; font-weight: bold;">
                                ${analysis.trueEdge > 0 ? '+' : ''}${analysis.trueEdge.toFixed(1)}%
                            </td>
                            <td style="padding: 12px; text-align: center; font-weight: bold; color: ${isEV ? '#22c55e' : '#ef4444'};">
                                $${analysis.ev.toFixed(2)}
                            </td>
                            <td style="padding: 12px; text-align: center; color: ${ratingColor}; font-weight: bold;">
                                ${rating}
                            </td>
                            <td style="padding: 12px; text-align: center;">
                                <button onclick='addAltLineToParlay(${JSON.stringify({
                                    player: player,
                                    propType: propType,
                                    line: analysis.line,
                                    odds: analysis.odds,
                                    hitRate: analysis.hitRate,
                                    games: games,
                                    projection: analysis.projection,
                                    trueEdge: analysis.trueEdge,
                                    impliedProb: analysis.impliedProb,
                                    edge: analysis.edge,
                                    edgePercent: analysis.edgePercent
                                })})' 
                                    style="padding: 6px 12px; background: ${isEV ? '#22c55e' : '#f59e0b'}; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600;"
                                    title="${!isEV ? 'Warning: Negative EV (-$' + Math.abs(analysis.ev).toFixed(2) + ' per $100). Add anyway for parlay building.' : 'Positive EV bet'}">
                                    ‚ûï Add${!isEV ? ' ‚ö†Ô∏è' : ''}
                                </button>
                            </td>
                        </tr>
                    `;
                });
                
                html += `
                            </tbody>
                        </table>
                    </div>
                `;
                
                // Add explanation
                const hasAdjustments = analyses.some(a => a.wasAdjusted);
                
                html += `
                    <div style="background: #f1f5f9; padding: 15px; border-radius: 8px; margin-top: 15px; font-size: 14px; color: #334155;">
                        <strong>üìö How to read this:</strong>
                        <ul style="margin: 10px 0; padding-left: 20px;">
                            <li><strong>Hit Rate${hasAdjustments ? '*' : ''}:</strong> % chance this bet hits (based on recent games ${hasAdjustments ? '+ statistical adjustment' : ''})</li>
                            <li><strong>Implied:</strong> What the odds suggest your win probability is</li>
                            <li><strong>True Edge:</strong> Hit rate minus implied probability (positive = value)</li>
                            <li><strong>EV (Expected Value):</strong> Average profit/loss per $100 bet over time</li>
                            <li><strong>Rating:</strong> üî• Excellent (EV > $10) | ‚úÖ Good ($5-10) | ‚ö° Fair ($0-5) | ‚ö†Ô∏è Poor (-$5-0) | ‚ùå Bad (< -$5)</li>
                        </ul>
                        ${hasAdjustments ? `
                        <div style="background: rgba(147, 197, 253, 0.2); border-left: 3px solid #3b82f6; padding: 10px; margin-top: 10px; border-radius: 4px;">
                            <strong>üìä Hit Rate Adjustments:</strong>
                            <p style="margin: 5px 0; line-height: 1.6;">
                                Lines marked with * have adjusted hit rates. When a line is far from the projection (${projection.toFixed(1)}), 
                                we adjust the hit rate using statistical probability to be more accurate. This prevents overestimating 
                                unlikely outcomes (like lines ${stdDev.toFixed(0)}+ above projection).
                            </p>
                            <p style="margin: 5px 0; font-size: 12px; opacity: 0.9;">
                                <strong>Example:</strong> If 3 of 7 games hit OVER 30, that's 42.9% historically. But if the projection 
                                is 25, it's unlikely this 42.9% rate continues. We adjust it to ~27% based on distance from projection.
                            </p>
                        </div>
                        ` : ''}
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #cbd5e1;">
                            <strong>‚ö†Ô∏è Warning Icons:</strong>
                            <ul style="margin: 5px 0; padding-left: 20px; font-size: 13px;">
                                <li><strong>‚¨ÜÔ∏è Above projection:</strong> Line is higher than expected (boom play)</li>
                                <li><strong>‚¨áÔ∏è Below projection:</strong> Line is lower than expected (safe play)</li>
                                <li><strong>üìä Adjusted:</strong> Hit rate was adjusted based on distance from projection</li>
                                <li><strong>‚ö†Ô∏è High variance:</strong> Line is 1.5+ std deviations from projection (risky)</li>
                            </ul>
                        </div>
                        <p style="margin-top: 12px; font-weight: bold;">
                            üí° Strategy: Prioritize lines NEAR projection (${(projection - stdDev).toFixed(1)}-${(projection + stdDev).toFixed(1)}) for more reliable bets.
                        </p>
                    </div>
                `;
                
                resultsDiv.innerHTML = html;
                
            } catch (error) {
                resultsDiv.innerHTML = `
                    <div class="empty-state">
                        <h3>‚ùå Error</h3>
                        <p>${error.message}</p>
                    </div>
                `;
            } finally {
                btn.disabled = false;
                btn.textContent = 'üìä Compare Alt Lines';
            }
        }
        
        function addAltLineToParlay(altLine) {
            // Convert alt line data to bet format for currentParlay (Parlay Builder)
            const bet = {
                player: altLine.player,
                prop_type: altLine.propType,
                bet: 'OVER',
                line: altLine.line,
                odds: altLine.odds,
                bookmaker: 'FanDuel',
                adjusted_projection: altLine.projection.toFixed(1),  // Use adjusted_projection field
                hit_rate: altLine.hitRate.toFixed(1),
                edge: (altLine.projection - altLine.line).toFixed(1),
                true_edge: altLine.trueEdge.toFixed(1),
                manual_games: true,
                is_alt_line: true  // Flag to indicate this is an alt line (uses >= not >)
            };
            
            // Check if already in current parlay
            const alreadyExists = currentParlay.some(b => 
                b.player === bet.player && 
                b.prop_type === bet.prop_type && 
                b.line === bet.line
            );
            
            if (alreadyExists) {
                alert(`${bet.player} OVER ${bet.line} is already in your parlay`);
                return;
            }
            
            // Add to current parlay (Parlay Builder tab)
            currentParlay.push(bet);
            localStorage.setItem('currentParlay', JSON.stringify(currentParlay));
            updateParlayDisplay();
            
            // ALSO add to Manual Parlay section (Build Parlay from Manual Bets)
            manualParlayBets.push(bet);
            updateManualParlayList();
            
            // Add to AI Parlay Pool
            addToAIPool(bet);
            
            // Show success message
            const successMsg = document.createElement('div');
            successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #22c55e; color: white; padding: 15px 20px; border-radius: 8px; font-weight: bold; z-index: 9999; box-shadow: 0 4px 6px rgba(0,0,0,0.1);';
            successMsg.innerHTML = `‚úÖ Added ${bet.player} OVER ${bet.line} to Parlay Builder<br><small style="font-size: 11px; opacity: 0.9; margin-top: 4px; display: block;">‚ú® Also added to AI Parlay Pool & Manual Bets</small>`;
            document.body.appendChild(successMsg);
            
            setTimeout(() => {
                successMsg.remove();
            }, 3000);
            
            // Switch to Parlay Builder tab
            showTab('parlay');
        }
        
        function displayManualBet(bet, container) {
            const confidenceClass = `confidence-${bet.confidence.toLowerCase()}`;
            const edgeColor = parseFloat(bet.edge) > 0 ? '#4ade80' : '#f87171';
            const now = new Date();
            const timestamp = now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
            
            const html = `
                <div class="bet-card">
                    <div class="bet-header">
                        <div class="player-name">${bet.player}</div>
                        <div class="confidence-badge ${confidenceClass}">${bet.confidence}</div>
                    </div>
                    <div style="font-size: 24px; font-weight: bold; margin-bottom: 10px;">
                        ${bet.bet} ${bet.line} ${bet.prop_type.replace('_', ' ')}
                        ${bet.opponent ? `<span style="font-size: 16px; opacity: 0.9;"> vs ${bet.opponent}</span>` : ''}
                    </div>
                    <div style="font-size: 16px; opacity: 0.9; margin-bottom: 15px;">
                        ${bet.odds > 0 ? '+' : ''}${bet.odds} at ${bet.bookmaker}
                    </div>
                    <div style="font-size: 11px; opacity: 0.7; margin-bottom: 15px;">
                        üìä Analysis as of ${timestamp} - Always verify lines on sportsbook before betting
                    </div>
                    <div style="background: rgba(255,255,255,0.2); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <div style="font-size: 18px; font-weight: bold; margin-bottom: 8px;">
                            ${bet.recommendation}
                        </div>
                        <div style="font-size: 14px; opacity: 0.9;">
                            ${getRecommendationExplanation(bet)}
                        </div>
                        ${parseFloat(bet.cv) > 40 ? `
                        <div style="background: rgba(251, 191, 36, 0.3); border-left: 4px solid #fbbf24; padding: 10px; margin-top: 12px; border-radius: 4px; font-size: 13px;">
                            ‚ö†Ô∏è <strong>HIGH VOLATILITY WARNING:</strong> Player's stats vary by ${bet.cv}% (CV). 
                            Performance is inconsistent (range: ${Math.min(...bet.games)}-${Math.max(...bet.games)}) - hit rates may be less reliable.
                        </div>
                        ` : ''}
                        ${!bet.projection_supports ? `
                        <div style="background: rgba(239, 68, 68, 0.2); border-left: 4px solid #ef4444; padding: 10px; margin-top: 12px; border-radius: 4px; font-size: 13px;">
                            ‚ö†Ô∏è <strong>PROJECTION CONFLICT:</strong> Projection (${bet.weighted_avg}) ${bet.bet === 'OVER' ? 'is below' : 'is above'} line (${bet.line}). 
                            Recommendation is based on true edge, but projection doesn't strongly support this side.
                        </div>
                        ` : ''}
                        ${bet.other_side ? `
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.2); font-size: 13px;">
                            <strong>üìä Why ${bet.bet} over ${bet.other_side.side}:</strong><br>
                            ${bet.bet}: ${bet.true_edge}% true edge (${bet.hit_rate}% hit rate vs ${bet.implied_prob}% implied)<br>
                            ${bet.other_side.side}: ${bet.other_side.trueEdge.toFixed(1)}% true edge (${bet.other_side.hitRate.toFixed(1)}% hit rate vs ${bet.other_side.impliedProb.toFixed(1)}% implied)
                            ${Math.abs(parseFloat(bet.weighted_avg) - parseFloat(bet.line)) < 1.0 ? '<br><span style="opacity: 0.8;">Note: Projection very close to line - using true edge as tiebreaker</span>' : ''}
                        </div>
                        ` : ''}
                    </div>
                    <div class="bet-details">
                        <div class="bet-stat">
                            <div class="bet-stat-label">Projection</div>
                            <div class="bet-stat-value">${bet.adjusted_projection}
                                ${bet.projection_supports ? (bet.bet === 'OVER' ? ' ‚¨ÜÔ∏è' : ' ‚¨áÔ∏è') : ' ‚ö†Ô∏è'}
                            </div>
                            ${bet.adjustments && bet.adjustments.length > 0 ? `
                            <div style="font-size: 11px; opacity: 0.7; margin-top: 4px;">
                                Base: ${bet.base_projection} ‚Üí Adjusted: ${bet.adjusted_projection}
                                <br>Context adjustment: ${parseFloat(bet.total_adjustment) > 0 ? '+' : ''}${bet.total_adjustment}
                            </div>
                            ` : `
                            <div style="font-size: 11px; opacity: 0.7; margin-top: 4px;">
                                Simple Avg: ${bet.simple_avg} | Std Dev: ¬±${bet.std_dev}
                            </div>
                            `}
                        </div>
                        <div class="bet-stat">
                            <div class="bet-stat-label">Edge</div>
                            <div class="bet-stat-value" style="color: ${edgeColor};">
                                ${parseFloat(bet.edge) > 0 ? '+' : ''}${bet.edge} (${parseFloat(bet.edge_percent) > 0 ? '+' : ''}${bet.edge_percent}%)
                            </div>
                        </div>
                        <div class="bet-stat">
                            <div class="bet-stat-label">Hit Rate (${bet.bet})</div>
                            <div class="bet-stat-value">
                                ${bet.was_adjusted ? `<span title="Historical: ${bet.historical_hit_rate}% ‚Üí Adjusted: ${bet.hit_rate}%" style="cursor: help; border-bottom: 1px dotted #fff;">${bet.hit_rate}%*</span>` : `${bet.hit_rate}%`}
                            </div>
                            ${bet.was_adjusted ? `<div style="font-size: 10px; opacity: 0.7; margin-top: 4px;">*Adjusted for distance from projection</div>` : ''}
                        </div>
                        ${bet.true_edge ? `
                        <div class="bet-stat">
                            <div class="bet-stat-label">True Edge</div>
                            <div class="bet-stat-value" style="color: ${parseFloat(bet.true_edge) > 0 ? '#4ade80' : '#f87171'};">
                                ${parseFloat(bet.true_edge) > 0 ? '+' : ''}${bet.true_edge}%
                            </div>
                            ${(() => {
                                const edge = parseFloat(bet.true_edge);
                                let rating, stars, color, quality, barWidth;
                                
                                if (edge >= 25) {
                                    rating = 5;
                                    stars = '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê';
                                    color = '#10b981';
                                    quality = 'ELITE';
                                    barWidth = '100%';
                                } else if (edge >= 15) {
                                    rating = 4;
                                    stars = '‚≠ê‚≠ê‚≠ê‚≠ê';
                                    color = '#4ade80';
                                    quality = 'EXCELLENT';
                                    barWidth = '80%';
                                } else if (edge >= 10) {
                                    rating = 3;
                                    stars = '‚≠ê‚≠ê‚≠ê';
                                    color = '#fbbf24';
                                    quality = 'GOOD';
                                    barWidth = '60%';
                                } else if (edge >= 5) {
                                    rating = 2;
                                    stars = '‚≠ê‚≠ê';
                                    color = '#f59e0b';
                                    quality = 'FAIR';
                                    barWidth = '40%';
                                } else if (edge > 0) {
                                    rating = 1;
                                    stars = '‚≠ê';
                                    color = '#9ca3af';
                                    quality = 'MARGINAL';
                                    barWidth = '20%';
                                } else {
                                    rating = 0;
                                    stars = '‚òÜ‚òÜ‚òÜ‚òÜ‚òÜ';
                                    color = '#ef4444';
                                    quality = 'NEGATIVE';
                                    barWidth = '0%';
                                }
                                
                                return `
                                    <div style="margin-top: 8px;">
                                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                                            <span style="font-size: 14px;">${stars}</span>
                                            <span style="font-size: 11px; font-weight: 600; color: ${color};">${quality}</span>
                                        </div>
                                        <div style="background: rgba(255,255,255,0.2); height: 8px; border-radius: 4px; overflow: hidden;">
                                            <div style="background: ${color}; height: 100%; width: ${barWidth}; transition: width 0.3s;"></div>
                                        </div>
                                        <div style="font-size: 10px; opacity: 0.7; margin-top: 4px;">
                                            ${edge >= 25 ? 'üî• Rare value - Bet heavy!' : 
                                              edge >= 15 ? '‚úÖ Strong edge - Bet with confidence' :
                                              edge >= 10 ? 'üëç Solid edge - Good bet' :
                                              edge >= 5 ? '‚ö†Ô∏è Small edge - Bet cautiously' :
                                              edge > 0 ? 'üòê Minimal edge - Consider passing' :
                                              '‚ùå Negative edge - Do not bet'}
                                        </div>
                                    </div>
                                `;
                            })()}
                        </div>
                        ` : ''}
                        ${bet.implied_prob ? `
                        <div class="bet-stat">
                            <div class="bet-stat-label">Implied Prob (from odds)</div>
                            <div class="bet-stat-value">${bet.implied_prob}%</div>
                        </div>
                        ` : ''}
                        <div class="bet-stat">
                            <div class="bet-stat-label">Recent Games</div>
                            <div class="bet-stat-value" style="font-size: 14px;">
                                ${bet.games.join(', ')}
                                ${bet.manual_games ? '<br><span style="font-size: 11px; color: #4ade80;">‚úì Manual Entry</span>' : '<br><span style="font-size: 11px; opacity: 0.7;">‚ö†Ô∏è Estimates</span>'}
                            </div>
                        </div>
                        ${bet.shooting_analysis ? `
                        <div class="bet-stat" style="grid-column: 1 / -1;">
                            <div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 12px; border-radius: 6px;">
                                <div style="font-weight: 600; color: #92400e; margin-bottom: 8px;">
                                    üéØ Shooting Efficiency Analysis
                                </div>
                                ${bet.shooting_analysis.type === 'FGA' ? `
                                    <div style="font-size: 12px; color: #78350f; line-height: 1.6;">
                                        <div><strong>Avg FGA:</strong> ${bet.shooting_analysis.avgAttempts.toFixed(1)} attempts/game</div>
                                        <div><strong>Efficiency:</strong> ${bet.shooting_analysis.pointsPerAttempt.toFixed(2)} pts/attempt</div>
                                        <div><strong>Efficiency Range:</strong> ${bet.shooting_analysis.ptsPerAttemptRange.min.toFixed(2)} - ${bet.shooting_analysis.ptsPerAttemptRange.max.toFixed(2)} pts/attempt</div>
                                        <div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #fbbf24;">
                                            <strong>Projected Range:</strong> ${bet.shooting_analysis.projectedRange.low.toFixed(1)} - ${bet.shooting_analysis.projectedRange.high.toFixed(1)} points
                                            <div style="font-size: 11px; margin-top: 4px; opacity: 0.9;">
                                                ${bet.shooting_analysis.varianceWarning ? 
                                                    '‚ö†Ô∏è High shooting variance - bad night (30% below avg) could significantly impact' :
                                                    '‚úÖ Consistent shooting - projection is reliable'}
                                            </div>
                                        </div>
                                    </div>
                                ` : ''}
                                ${bet.shooting_analysis.type === '3PA' ? `
                                    <div style="font-size: 12px; color: #78350f; line-height: 1.6;">
                                        <div><strong>Avg 3PA:</strong> ${bet.shooting_analysis.avgAttempts.toFixed(1)} attempts/game</div>
                                        <div><strong>3P%:</strong> ${bet.shooting_analysis.avg3PPercent.toFixed(1)}% (${bet.shooting_analysis.threesPerAttempt.toFixed(2)} makes/attempt)</div>
                                        <div><strong>3P% Range:</strong> ${bet.shooting_analysis.tpRange.min.toFixed(1)}% - ${bet.shooting_analysis.tpRange.max.toFixed(1)}%</div>
                                        <div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid #fbbf24;">
                                            <strong>To hit ${bet.line} makes:</strong> Needs ${bet.shooting_analysis.attemptsNeeded}+ attempts OR ${bet.shooting_analysis.percentNeeded.toFixed(1)}% shooting
                                            <div style="font-size: 11px; margin-top: 4px; opacity: 0.9;">
                                                ${bet.shooting_analysis.volumeRisk ? 
                                                    '‚ö†Ô∏è Volume risk - averages fewer attempts than needed' :
                                                    '‚úÖ Takes enough shots - volume is good'}
                                                ${bet.shooting_analysis.varianceWarning ? 
                                                    '<br>‚ö†Ô∏è High 3P% variance - shooting percentage is inconsistent' :
                                                    ''}
                                            </div>
                                        </div>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                        ` : ''}
                    </div>
                    
                    <div style="margin-top: 15px;">
                        <button onclick="addToParlay(${JSON.stringify(bet).replace(/"/g, '&quot;')})" 
                                style="width: 100%; padding: 15px; background: #8b5cf6; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 15px; margin-bottom: 10px;">
                            ‚ûï Add to Parlay
                        </button>
                        <button onclick="sendToAltLines(${JSON.stringify(bet).replace(/"/g, '&quot;')})" 
                                style="width: 100%; padding: 12px; background: #0ea5e9; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px; margin-bottom: 10px;">
                            üì§ Send to Alt Lines Analyzer
                        </button>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <button onclick="trackBetResult('${bet.player}', '${bet.prop_type}', ${bet.line}, '${bet.bet}', ${bet.adjusted_projection}, 'win', ${JSON.stringify(bet).replace(/"/g, '&quot;')})" 
                                    style="padding: 12px; background: #10b981; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;">
                                ‚úÖ Single WIN
                            </button>
                            <button onclick="trackBetResult('${bet.player}', '${bet.prop_type}', ${bet.line}, '${bet.bet}', ${bet.adjusted_projection}, 'loss', ${JSON.stringify(bet).replace(/"/g, '&quot;')})" 
                                    style="padding: 12px; background: #ef4444; color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; font-size: 14px;">
                                ‚ùå Single LOSS
                            </button>
                        </div>
                        <small style="display: block; color: #6b7280; text-align: center; margin-top: 8px; font-size: 12px;">
                            For parlays: Click "Add to Parlay", then track in Parlay Builder tab
                        </small>
                    </div>
                </div>
            `;
            
            container.innerHTML = html;
            
            // Add to parlay list
            manualParlayBets.push(bet);
            updateManualParlayList();
        }
        
        function getRecommendationExplanation(bet) {
            const edge = parseFloat(bet.edge_percent);
            const hitRate = parseFloat(bet.hit_rate);
            const trueEdge = bet.true_edge ? parseFloat(bet.true_edge) : null;
            
            if (bet.recommendation.includes('STRONG')) {
                return `Strong ${bet.bet.toLowerCase()} play with ${Math.abs(edge).toFixed(1)}% edge and ${hitRate.toFixed(0)}% hit rate${trueEdge ? ` (${trueEdge > 0 ? '+' : ''}${trueEdge.toFixed(1)}% vs implied odds)` : ''}`;
            } else if (bet.recommendation.includes('GOOD')) {
                return `Good value with ${Math.abs(edge).toFixed(1)}% projection edge and ${hitRate.toFixed(0)}% historical success rate`;
            } else if (bet.recommendation.includes('BET')) {
                return `Decent edge at ${Math.abs(edge).toFixed(1)}%${trueEdge && trueEdge > 5 ? ` with +${trueEdge.toFixed(1)}% advantage over implied odds` : ''}`;
            } else if (bet.recommendation.includes('LEAN')) {
                return `Small edge (${Math.abs(edge).toFixed(1)}%) - consider as part of larger strategy`;
            } else {
                return `Limited edge or inconsistent performance - projection: ${bet.weighted_avg}, line: ${bet.line}`;
            }
        }
        
        function updateComparison() {
            const container = document.getElementById('comparison-bets');
            
            if (comparisonBets.length === 0) {
                container.innerHTML = '<p style="color: #666; text-align: center; padding: 20px;">Add bets to compare them here</p>';
                return;
            }
            
            // Group by player and prop type
            const grouped = {};
            comparisonBets.forEach(bet => {
                const key = `${bet.player}_${bet.prop_type}`;
                if (!grouped[key]) {
                    grouped[key] = [];
                }
                grouped[key].push(bet);
            });
            
            let html = '';
            Object.keys(grouped).forEach(key => {
                const bets = grouped[key];
                const [player, propType] = key.split('_');
                
                html += `
                    <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <div style="font-weight: bold; margin-bottom: 10px;">
                            ${player} - ${propType.replace('_', ' ')}
                        </div>
                        <div style="display: grid; gap: 10px;">
                `;
                
                bets.forEach((bet, idx) => {
                    const edgeColor = parseFloat(bet.edge) > 0 ? '#22c55e' : '#ef4444';
                    html += `
                        <div style="background: white; padding: 12px; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${bet.bookmaker}</strong>: ${bet.bet} ${bet.line} (${bet.odds > 0 ? '+' : ''}${bet.odds})
                            </div>
                            <div style="text-align: right;">
                                <div style="font-weight: bold; color: ${edgeColor};">
                                    ${parseFloat(bet.edge_percent) > 0 ? '+' : ''}${bet.edge_percent}% edge
                                </div>
                                <div style="font-size: 12px; color: #666;">${bet.confidence}</div>
                            </div>
                        </div>
                    `;
                });
                
                html += `
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function clearComparison() {
            comparisonBets = [];
            updateComparison();
        }
        
        // currentGameBets already declared above - no need to redeclare
        
        async function buildParlays() {
            const numParlays = parseInt(document.getElementById('num-parlays').value) || 3;
            const legsPerParlay = parseInt(document.getElementById('parlay-legs').value) || 4;
            const resultsDiv = document.getElementById('parlay-results');
            const btn = document.getElementById('build-parlay-btn');
            
            if (currentGameBets.length === 0) {
                alert('Please search for a game first to get available bets');
                return;
            }
            
            if (currentGameBets.length < legsPerParlay) {
                alert(`Not enough bets found. Only ${currentGameBets.length} bets available, need at least ${legsPerParlay}`);
                return;
            }
            
            btn.disabled = true;
            btn.textContent = '‚è≥ Building...';
            
            resultsDiv.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Building ${numParlays} optimized parlays...</p>
                </div>
            `;
            
            // Sort bets by edge and confidence
            const sortedBets = [...currentGameBets].sort((a, b) => {
                // Sort by confidence first, then edge
                const confidenceScore = {High: 3, Medium: 2, Low: 1};
                if (confidenceScore[a.confidence] !== confidenceScore[b.confidence]) {
                    return confidenceScore[b.confidence] - confidenceScore[a.confidence];
                }
                return parseFloat(b.edge_percent) - parseFloat(a.edge_percent);
            });
            
            const parlays = [];
            const usedBets = new Set(); // Track which exact bets we've used globally
            
            // Build different risk level parlays
            const riskLevels = [
                {name: 'Conservative', desc: 'High confidence plays only', minConfidence: 'High', minEdge: 8},
                {name: 'Balanced', desc: 'Mix of high and medium confidence', minConfidence: 'Medium', minEdge: 3},
                {name: 'Aggressive', desc: 'Highest edges, any confidence', minConfidence: 'Low', minEdge: 0}
            ];
            
            for (let i = 0; i < numParlays && i < riskLevels.length; i++) {
                const risk = riskLevels[i];
                
                // Filter bets by risk criteria AND exclude already used bets
                let availableBets = sortedBets.filter(bet => {
                    // Create unique key for this EXACT bet (player + prop + line + direction)
                    const betKey = `${bet.player}_${bet.prop_type}_${bet.line}_${bet.bet}`;
                    if (usedBets.has(betKey)) {
                        return false; // Skip if this exact bet was already used
                    }
                    
                    const confidenceScore = {High: 3, Medium: 2, Low: 1};
                    const minScore = {High: 3, Medium: 2, Low: 1}[risk.minConfidence];
                    return confidenceScore[bet.confidence] >= minScore && 
                           parseFloat(bet.edge_percent) >= risk.minEdge;
                });
                
                // Take top legs for this parlay
                const parlayLegs = availableBets.slice(0, legsPerParlay);
                
                if (parlayLegs.length >= 2) {
                    // Mark these EXACT bets as used globally
                    parlayLegs.forEach(leg => {
                        const betKey = `${leg.player}_${leg.prop_type}_${leg.line}_${leg.bet}`;
                        usedBets.add(betKey);
                    });
                    
                    // Calculate parlay odds (simple multiplication for demonstration)
                    let totalOdds = 1;
                    let avgEdge = 0;
                    let avgHitRate = 0;
                    
                    parlayLegs.forEach(leg => {
                        // Convert American odds to decimal
                        const decimalOdds = leg.odds > 0 ? (leg.odds / 100) + 1 : (100 / Math.abs(leg.odds)) + 1;
                        totalOdds *= decimalOdds;
                        avgEdge += parseFloat(leg.edge_percent);
                        avgHitRate += parseFloat(leg.hit_rate);
                    });
                    
                    avgEdge /= parlayLegs.length;
                    avgHitRate /= parlayLegs.length;
                    
                    // Convert back to American odds
                    const americanOdds = totalOdds >= 2 ? Math.round((totalOdds - 1) * 100) : Math.round(-100 / (totalOdds - 1));
                    
                    parlays.push({
                        name: risk.name,
                        description: risk.desc,
                        legs: parlayLegs,
                        totalOdds: americanOdds,
                        avgEdge: avgEdge.toFixed(1),
                        avgHitRate: avgHitRate.toFixed(1),
                        numLegs: parlayLegs.length
                    });
                }
            }
            
            if (parlays.length === 0) {
                resultsDiv.innerHTML = `
                    <div class="empty-state">
                        <h3>Not Enough Bets</h3>
                        <p>Could not build parlays with current criteria. Try lowering minimum edge.</p>
                    </div>
                `;
                btn.disabled = false;
                btn.textContent = 'üé∞ Build Parlays';
                return;
            }
            
            displayParlays(parlays, resultsDiv);
            btn.disabled = false;
            btn.textContent = 'üé∞ Build Parlays';
        }
        
        function displayParlays(parlays, container) {
            let html = '';
            
            parlays.forEach((parlay, index) => {
                const gradients = [
                    'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                    'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                    'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)'
                ];
                
                html += `
                    <div style="background: ${gradients[index % 3]}; color: white; border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <div>
                                <div style="font-size: 20px; font-weight: bold;">${parlay.name} Parlay</div>
                                <div style="font-size: 14px; opacity: 0.9;">${parlay.description}</div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 24px; font-weight: bold;">${parlay.totalOdds > 0 ? '+' : ''}${parlay.totalOdds}</div>
                                <div style="font-size: 12px; opacity: 0.9;">${parlay.numLegs}-leg parlay</div>
                            </div>
                        </div>
                        
                        <div style="background: rgba(255,255,255,0.2); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; text-align: center;">
                                <div>
                                    <div style="font-size: 12px; opacity: 0.9;">Avg Edge</div>
                                    <div style="font-size: 18px; font-weight: bold;">${parlay.avgEdge}%</div>
                                </div>
                                <div>
                                    <div style="font-size: 12px; opacity: 0.9;">Avg Hit Rate</div>
                                    <div style="font-size: 18px; font-weight: bold;">${parlay.avgHitRate}%</div>
                                </div>
                                <div>
                                    <div style="font-size: 12px; opacity: 0.9;">Risk Level</div>
                                    <div style="font-size: 18px; font-weight: bold;">${parlay.name}</div>
                                </div>
                            </div>
                        </div>
                        
                        <div style="font-weight: bold; margin-bottom: 10px;">Legs:</div>
                `;
                
                parlay.legs.forEach((leg, legIndex) => {
                    html += `
                        <div style="background: rgba(255,255,255,0.15); padding: 12px; border-radius: 8px; margin-bottom: 8px;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="font-weight: bold;">${legIndex + 1}. ${leg.player}</div>
                                    <div style="font-size: 14px; opacity: 0.9;">
                                        ${leg.bet} ${leg.line} ${leg.prop_type.replace('player_', '').replace('_', ' ')}
                                    </div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="font-weight: bold;">${leg.odds > 0 ? '+' : ''}${leg.odds}</div>
                                    <div style="font-size: 12px; opacity: 0.9;">${leg.confidence} ‚Ä¢ ${leg.edge_percent}% edge</div>
                                </div>
                            </div>
                        </div>
                    `;
                });
                
                html += `
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        function parseGameSearch(search) {
            // Better parser that handles multi-word team names
            // Handles: "Saints vs Titans", "New Orleans vs Tennessee", "NO TEN"
            
            const cleaned = search.toLowerCase().trim();
            
            // Try to split on 'vs', '@', 'at'
            let teams = [];
            
            if (cleaned.includes(' vs ')) {
                teams = cleaned.split(' vs ').map(t => t.trim());
            } else if (cleaned.includes(' v ')) {
                teams = cleaned.split(' v ').map(t => t.trim());
            } else if (cleaned.includes(' @ ')) {
                teams = cleaned.split(' @ ').map(t => t.trim());
            } else if (cleaned.includes(' at ')) {
                teams = cleaned.split(' at ').map(t => t.trim());
            } else {
                // No separator found - try to split smartly
                // Common patterns: "saints titans", "NO TEN" 
                const words = cleaned.split(/\s+/);
                
                if (words.length === 2) {
                    // Two words: assume each is a team
                    teams = words;
                } else if (words.length >= 3) {
                    // Multiple words: take first and last
                    teams = [words[0], words[words.length - 1]];
                } else {
                    teams = words;
                }
            }
            
            return teams.filter(t => t && t.length >= 2);
        }
        
        // Moneyline/Spread Analysis
        function toggleScoringMethod(method) {
            const ppgInputs = document.getElementById('ml-ppg-inputs');
            const totalInputs = document.getElementById('ml-total-inputs');
            
            if (method === 'ppg') {
                ppgInputs.style.display = 'block';
                totalInputs.style.display = 'none';
            } else {
                ppgInputs.style.display = 'none';
                totalInputs.style.display = 'block';
            }
        }
        
        function addGameBetToParlay(betType, team, line, odds, projection, edge, awayTeam = '', homeTeam = '') {
            const sport = window.currentSport || 'nfl';
            
            // Create bet object matching the format expected by parlay builder
            const gameBet = {
                player: team, // Use team name in "player" field
                prop_type: betType, // 'moneyline', 'spread', 'total_over', 'total_under'
                line: line,
                bet: 'YES', // Game bets are always "YES" (we're betting it happens)
                odds: odds,
                adjusted_projection: projection,
                hit_rate: projection !== 'N/A' ? parseFloat(projection) : 50,
                true_edge: edge !== 'N/A' ? parseFloat(edge) : 0,
                bookmaker: 'Manual Entry',
                is_game_bet: true,
                sport: sport,
                // Store team names for totals display
                away_team: awayTeam,
                home_team: homeTeam
            };
            
            // Add to parlay
            currentParlay.push(gameBet);
            localStorage.setItem('currentParlay', JSON.stringify(currentParlay));
            updateParlayDisplay();
            
            // Also add to AI pool
            addToAIPool(gameBet);
            
            // Show success message and switch to parlay tab
            const betDescription = betType === 'moneyline' ? `${team} ML` :
                                  betType === 'spread' ? `${team} ${line > 0 ? '+' : ''}${line}` :
                                  betType === 'total_over' ? `OVER ${line}` :
                                  `UNDER ${line}`;
            
            alert(`‚úÖ Added to parlay!\n\n${betDescription} (${odds > 0 ? '+' : ''}${odds})\n\n‚ú® Also added to AI Parlay Pool for optimal parlay suggestions!\n\nGo to Parlay Builder tab to see your parlay.`);
            showTab('parlay');
        }
        
        function updateGameParlayCalculation() {
            const checkboxes = document.querySelectorAll('#game-parlay-selections input[type="checkbox"]:checked');
            const parlayCalc = document.getElementById('parlay-calculation');
            const legsList = document.getElementById('parlay-legs-list');
            
            if (checkboxes.length === 0) {
                parlayCalc.style.display = 'none';
                return;
            }
            
            parlayCalc.style.display = 'block';
            
            // Build legs list
            let legsHTML = '';
            let combinedOdds = 1;
            let combinedProb = 1;
            const legs = [];
            
            checkboxes.forEach(cb => {
                const team = cb.dataset.team;
                const type = cb.dataset.type;
                const line = cb.dataset.line;
                const odds = parseFloat(cb.dataset.odds);
                const prob = parseFloat(cb.dataset.prob) / 100;
                const edge = cb.dataset.edge;
                
                legs.push({ team, type, line, odds, prob, edge });
                
                // Calculate decimal odds
                const decimalOdds = odds > 0 ? (odds / 100) + 1 : (100 / Math.abs(odds)) + 1;
                combinedOdds *= decimalOdds;
                combinedProb *= prob;
                
                legsHTML += `<div style="font-size: 13px; padding: 5px 0; border-bottom: 1px solid #e5e7eb;">‚Ä¢ ${team} ${line !== 'ML' ? line : ''} (${odds > 0 ? '+' : ''}${odds})</div>`;
            });
            
            legsList.innerHTML = legsHTML;
            
            // Check for correlation warnings
            let correlationWarning = '';
            const types = legs.map(l => l.type);
            const teams = legs.map(l => l.team);
            
            // Check for conflicting bets
            if (types.includes('total_over') && types.includes('total_under')) {
                correlationWarning += '‚ö†Ô∏è WARNING: OVER and UNDER are mutually exclusive!<br>';
            }
            
            // Check for same-team spread + ML
            const awayTeam = teams.find(t => !['OVER', 'UNDER'].includes(t) && legs.find(l => l.team === t && l.line > 0));
            const homeTeam = teams.find(t => !['OVER', 'UNDER'].includes(t) && legs.find(l => l.team === t && (l.line < 0 || l.line === 'ML')));
            
            if (types.filter(t => t === 'moneyline').length > 1) {
                correlationWarning += '‚ö†Ô∏è WARNING: Both moneylines cannot win!<br>';
            }
            
            // Correlation notes
            if (correlationWarning) {
                legsHTML = `<div style="background: #fef3c7; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-size: 12px; color: #92400e;">${correlationWarning}</div>` + legsHTML;
                legsList.innerHTML = legsHTML;
            }
            
            // Convert back to American odds
            const americanOdds = combinedOdds >= 2 ? Math.round((combinedOdds - 1) * 100) : Math.round(-100 / (combinedOdds - 1));
            const payout = americanOdds > 0 ? (100 * (americanOdds / 100)) : (100 / (Math.abs(americanOdds) / 100));
            
            document.getElementById('parlay-odds').textContent = (americanOdds > 0 ? '+' : '') + americanOdds;
            document.getElementById('parlay-payout').textContent = '$' + payout.toFixed(2);
            document.getElementById('parlay-prob').textContent = (combinedProb * 100).toFixed(1) + '%';
            
            // Store for adding to main parlay builder
            window.currentGameParlay = legs;
        }
        
        function addGameParlayToMain() {
            if (!window.currentGameParlay || window.currentGameParlay.length === 0) {
                alert('Please select at least one bet');
                return;
            }
            
            // Add each leg to the main parlay builder
            window.currentGameParlay.forEach(leg => {
                addGameBetToParlay(leg.type, leg.team, leg.line, leg.odds, leg.prob * 100 + '%', leg.edge);
            });
            
            // Clear selections
            document.querySelectorAll('#game-parlay-selections input[type="checkbox"]').forEach(cb => cb.checked = false);
            updateGameParlayCalculation();
            
            alert(`‚úÖ Added ${window.currentGameParlay.length}-leg parlay to Parlay Builder!\n\nGo to Parlay Builder tab to review and place your bet.`);
        }
        
        async function analyzeMoneyline() {
            // Get team names
            const awayTeam = document.getElementById('ml-away-team').value;
            const homeTeam = document.getElementById('ml-home-team').value;
            
            // Get odds
            const awayML = parseInt(document.getElementById('ml-away-odds').value) || 0;
            const homeML = parseInt(document.getElementById('ml-home-odds').value) || 0;
            const awaySpread = parseFloat(document.getElementById('ml-away-spread').value) || 0;
            const awaySpreadOdds = parseInt(document.getElementById('ml-away-spread-odds').value) || -110;
            const homeSpread = parseFloat(document.getElementById('ml-home-spread').value) || 0;
            const homeSpreadOdds = parseInt(document.getElementById('ml-home-spread-odds').value) || -110;
            const totalLine = parseFloat(document.getElementById('ml-total-line').value) || 0;
            const overOdds = parseInt(document.getElementById('ml-over-odds').value) || -110;
            const underOdds = parseInt(document.getElementById('ml-under-odds').value) || -110;
            
            // Get team stats
            const awayWins = parseInt(document.getElementById('ml-away-wins')?.value) || 0;
            const awayLosses = parseInt(document.getElementById('ml-away-losses')?.value) || 0;
            const homeWins = parseInt(document.getElementById('ml-home-wins')?.value) || 0;
            const homeLosses = parseInt(document.getElementById('ml-home-losses')?.value) || 0;
            
            const awayFormWins = parseInt(document.getElementById('ml-away-form-wins')?.value) || 0;
            const awayFormLosses = parseInt(document.getElementById('ml-away-form-losses')?.value) || 0;
            const homeFormWins = parseInt(document.getElementById('ml-home-form-wins')?.value) || 0;
            const homeFormLosses = parseInt(document.getElementById('ml-home-form-losses')?.value) || 0;
            
            // Check which scoring input method is selected
            const scoringMethod = document.querySelector('input[name="ml-scoring-method"]:checked')?.value || 'ppg';
            
            let awayPPG, homePPG, awayPAPG, homePAPG;
            
            if (scoringMethod === 'total') {
                // Calculate PPG from total points
                const gamesPlayed = parseInt(document.getElementById('ml-games-played')?.value) || 17;
                const awayPF = parseInt(document.getElementById('ml-away-pf')?.value) || 0;
                const homePF = parseInt(document.getElementById('ml-home-pf')?.value) || 0;
                const awayPA = parseInt(document.getElementById('ml-away-pa')?.value) || 0;
                const homePA = parseInt(document.getElementById('ml-home-pa')?.value) || 0;
                
                awayPPG = gamesPlayed > 0 ? awayPF / gamesPlayed : 0;
                homePPG = gamesPlayed > 0 ? homePF / gamesPlayed : 0;
                awayPAPG = gamesPlayed > 0 ? awayPA / gamesPlayed : 0;
                homePAPG = gamesPlayed > 0 ? homePA / gamesPlayed : 0;
            } else {
                // Use PPG directly
                awayPPG = parseFloat(document.getElementById('ml-away-ppg')?.value) || 0;
                homePPG = parseFloat(document.getElementById('ml-home-ppg')?.value) || 0;
                awayPAPG = parseFloat(document.getElementById('ml-away-papg')?.value) || 0;
                homePAPG = parseFloat(document.getElementById('ml-home-papg')?.value) || 0;
            }
            
            const awayRest = parseInt(document.getElementById('ml-away-rest')?.value) || 1;
            const homeRest = parseInt(document.getElementById('ml-home-rest')?.value) || 1;
            
            const awayInjuries = document.getElementById('ml-away-injuries')?.value || '';
            const homeInjuries = document.getElementById('ml-home-injuries')?.value || '';
            
            const resultsDiv = document.getElementById('moneyline-results');
            const btn = document.getElementById('ml-analyze-btn');
            const sport = window.currentSport || 'nfl';
            
            if (!awayTeam || !homeTeam) {
                alert('Please enter both team names');
                return;
            }
            
            btn.disabled = true;
            btn.textContent = '‚è≥ Analyzing...';
            
            resultsDiv.innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Calculating win probabilities and projected scores...</p>
                </div>
            `;
            
            try {
                // Calculate win probability
                const hasStats = awayWins > 0 && homeWins > 0 && awayPPG > 0 && homePPG > 0;
                
                let homeWinProb = 0.5;
                let projectedAwayScore = 0;
                let projectedHomeScore = 0;
                let injuryNotes = ''; // Declare here for broader scope
                let spreadImpliedProb = null; // Declare here for broader scope
                
                if (hasStats) {
                    // Team strength from record
                    const awayWinPct = awayWins / (awayWins + awayLosses);
                    const homeWinPct = homeWins / (homeWins + homeLosses);
                    
                    // Recent form
                    const awayFormPct = awayFormWins / (awayFormWins + awayFormLosses || 10);
                    const homeFormPct = homeFormWins / (homeFormWins + homeFormLosses || 10);
                    
                    // Net rating
                    const awayNetRating = awayPPG - awayPAPG;
                    const homeNetRating = homePPG - homePAPG;
                    
                    // Home court advantage
                    const homeAdvantage = sport === 'nba' ? 3.5 : 2.5;
                    
                    // Calculate probability with IMPROVED WEIGHTING
                    homeWinProb = 0.5;
                    
                    // TEAM STRENGTH (50%) - DOUBLED from 30% - Most important factor!
                    // Season record is the best predictor of future performance
                    const recordDiff = (homeWinPct - awayWinPct) * 0.50;
                    homeWinProb += recordDiff;
                    
                    // NET RATING (25%) - Reduced from 30% and capped
                    // Points differential matters but can be misleading
                    const avgPPG = (awayPPG + homePPG) / 2;
                    if (avgPPG > 0) {
                        const ratingDiff = (homeNetRating - awayNetRating) / avgPPG;
                        // CAP the net rating impact at ¬±0.15 to prevent outliers
                        const cappedRatingDiff = Math.max(-0.15, Math.min(0.15, ratingDiff * 0.25));
                        homeWinProb += cappedRatingDiff;
                    }
                    
                    // RECENT FORM (10%) - HALVED from 20% - Less predictive than season record
                    // Recent games are noisy, small sample size
                    const formDiff = (homeFormPct - awayFormPct) * 0.10;
                    homeWinProb += formDiff;
                    
                    // HOME COURT (10%) - Reduced for bad teams
                    // Bad teams don't benefit as much from home court
                    let homeCourtBonus = 0.05;
                    // If home team has losing record, reduce home court advantage by 50%
                    if (homeWinPct < 0.45) {
                        homeCourtBonus *= 0.5;
                    }
                    homeWinProb += homeCourtBonus;
                    
                    // REST ADVANTAGE (5%) - Reduced from 10%
                    // Rest matters but not as much as team quality
                    // REST ADVANTAGE (5%) - Reduced from 10%
                    // Rest matters but not as much as team quality
                    if (homeRest > awayRest + 1) {
                        homeWinProb += 0.025;
                    } else if (awayRest > homeRest + 1) {
                        homeWinProb -= 0.025;
                    }
                    
                    // Clamp probability to reasonable range (5% to 95%)
                    // Never say a team has 0% or 100% chance - upsets happen!
                    homeWinProb = Math.max(0.05, Math.min(0.95, homeWinProb));
                    
                    // SPREAD-BASED PROBABILITY VALIDATION (if spread exists)
                    // The spread is Vegas' best estimate - use it as a sanity check!
                    if (awaySpread !== 0 || homeSpread !== 0) {
                        // Convert spread to win probability
                        // Formula: Every point of spread ‚âà 2.5% win probability
                        // Example: Away -10 means away team favored by 10 ‚Üí ~75% away win prob
                        const spread = awaySpread; // Negative if away team favored
                        const spreadPoints = Math.abs(spread);
                        const spreadImpactPct = spreadPoints * 0.025; // 2.5% per point
                        
                        // Calculate HOME team win probability from spread
                        if (spread < 0) {
                            // Away team favored (e.g., Spurs -4)
                            // Home team is underdog, gets fewer win %
                            spreadImpliedProb = 0.50 - spreadImpactPct; // Home team underdog
                        } else if (spread > 0) {
                            // Home team favored (e.g., Hornets -4 would show as Spurs +4)
                            // Home team gets more win %
                            spreadImpliedProb = 0.50 + spreadImpactPct; // Home team favorite
                        }
                        
                        // Clamp spread-implied probability
                        spreadImpliedProb = Math.max(0.05, Math.min(0.95, spreadImpliedProb));
                        
                        // CROSS-CHECK: If our calculation differs significantly from spread-implied,
                        // blend them together with spread getting 60% weight
                        // (Vegas knows more than we do - trust the spread!)
                        if (Math.abs(homeWinProb - spreadImpliedProb) > 0.10) {
                            // More than 10% difference - blend them
                            // 40% our calculation, 60% spread-implied
                            homeWinProb = (homeWinProb * 0.40) + (spreadImpliedProb * 0.60);
                            homeWinProb = Math.max(0.05, Math.min(0.95, homeWinProb));
                        }
                    }
                    
                    // Injury Impact Analysis
                    let awayInjuryImpact = 0;
                    let homeInjuryImpact = 0;
                    let awayPPGAdjusted = awayPPG;
                    let homePPGAdjusted = homePPG;
                    
                    // Analyze away team injuries
                    if (awayInjuries && awayInjuries.toLowerCase().includes('out')) {
                        const injuryText = awayInjuries.toLowerCase();
                        
                        // QB out = massive impact
                        if (injuryText.includes('qb') || injuryText.includes('quarterback')) {
                            awayInjuryImpact = sport === 'nfl' ? 0.15 : 0.10; // 15% for NFL, 10% for NBA
                            awayPPGAdjusted = awayPPG * 0.75; // 25% reduction in scoring
                            injuryNotes += `‚ö†Ô∏è ${awayTeam} starting QB OUT - Major impact (-25% offense, -15% win prob)\n`;
                        }
                        // RB/WR out = moderate impact (NFL)
                        else if (sport === 'nfl' && (injuryText.includes('rb') || injuryText.includes('wr') || injuryText.includes('running back') || injuryText.includes('wide receiver'))) {
                            awayInjuryImpact = 0.05;
                            awayPPGAdjusted = awayPPG * 0.90; // 10% reduction
                            injuryNotes += `‚ö†Ô∏è ${awayTeam} key skill player OUT - Moderate impact (-10% offense, -5% win prob)\n`;
                        }
                        // Star player out (NBA)
                        else if (sport === 'nba' && (injuryText.includes('ppg') || injuryText.includes('points'))) {
                            // Try to extract PPG from injury text (e.g., "LeBron James OUT - 25 PPG")
                            const ppgMatch = injuryText.match(/(\d+)\s*ppg/);
                            if (ppgMatch) {
                                const playerPPG = parseInt(ppgMatch[1]);
                                awayPPGAdjusted = awayPPG - playerPPG;
                                awayInjuryImpact = playerPPG / awayPPG * 0.30; // Impact proportional to scoring
                                injuryNotes += `‚ö†Ô∏è ${awayTeam} star player OUT (${playerPPG} PPG) - Major impact (-${playerPPG} pts, -${(awayInjuryImpact * 100).toFixed(1)}% win prob)\n`;
                            } else {
                                awayInjuryImpact = 0.08;
                                awayPPGAdjusted = awayPPG * 0.88;
                                injuryNotes += `‚ö†Ô∏è ${awayTeam} key player OUT - Moderate impact (-12% offense, -8% win prob)\n`;
                            }
                        }
                        // Generic OUT player
                        else if (injuryText.includes('out')) {
                            awayInjuryImpact = 0.03;
                            awayPPGAdjusted = awayPPG * 0.95;
                            injuryNotes += `‚ö†Ô∏è ${awayTeam} player OUT - Minor impact (-5% offense, -3% win prob)\n`;
                        }
                    }
                    
                    // Analyze home team injuries
                    if (homeInjuries && homeInjuries.toLowerCase().includes('out')) {
                        const injuryText = homeInjuries.toLowerCase();
                        
                        // QB out = massive impact
                        if (injuryText.includes('qb') || injuryText.includes('quarterback')) {
                            homeInjuryImpact = sport === 'nfl' ? 0.15 : 0.10;
                            homePPGAdjusted = homePPG * 0.75;
                            injuryNotes += `‚ö†Ô∏è ${homeTeam} starting QB OUT - Major impact (-25% offense, -15% win prob)\n`;
                        }
                        // RB/WR out = moderate impact (NFL)
                        else if (sport === 'nfl' && (injuryText.includes('rb') || injuryText.includes('wr') || injuryText.includes('running back') || injuryText.includes('wide receiver'))) {
                            homeInjuryImpact = 0.05;
                            homePPGAdjusted = homePPG * 0.90;
                            injuryNotes += `‚ö†Ô∏è ${homeTeam} key skill player OUT - Moderate impact (-10% offense, -5% win prob)\n`;
                        }
                        // Star player out (NBA)
                        else if (sport === 'nba' && (injuryText.includes('ppg') || injuryText.includes('points'))) {
                            const ppgMatch = injuryText.match(/(\d+)\s*ppg/);
                            if (ppgMatch) {
                                const playerPPG = parseInt(ppgMatch[1]);
                                homePPGAdjusted = homePPG - playerPPG;
                                homeInjuryImpact = playerPPG / homePPG * 0.30;
                                injuryNotes += `‚ö†Ô∏è ${homeTeam} star player OUT (${playerPPG} PPG) - Major impact (-${playerPPG} pts, -${(homeInjuryImpact * 100).toFixed(1)}% win prob)\n`;
                            } else {
                                homeInjuryImpact = 0.08;
                                homePPGAdjusted = homePPG * 0.88;
                                injuryNotes += `‚ö†Ô∏è ${homeTeam} key player OUT - Moderate impact (-12% offense, -8% win prob)\n`;
                            }
                        }
                        // Generic OUT player
                        else if (injuryText.includes('out')) {
                            homeInjuryImpact = 0.03;
                            homePPGAdjusted = homePPG * 0.95;
                            injuryNotes += `‚ö†Ô∏è ${homeTeam} player OUT - Minor impact (-5% offense, -3% win prob)\n`;
                        }
                    }
                    
                    // Apply injury adjustments to win probability
                    homeWinProb += awayInjuryImpact; // Away injuries HELP home (increase home win prob)
                    homeWinProb -= homeInjuryImpact; // Home injuries HURT home (decrease home win prob)
                    
                    // Bound probability
                    homeWinProb = Math.max(0.20, Math.min(0.80, homeWinProb));
                    
                    // Project scores with injury-adjusted PPG
                    projectedAwayScore = (awayPPGAdjusted + homePAPG) / 2;
                    projectedHomeScore = (homePPGAdjusted + awayPAPG) / 2 + (homeAdvantage / 2);
                    
                } else {
                    homeWinProb = 0.5;
                }
                
                const awayWinProb = 1 - homeWinProb;
                
                // Calculate implied probabilities from odds
                const awayMLProb = awayML < 0 ? Math.abs(awayML) / (Math.abs(awayML) + 100) : 100 / (awayML + 100);
                const homeMLProb = homeML < 0 ? Math.abs(homeML) / (Math.abs(homeML) + 100) : 100 / (homeML + 100);
                const awaySpreadProb = awaySpreadOdds < 0 ? Math.abs(awaySpreadOdds) / (Math.abs(awaySpreadOdds) + 100) : 100 / (awaySpreadOdds + 100);
                const homeSpreadProb = homeSpreadOdds < 0 ? Math.abs(homeSpreadOdds) / (Math.abs(homeSpreadOdds) + 100) : 100 / (homeSpreadOdds + 100);
                const overProb = overOdds < 0 ? Math.abs(overOdds) / (Math.abs(overOdds) + 100) : 100 / (overOdds + 100);
                const underProb = underOdds < 0 ? Math.abs(underOdds) / (Math.abs(underOdds) + 100) : 100 / (underOdds + 100);
                
                // Calculate edges
                const awayMLEdge = hasStats ? ((awayWinProb - awayMLProb) * 100).toFixed(1) : 'N/A';
                const homeMLEdge = hasStats ? ((homeWinProb - homeMLProb) * 100).toFixed(1) : 'N/A';
                
                // Projected margin
                const projectedMargin = hasStats ? (projectedHomeScore - projectedAwayScore).toFixed(1) : 'N/A';
                const projectedTotal = hasStats ? (projectedHomeScore + projectedAwayScore).toFixed(1) : 'N/A';
                
                // Sanity check: Don't recommend betting on projected loser unless edge is VERY strong
                // If Patriots projected to win by 4+, don't recommend Broncos ML even with small edge
                let awayMLAdjustedEdge = awayMLEdge;
                let homeMLAdjustedEdge = homeMLEdge;
                
                if (hasStats && Math.abs(projectedMargin) > 3) {
                    // If projected margin > 3 points, suppress opposite team unless edge > 5%
                    if (projectedMargin < -3 && parseFloat(homeMLEdge) < 5) {
                        // Away team projected to win big, don't recommend home ML
                        homeMLAdjustedEdge = -99; // Force to not show button
                    } else if (projectedMargin > 3 && parseFloat(awayMLEdge) < 5) {
                        // Home team projected to win big, don't recommend away ML
                        awayMLAdjustedEdge = -99; // Force to not show button
                    }
                }
                
                // Spread edge (if we have projections)
                let awaySpreadEdge = 'N/A';
                let homeSpreadEdge = 'N/A';
                if (hasStats && awaySpread !== 0) {
                    // Spread covering logic (clearer approach):
                    // 
                    // projectedMargin: positive = home wins by that much
                    //                  negative = away wins by that much
                    // Example: +5 = home wins by 5, -5 = away wins by 5
                    //
                    // awaySpread: what the away team is getting
                    // Example: -3 = away is 3-point favorite (needs to win by 4+)
                    //          +3 = away is 3-point underdog (loses by less than 3 or wins)
                    //
                    // Away team COVERS if:
                    // (awayActualMargin - awaySpread) > 0
                    //
                    // Where awayActualMargin = -projectedMargin (flip sign)
                    
                    // Example 1: Cavs -3, projected Hornets +0.8
                    // projectedMargin = +0.8 (Hornets win by 0.8)
                    // awayActualMargin = -0.8 (Cavs lose by 0.8)
                    // awaySpread = -3
                    // coverMargin = -0.8 - (-3) = +2.2
                    // Positive means... wait no.
                    //
                    // Let's think differently:
                    // Cavs -3 means Cavs win by 4+ to cover
                    // Projected: Cavs lose by 0.8
                    // Cavs are -3.8 points away from covering (-0.8 actual vs -3 spread = -3.8 difference)
                    // So Cavs DON'T cover
                    
                    // Clearest way: 
                    // awayNetResult = awayActualMargin + awaySpread
                    // If awayNetResult > 0, away covers
                    
                    const awayActualMargin = -projectedMargin;  // Negative if away loses
                    const awayNetResult = awayActualMargin + awaySpread;
                    
                    // Example: Cavs projected -0.8, spread -3
                    // awayNetResult = -0.8 + (-3) = -3.8 (negative = doesn't cover)
                    
                    // Example 2: Cavs projected +4, spread -3
                    // awayNetResult = 4 + (-3) = +1 (positive = covers!)
                    
                    let awayCoversProb;
                    if (awayNetResult > 2) {
                        awayCoversProb = 0.70;  // Strongly favors away covering
                    } else if (awayNetResult > 0.5) {
                        awayCoversProb = 0.60;  // Moderately favors away covering
                    } else if (awayNetResult > -0.5) {
                        awayCoversProb = 0.50;  // Toss-up
                    } else if (awayNetResult > -2) {
                        awayCoversProb = 0.40;  // Moderately favors home covering
                    } else {
                        awayCoversProb = 0.30;  // Strongly favors home covering
                    }
                    
                    awaySpreadEdge = ((awayCoversProb - awaySpreadProb) * 100).toFixed(1);
                    homeSpreadEdge = ((1 - awayCoversProb - homeSpreadProb) * 100).toFixed(1);
                }
                
                // Total edge
                let overEdge = 'N/A';
                let underEdge = 'N/A';
                if (hasStats && totalLine > 0) {
                    const overProb = parseFloat(projectedTotal) > totalLine ? 0.60 : 0.40;
                    overEdge = ((overProb - (overOdds < 0 ? Math.abs(overOdds) / (Math.abs(overOdds) + 100) : 100 / (overOdds + 100))) * 100).toFixed(1);
                    underEdge = ((1 - overProb - (underOdds < 0 ? Math.abs(underOdds) / (Math.abs(underOdds) + 100) : 100 / (underOdds + 100))) * 100).toFixed(1);
                }
                
                // Build results HTML
                let html = `
                    <div style="background: white; border-radius: 12px; padding: 25px; margin-top: 20px;">
                        <h3 style="margin: 0 0 20px 0; color: #1e40af; font-size: 20px; border-bottom: 2px solid #e5e7eb; padding-bottom: 10px;">
                            üìä ${awayTeam} @ ${homeTeam} - Analysis
                        </h3>
`;
                
                if (!hasStats) {
                    html += `
                        <div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 15px; border-radius: 6px; margin-bottom: 20px;">
                            <p style="margin: 0; color: #92400e; font-size: 14px;">
                                ‚ö†Ô∏è <strong>Limited Analysis:</strong> Enter team stats (records, PPG, etc.) above for detailed win probability and score projections.
                            </p>
                        </div>
                    `;
                }
                
                // Win Probability Section
                if (hasStats) {
                    html += `
                        <div style="background: #f0f9ff; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <h4 style="margin: 0 0 10px 0; color: #0369a1;">üìà Win Probability</h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                <div>
                                    <div style="font-size: 13px; color: #666; margin-bottom: 5px;">${awayTeam}</div>
                                    <div style="font-size: 24px; font-weight: 600; color: #dc2626;">${(awayWinProb * 100).toFixed(1)}%</div>
                                </div>
                                <div>
                                    <div style="font-size: 13px; color: #666; margin-bottom: 5px;">${homeTeam}</div>
                                    <div style="font-size: 24px; font-weight: 600; color: #16a34a;">${(homeWinProb * 100).toFixed(1)}%</div>
                                </div>
                            </div>
                            ${spreadImpliedProb !== null ? `
                                <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #bae6fd; font-size: 12px; color: #0369a1;">
                                    ‚úì Validated against ${Math.abs(awaySpread)}-point spread (spread implies ${(spreadImpliedProb * 100).toFixed(0)}% ${homeTeam}, ${((1-spreadImpliedProb) * 100).toFixed(0)}% ${awayTeam} win probability)
                                </div>
                            ` : ''}
                        </div>
                        
                        ${injuryNotes ? `
                        <div style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <h4 style="margin: 0 0 10px 0; color: #92400e;">üè• Injury Impact Analysis</h4>
                            <div style="font-size: 13px; color: #78350f; line-height: 1.8; white-space: pre-line;">
                                ${injuryNotes}
                            </div>
                            <div style="font-size: 12px; color: #92400e; margin-top: 10px; font-style: italic;">
                                ‚ÑπÔ∏è Projections and win probability have been adjusted to account for these injuries.
                            </div>
                        </div>
                        ` : ''}
                        
                        <div style="background: #f0fdf4; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <h4 style="margin: 0 0 10px 0; color: #15803d;">üéØ Projected Score</h4>
                            <div style="font-size: 20px; font-weight: 600; text-align: center; color: #333;">
                                ${awayTeam} ${projectedAwayScore.toFixed(1)} - ${projectedHomeScore.toFixed(1)} ${homeTeam}
                            </div>
                            <div style="font-size: 14px; text-align: center; color: #666; margin-top: 5px;">
                                Projected Margin: ${projectedMargin >= 0 ? `${homeTeam} -${Math.abs(projectedMargin)}` : `${awayTeam} -${Math.abs(projectedMargin)}`}
                            </div>
                            <div style="font-size: 14px; text-align: center; color: #666; margin-top: 3px;">
                                Projected Total: ${projectedTotal} points
                            </div>
                        </div>
                    `;
                }
                
                // Moneyline Analysis
                if (awayML !== 0 || homeML !== 0) {
                    html += `
                        <div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <h4 style="margin: 0 0 15px 0; color: #92400e;">üí∞ Moneyline Analysis</h4>
                `;
                    
                    if (awayML !== 0) {
                        const awayEdgeNum = parseFloat(awayMLEdge);
                        const awayWinPct = awayWinProb * 100;
                        const awayStars = awayEdgeNum > 10 ? '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê' : awayEdgeNum > 7 ? '‚≠ê‚≠ê‚≠ê‚≠ê' : awayEdgeNum > 4 ? '‚≠ê‚≠ê‚≠ê' : awayEdgeNum > 2 ? '‚≠ê‚≠ê' : '‚≠ê';
                        
                        // CRITICAL: Don't recommend if win probability < 40% (likely to lose!)
                        // Even with positive edge, low win% = too risky
                        let awayRec, awayExplanation;
                        if (awayWinPct < 40) {
                            // Low win probability - don't recommend even with edge
                            awayRec = 'AVOID ‚ùå';
                            awayExplanation = `Low win probability (${awayWinPct.toFixed(1)}%) - too risky even with ${awayEdgeNum > 0 ? 'positive' : 'negative'} edge`;
                        } else if (awayEdgeNum > 5) {
                            awayRec = 'STRONG BET ‚úÖ';
                            awayExplanation = 'Good value - odds underpricing win chance';
                        } else if (awayEdgeNum > 2) {
                            awayRec = 'BET ‚úÖ';
                            awayExplanation = 'Good value - odds underpricing win chance';
                        } else if (awayEdgeNum > 0) {
                            awayRec = 'SLIGHT VALUE ‚ö†Ô∏è';
                            awayExplanation = 'Slight value - small edge';
                        } else {
                            awayRec = 'AVOID ‚ùå';
                            awayExplanation = 'Overpriced - odds too high for actual win chance';
                        }
                        html += `
                            <div style="background: white; padding: 12px; border-radius: 6px; margin-bottom: 10px; border-left: 4px solid ${awayEdgeNum > 2 ? '#16a34a' : awayEdgeNum > 0 ? '#f59e0b' : '#dc2626'};">
                                <div style="font-weight: 600; margin-bottom: 5px;">${awayTeam} ${awayML > 0 ? '+' : ''}${awayML}</div>
                                <div style="font-size: 13px; color: #666;">Implied Probability: ${(awayMLProb * 100).toFixed(1)}%</div>
                                ${hasStats ? `<div style="font-size: 13px; color: #666;">True Probability: ${(awayWinProb * 100).toFixed(1)}%</div>` : ''}
                                ${hasStats ? `<div style="font-size: 13px; font-weight: 600; color: ${awayEdgeNum > 0 ? '#16a34a' : '#dc2626'};">Edge: ${awayMLEdge > 0 ? '+' : ''}${awayMLEdge}%</div>` : ''}
                                ${hasStats ? `<div style="font-size: 12px; color: #666; font-style: italic; margin-top: 3px;">${awayExplanation}</div>` : ''}
                                ${hasStats ? `<div style="font-size: 13px; margin-top: 5px;">${awayStars} ${awayRec}</div>` : ''}
                                ${hasStats && parseFloat(awayMLAdjustedEdge) > 2 ? `
                                    <button onclick="addGameBetToParlay('moneyline', '${awayTeam}', 'ML', ${awayML}, '${(awayWinProb * 100).toFixed(1)}%', ${awayMLEdge})" 
                                        style="margin-top: 10px; padding: 8px 16px; background: #8b5cf6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600; width: 100%;"
                                        onmouseover="this.style.background='#7c3aed'" 
                                        onmouseout="this.style.background='#8b5cf6'">
                                        ‚ûï Add ${awayTeam} ML to Parlay
                                    </button>
                                ` : ''}
                            </div>
                        `;
                    }
                    
                    if (homeML !== 0) {
                        const homeEdgeNum = parseFloat(homeMLEdge);
                        const homeWinPct = homeWinProb * 100;
                        const homeStars = homeEdgeNum > 10 ? '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê' : homeEdgeNum > 7 ? '‚≠ê‚≠ê‚≠ê‚≠ê' : homeEdgeNum > 4 ? '‚≠ê‚≠ê‚≠ê' : homeEdgeNum > 2 ? '‚≠ê‚≠ê' : '‚≠ê';
                        
                        // CRITICAL: Don't recommend if win probability < 40% (likely to lose!)
                        // Even with positive edge, low win% = too risky
                        let homeRec, homeExplanation;
                        if (homeWinPct < 40) {
                            // Low win probability - don't recommend even with edge
                            homeRec = 'AVOID ‚ùå';
                            homeExplanation = `Low win probability (${homeWinPct.toFixed(1)}%) - too risky even with ${homeEdgeNum > 0 ? 'positive' : 'negative'} edge`;
                        } else if (homeEdgeNum > 5) {
                            homeRec = 'STRONG BET ‚úÖ';
                            homeExplanation = 'Good value - odds underpricing win chance';
                        } else if (homeEdgeNum > 2) {
                            homeRec = 'BET ‚úÖ';
                            homeExplanation = 'Good value - odds underpricing win chance';
                        } else if (homeEdgeNum > 0) {
                            homeRec = 'SLIGHT VALUE ‚ö†Ô∏è';
                            homeExplanation = 'Slight value - small edge';
                        } else {
                            homeRec = 'AVOID ‚ùå';
                            homeExplanation = 'Overpriced - odds too high for actual win chance';
                        }
                        html += `
                            <div style="background: white; padding: 12px; border-radius: 6px; border-left: 4px solid ${homeEdgeNum > 2 ? '#16a34a' : homeEdgeNum > 0 ? '#f59e0b' : '#dc2626'};">
                                <div style="font-weight: 600; margin-bottom: 5px;">${homeTeam} ${homeML > 0 ? '+' : ''}${homeML}</div>
                                <div style="font-size: 13px; color: #666;">Implied Probability: ${(homeMLProb * 100).toFixed(1)}%</div>
                                ${hasStats ? `<div style="font-size: 13px; color: #666;">True Probability: ${(homeWinProb * 100).toFixed(1)}%</div>` : ''}
                                ${hasStats ? `<div style="font-size: 13px; font-weight: 600; color: ${homeEdgeNum > 0 ? '#16a34a' : '#dc2626'};">Edge: ${homeMLEdge > 0 ? '+' : ''}${homeMLEdge}%</div>` : ''}
                                ${hasStats ? `<div style="font-size: 12px; color: #666; font-style: italic; margin-top: 3px;">${homeExplanation}</div>` : ''}
                                ${hasStats ? `<div style="font-size: 13px; margin-top: 5px;">${homeStars} ${homeRec}</div>` : ''}
                                ${hasStats && parseFloat(homeMLAdjustedEdge) > 2 ? `
                                    <button onclick="addGameBetToParlay('moneyline', '${homeTeam}', 'ML', ${homeML}, '${(homeWinProb * 100).toFixed(1)}%', ${homeMLEdge})" 
                                        style="margin-top: 10px; padding: 8px 16px; background: #8b5cf6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600; width: 100%;"
                                        onmouseover="this.style.background='#7c3aed'" 
                                        onmouseout="this.style.background='#8b5cf6'">
                                        ‚ûï Add ${homeTeam} ML to Parlay
                                    </button>
                                ` : ''}
                            </div>
                        `;
                    }
                    
                    html += `</div>`;
                }
                
                // Spread Analysis
                if (awaySpread !== 0 || homeSpread !== 0) {
                    html += `
                        <div style="background: #ede9fe; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <h4 style="margin: 0 0 15px 0; color: #6b21a8;">üìä Spread Analysis</h4>
                            ${hasStats ? `<div style="font-size: 13px; color: #666; margin-bottom: 10px;">Projected Margin: ${projectedMargin >= 0 ? `${homeTeam} -${Math.abs(projectedMargin)}` : `${awayTeam} -${Math.abs(projectedMargin)}`}</div>` : ''}
                `;
                    
                    if (awaySpread !== 0) {
                        const spreadEdgeNum = parseFloat(awaySpreadEdge);
                        const spreadRec = spreadEdgeNum > 5 ? 'STRONG BET ‚úÖ' : spreadEdgeNum > 2 ? 'BET ‚úÖ' : spreadEdgeNum > 0 ? 'SLIGHT VALUE ‚ö†Ô∏è' : 'AVOID ‚ùå';
                        const projectedAwayMargin = -projectedMargin;
                        const awayCoversProb = projectedAwayMargin > awaySpread ? 55 : 45; // Simplified for display
                        html += `
                            <div style="background: white; padding: 12px; border-radius: 6px; margin-bottom: 10px; border-left: 4px solid ${spreadEdgeNum > 2 ? '#16a34a' : spreadEdgeNum > 0 ? '#f59e0b' : '#dc2626'};">
                                <div style="font-weight: 600; margin-bottom: 5px;">${awayTeam} ${awaySpread > 0 ? '+' : ''}${awaySpread} (${awaySpreadOdds})</div>
                                ${hasStats && awaySpreadEdge !== 'N/A' ? `<div style="font-size: 13px; font-weight: 600; color: ${spreadEdgeNum > 0 ? '#16a34a' : '#dc2626'};">Edge: ${awaySpreadEdge > 0 ? '+' : ''}${awaySpreadEdge}%</div>` : ''}
                                ${hasStats && awaySpreadEdge !== 'N/A' ? `<div style="font-size: 13px; margin-top: 5px;">${spreadRec}</div>` : ''}
                                ${hasStats && awaySpreadEdge !== 'N/A' && spreadEdgeNum > 2 ? `
                                    <button onclick="addGameBetToParlay('spread', '${awayTeam}', ${awaySpread}, ${awaySpreadOdds}, '${awayCoversProb}%', ${awaySpreadEdge})" 
                                        style="margin-top: 10px; padding: 8px 16px; background: #8b5cf6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600; width: 100%;"
                                        onmouseover="this.style.background='#7c3aed'" 
                                        onmouseout="this.style.background='#8b5cf6'">
                                        ‚ûï Add ${awayTeam} ${awaySpread > 0 ? '+' : ''}${awaySpread} to Parlay
                                    </button>
                                ` : ''}
                            </div>
                        `;
                    }
                    
                    if (homeSpread !== 0) {
                        const homeSpreadEdgeNum = parseFloat(homeSpreadEdge);
                        const homeSpreadRec = homeSpreadEdgeNum > 5 ? 'STRONG BET ‚úÖ' : homeSpreadEdgeNum > 2 ? 'BET ‚úÖ' : homeSpreadEdgeNum > 0 ? 'SLIGHT VALUE ‚ö†Ô∏è' : 'AVOID ‚ùå';
                        const homeCoversProb = projectedMargin > homeSpread ? 55 : 45; // Home covers if actual margin > spread
                        html += `
                            <div style="background: white; padding: 12px; border-radius: 6px; margin-bottom: 10px; border-left: 4px solid ${homeSpreadEdgeNum > 2 ? '#16a34a' : homeSpreadEdgeNum > 0 ? '#f59e0b' : '#dc2626'};">
                                <div style="font-weight: 600; margin-bottom: 5px;">${homeTeam} ${homeSpread > 0 ? '+' : ''}${homeSpread} (${homeSpreadOdds})</div>
                                ${hasStats && homeSpreadEdge !== 'N/A' ? `<div style="font-size: 13px; font-weight: 600; color: ${homeSpreadEdgeNum > 0 ? '#16a34a' : '#dc2626'};">Edge: ${homeSpreadEdge > 0 ? '+' : ''}${homeSpreadEdge}%</div>` : ''}
                                ${hasStats && homeSpreadEdge !== 'N/A' ? `<div style="font-size: 13px; margin-top: 5px;">${homeSpreadRec}</div>` : ''}
                                ${hasStats && homeSpreadEdge !== 'N/A' && homeSpreadEdgeNum > 2 ? `
                                    <button onclick="addGameBetToParlay('spread', '${homeTeam}', ${homeSpread}, ${homeSpreadOdds}, '${homeCoversProb}%', ${homeSpreadEdge})" 
                                        style="margin-top: 10px; padding: 8px 16px; background: #8b5cf6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px; font-weight: 600; width: 100%;"
                                        onmouseover="this.style.background='#7c3aed'" 
                                        onmouseout="this.style.background='#8b5cf6'">
                                        ‚ûï Add ${homeTeam} ${homeSpread > 0 ? '+' : ''}${homeSpread} to Parlay
                                    </button>
                                ` : ''}
                            </div>
                        `;
                    }
                    
                    html += `</div>`;
                }
                
                // Total Analysis  
                if (totalLine > 0) {
                    html += `
                        <div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <h4 style="margin: 0 0 15px 0; color: #92400e;">üéØ Over/Under Analysis</h4>
                            <div style="font-size: 13px; color: #666; margin-bottom: 10px;">Line: ${totalLine} points</div>
                            ${hasStats ? `<div style="font-size: 13px; color: #666; margin-bottom: 10px;">Projected Total: ${projectedTotal} points</div>` : ''}
                            
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <div style="background: white; padding: 12px; border-radius: 6px;">
                                    <div style="font-weight: 600; margin-bottom: 5px;">OVER ${totalLine} (${overOdds})</div>
                                    ${hasStats && overEdge !== 'N/A' ? `<div style="font-size: 13px; font-weight: 600; color: ${parseFloat(overEdge) > 0 ? '#16a34a' : '#dc2626'};">Edge: ${parseFloat(overEdge) > 0 ? '+' : ''}${overEdge}%</div>` : ''}
                                    ${hasStats && overEdge !== 'N/A' ? `<div style="font-size: 13px; margin-top: 5px;">${parseFloat(overEdge) > 2 ? 'BET ‚úÖ' : parseFloat(overEdge) > 0 ? 'SLIGHT VALUE ‚ö†Ô∏è' : 'AVOID ‚ùå'}</div>` : ''}
                                    ${hasStats && overEdge !== 'N/A' && parseFloat(overEdge) > 2 ? `
                                        <button onclick="addGameBetToParlay('total_over', 'OVER', ${totalLine}, ${overOdds}, '${parseFloat(projectedTotal) > totalLine ? 60 : 40}%', ${overEdge}, '${awayTeam}', '${homeTeam}')" 
                                            style="margin-top: 10px; padding: 6px 12px; background: #8b5cf6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600; width: 100%;"
                                            onmouseover="this.style.background='#7c3aed'" 
                                            onmouseout="this.style.background='#8b5cf6'">
                                            ‚ûï Add to Parlay
                                        </button>
                                    ` : ''}
                                </div>
                                <div style="background: white; padding: 12px; border-radius: 6px;">
                                    <div style="font-weight: 600; margin-bottom: 5px;">UNDER ${totalLine} (${underOdds})</div>
                                    ${hasStats && underEdge !== 'N/A' ? `<div style="font-size: 13px; font-weight: 600; color: ${parseFloat(underEdge) > 0 ? '#16a34a' : '#dc2626'};">Edge: ${parseFloat(underEdge) > 0 ? '+' : ''}${underEdge}%</div>` : ''}
                                    ${hasStats && underEdge !== 'N/A' ? `<div style="font-size: 13px; margin-top: 5px;">${parseFloat(underEdge) > 2 ? 'BET ‚úÖ' : parseFloat(underEdge) > 0 ? 'SLIGHT VALUE ‚ö†Ô∏è' : 'AVOID ‚ùå'}</div>` : ''}
                                    ${hasStats && underEdge !== 'N/A' && parseFloat(underEdge) > 2 ? `
                                        <button onclick="addGameBetToParlay('total_under', 'UNDER', ${totalLine}, ${underOdds}, '${parseFloat(projectedTotal) < totalLine ? 60 : 40}%', ${underEdge}, '${awayTeam}', '${homeTeam}')" 
                                            style="margin-top: 10px; padding: 6px 12px; background: #8b5cf6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600; width: 100%;"
                                            onmouseover="this.style.background='#7c3aed'" 
                                            onmouseout="this.style.background='#8b5cf6'">
                                            ‚ûï Add to Parlay
                                        </button>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    `;
                }
                
                // Best Bets Summary with IMPROVED FILTERING
                if (hasStats) {
                    const bestBets = [];
                    
                    // CRITICAL: Don't recommend moneylines with <30% win probability
                    // Even if "edge" looks good, low win% = value trap!
                    const awayWinProbPct = awayWinProb * 100;
                    const homeWinProbPct = homeWinProb * 100;
                    
                    // Away ML - only recommend if >30% win prob AND positive edge
                    if (parseFloat(awayMLAdjustedEdge) > 2 && awayWinProbPct > 30) {
                        bestBets.push({ 
                            name: `${awayTeam} ML ${awayML}`, 
                            edge: parseFloat(awayMLEdge), 
                            type: 'moneyline',
                            winProb: awayWinProbPct 
                        });
                    }
                    
                    // Home ML - only recommend if >30% win prob AND positive edge
                    if (parseFloat(homeMLAdjustedEdge) > 2 && homeWinProbPct > 30) {
                        bestBets.push({ 
                            name: `${homeTeam} ML ${homeML}`, 
                            edge: parseFloat(homeMLEdge), 
                            type: 'moneyline',
                            winProb: homeWinProbPct 
                        });
                    }
                    
                    if (awaySpreadEdge !== 'N/A' && parseFloat(awaySpreadEdge) > 2) {
                        bestBets.push({ name: `${awayTeam} ${awaySpread > 0 ? '+' : ''}${awaySpread}`, edge: parseFloat(awaySpreadEdge), type: 'spread' });
                    }
                    if (overEdge !== 'N/A' && parseFloat(overEdge) > 2) {
                        bestBets.push({ name: `OVER ${totalLine}`, edge: parseFloat(overEdge), type: 'total_over' });
                    }
                    if (underEdge !== 'N/A' && parseFloat(underEdge) > 2) {
                        bestBets.push({ name: `UNDER ${totalLine}`, edge: parseFloat(underEdge), type: 'total_under' });
                    }
                    
                    if (bestBets.length > 0) {
                        bestBets.sort((a, b) => b.edge - a.edge);
                        
                        html += `
                            <div style="background: #d1fae5; border-left: 4px solid #10b981; padding: 15px; border-radius: 8px;">
                                <h4 style="margin: 0 0 10px 0; color: #065f46;">üí° Best Bets</h4>
                        `;
                        
                        bestBets.forEach((bet, index) => {
                            const stars = bet.edge > 10 ? '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê' : bet.edge > 7 ? '‚≠ê‚≠ê‚≠ê‚≠ê' : bet.edge > 4 ? '‚≠ê‚≠ê‚≠ê' : '‚≠ê‚≠ê';
                            
                            // Add warning for moneylines with low win probability
                            let warning = '';
                            if (bet.type === 'moneyline' && bet.winProb < 45) {
                                warning = `<div style="font-size: 11px; color: #f59e0b; margin-top: 4px;">‚ö†Ô∏è Underdog bet (${bet.winProb.toFixed(0)}% win prob) - Only for small unit sizes</div>`;
                            }
                            
                            html += `
                                <div style="background: white; padding: 10px; border-radius: 6px; margin-bottom: ${index < bestBets.length - 1 ? '10px' : '0'};">
                                    <div style="font-weight: 600; color: #065f46;">${index + 1}. ${bet.name}</div>
                                    <div style="font-size: 13px; color: #666;">Edge: +${bet.edge.toFixed(1)}% ${stars}</div>
                                    ${warning}
                                </div>
                            `;
                        });
                        
                        html += `</div>`;
                    }
                }
                
                // Custom Parlay Builder
                html += `
                    <div style="background: #f3e8ff; border-left: 4px solid #8b5cf6; padding: 15px; border-radius: 8px; margin-top: 20px;">
                        <h4 style="margin: 0 0 10px 0; color: #6b21a8;">üéØ Build Your Parlay</h4>
                        <p style="font-size: 13px; color: #6b21a8; margin-bottom: 15px;">
                            Select any bets to build a custom parlay (ignores edge recommendations)
                        </p>
                        <div id="game-parlay-selections" style="display: grid; gap: 10px;">
                `;
                
                // Add all available bets as checkboxes
                if (awayML !== 0) {
                    html += `
                        <label style="background: white; padding: 10px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 10px;">
                            <input type="checkbox" value="away_ml" data-team="${awayTeam}" data-type="moneyline" data-line="ML" data-odds="${awayML}" data-prob="${(awayWinProb * 100).toFixed(1)}" data-edge="${awayMLEdge}" style="width: 18px; height: 18px; cursor: pointer;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600;">${awayTeam} ML ${awayML > 0 ? '+' : ''}${awayML}</div>
                                <div style="font-size: 12px; color: #666;">Win Prob: ${(awayWinProb * 100).toFixed(1)}% | Edge: ${awayMLEdge > 0 ? '+' : ''}${awayMLEdge}%</div>
                            </div>
                        </label>
                    `;
                }
                
                if (homeML !== 0) {
                    html += `
                        <label style="background: white; padding: 10px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 10px;">
                            <input type="checkbox" value="home_ml" data-team="${homeTeam}" data-type="moneyline" data-line="ML" data-odds="${homeML}" data-prob="${(homeWinProb * 100).toFixed(1)}" data-edge="${homeMLEdge}" style="width: 18px; height: 18px; cursor: pointer;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600;">${homeTeam} ML ${homeML > 0 ? '+' : ''}${homeML}</div>
                                <div style="font-size: 12px; color: #666;">Win Prob: ${(homeWinProb * 100).toFixed(1)}% | Edge: ${homeMLEdge > 0 ? '+' : ''}${homeMLEdge}%</div>
                            </div>
                        </label>
                    `;
                }
                
                if (awaySpread !== 0) {
                    html += `
                        <label style="background: white; padding: 10px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 10px;">
                            <input type="checkbox" value="away_spread" data-team="${awayTeam}" data-type="spread" data-line="${awaySpread}" data-odds="${awaySpreadOdds}" data-prob="50" data-edge="${awaySpreadEdge}" style="width: 18px; height: 18px; cursor: pointer;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600;">${awayTeam} ${awaySpread > 0 ? '+' : ''}${awaySpread} (${awaySpreadOdds})</div>
                                <div style="font-size: 12px; color: #666;">Edge: ${awaySpreadEdge !== 'N/A' ? (parseFloat(awaySpreadEdge) > 0 ? '+' : '') + awaySpreadEdge + '%' : 'N/A'}</div>
                            </div>
                        </label>
                    `;
                }
                
                if (homeSpread !== 0) {
                    html += `
                        <label style="background: white; padding: 10px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 10px;">
                            <input type="checkbox" value="home_spread" data-team="${homeTeam}" data-type="spread" data-line="${homeSpread}" data-odds="${homeSpreadOdds}" data-prob="50" data-edge="${homeSpreadEdge}" style="width: 18px; height: 18px; cursor: pointer;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600;">${homeTeam} ${homeSpread > 0 ? '+' : ''}${homeSpread} (${homeSpreadOdds})</div>
                                <div style="font-size: 12px; color: #666;">Edge: ${homeSpreadEdge !== 'N/A' ? (parseFloat(homeSpreadEdge) > 0 ? '+' : '') + homeSpreadEdge + '%' : 'N/A'}</div>
                            </div>
                        </label>
                    `;
                }
                
                if (totalLine > 0) {
                    html += `
                        <label style="background: white; padding: 10px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 10px;">
                            <input type="checkbox" value="over" data-team="OVER" data-type="total_over" data-line="${totalLine}" data-odds="${overOdds}" data-prob="50" data-edge="${overEdge}" style="width: 18px; height: 18px; cursor: pointer;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600;">OVER ${totalLine} (${overOdds})</div>
                                <div style="font-size: 12px; color: #666;">Edge: ${overEdge !== 'N/A' ? (parseFloat(overEdge) > 0 ? '+' : '') + overEdge + '%' : 'N/A'}</div>
                            </div>
                        </label>
                        
                        <label style="background: white; padding: 10px; border-radius: 6px; cursor: pointer; display: flex; align-items: center; gap: 10px;">
                            <input type="checkbox" value="under" data-team="UNDER" data-type="total_under" data-line="${totalLine}" data-odds="${underOdds}" data-prob="50" data-edge="${underEdge}" style="width: 18px; height: 18px; cursor: pointer;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600;">UNDER ${totalLine} (${underOdds})</div>
                                <div style="font-size: 12px; color: #666;">Edge: ${underEdge !== 'N/A' ? (parseFloat(underEdge) > 0 ? '+' : '') + underEdge + '%' : 'N/A'}</div>
                            </div>
                        </label>
                    `;
                }
                
                html += `
                        </div>
                        
                        <div id="parlay-calculation" style="margin-top: 15px; padding: 15px; background: white; border-radius: 6px; display: none;">
                            <h5 style="margin: 0 0 10px 0; color: #6b21a8;">Parlay Summary</h5>
                            <div id="parlay-legs-list" style="margin-bottom: 10px;"></div>
                            <div style="border-top: 2px solid #e5e7eb; padding-top: 10px; margin-top: 10px;">
                                <div style="font-weight: 600; font-size: 16px; margin-bottom: 5px;">Combined Odds: <span id="parlay-odds"></span></div>
                                <div style="font-size: 14px; color: #666;">$100 bet wins: <span id="parlay-payout" style="font-weight: 600; color: #16a34a;"></span></div>
                                <div style="font-size: 13px; color: #666; margin-top: 5px;">Combined Probability: <span id="parlay-prob"></span></div>
                            </div>
                            <button onclick="addGameParlayToMain()" style="margin-top: 15px; padding: 10px 20px; background: #8b5cf6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; font-weight: 600; width: 100%;"
                                onmouseover="this.style.background='#7c3aed'" 
                                onmouseout="this.style.background='#8b5cf6'">
                                ‚ûï Add Parlay to Builder
                            </button>
                        </div>
                    </div>
                `;
                
                html += `</div>`;
                
                resultsDiv.innerHTML = html;
                
                // Add event listeners for parlay checkboxes
                setTimeout(() => {
                    const checkboxes = document.querySelectorAll('#game-parlay-selections input[type="checkbox"]');
                    checkboxes.forEach(cb => {
                        cb.addEventListener('change', updateGameParlayCalculation);
                    });
                }, 100);
                
            } catch (error) {
                console.error('Analysis error:', error);
                resultsDiv.innerHTML = `
                    <div style="background: #fee2e2; border-left: 4px solid #dc2626; padding: 15px; border-radius: 8px; margin-top: 20px;">
                        <p style="margin: 0; color: #991b1b;">
                            ‚ùå Error analyzing game: ${error.message}
                        </p>
                    </div>
                `;
            } finally {
                btn.disabled = false;
                btn.textContent = 'üìä Analyze Game Lines';
            }
        }
        // Manual Parlay Functions
        function updateManualParlayList() {
            const container = document.getElementById('manual-parlay-bets');
            
            if (manualParlayBets.length === 0) {
                container.innerHTML = '<p style="color: #999; font-style: italic;">No bets added yet. Analyze bets above to add them to your parlay.</p>';
                return;
            }
            
            let html = `<div style="background: #f8f9fa; padding: 15px; border-radius: 8px;">`;
            html += `<h4 style="margin-bottom: 10px; color: #333;">${manualParlayBets.length} Bet${manualParlayBets.length > 1 ? 's' : ''} Added:</h4>`;
            
            manualParlayBets.forEach((bet, index) => {
                html += `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: white; margin-bottom: 8px; border-radius: 6px;">
                        <div style="flex: 1;">
                            <strong>${bet.player}</strong> - ${bet.bet} ${bet.line} ${bet.prop_type.replace('_', ' ')}
                            <span style="font-size: 12px; color: #666;"> (${bet.odds > 0 ? '+' : ''}${bet.odds})</span>
                        </div>
                        <button onclick="removeFromManualParlay(${index})" style="background: #ef4444; color: white; border: none; padding: 4px 12px; border-radius: 4px; cursor: pointer; font-size: 12px;">Remove</button>
                    </div>
                `;
            });
            
            html += `</div>`;
            container.innerHTML = html;
        }
        
        function removeFromManualParlay(index) {
            manualParlayBets.splice(index, 1);
            updateManualParlayList();
        }
        
        function clearManualParlay() {
            manualParlayBets = [];
            updateManualParlayList();
            document.getElementById('manual-parlay-result').innerHTML = '';
        }
        
        function buildManualParlay() {
            if (manualParlayBets.length < 2) {
                alert('Add at least 2 bets to build a parlay');
                return;
            }
            
            // CORRELATION DETECTION
            // Check if multiple legs involve the same player
            const playerCounts = {};
            const correlatedGroups = [];
            
            manualParlayBets.forEach((bet, index) => {
                const player = bet.player.toLowerCase();
                if (!playerCounts[player]) {
                    playerCounts[player] = [];
                }
                playerCounts[player].push({
                    index: index,
                    bet: bet
                });
            });
            
            // Find correlated legs (same player)
            let hasCorrelation = false;
            for (const player in playerCounts) {
                if (playerCounts[player].length > 1) {
                    hasCorrelation = true;
                    correlatedGroups.push({
                        player: playerCounts[player][0].bet.player,
                        legs: playerCounts[player]
                    });
                }
            }
            
            // Calculate parlay odds (mathematical)
            let totalOdds = 1;
            manualParlayBets.forEach(bet => {
                const odds = bet.odds;
                // Convert American odds to decimal odds
                const decimal = odds < 0 ? (100 / Math.abs(odds)) + 1 : (odds / 100) + 1;
                totalOdds *= decimal;
            });
            
            // Convert back to American odds
            let parlayOdds;
            if (totalOdds >= 2) {
                // Positive odds: (decimal - 1) * 100
                parlayOdds = Math.round((totalOdds - 1) * 100);
            } else {
                // Negative odds: -100 / (decimal - 1)
                parlayOdds = Math.round(-100 / (totalOdds - 1));
            }
            
            // Calculate adjusted odds if correlation exists
            let adjustedOdds = parlayOdds;
            let correlationPenalty = 0;
            
            if (hasCorrelation) {
                // Sportsbooks typically reduce payout by 30-50% for correlated parlays
                // More legs on same player = bigger penalty
                const maxLegsOnPlayer = Math.max(...Object.values(playerCounts).map(arr => arr.length));
                
                if (maxLegsOnPlayer === 2) {
                    correlationPenalty = 0.35; // 35% reduction for 2 legs
                } else if (maxLegsOnPlayer === 3) {
                    correlationPenalty = 0.45; // 45% reduction for 3 legs
                } else {
                    correlationPenalty = 0.50; // 50% reduction for 4+ legs
                }
                
                // Apply penalty to payout
                const adjustedDecimal = 1 + ((totalOdds - 1) * (1 - correlationPenalty));
                
                if (adjustedDecimal >= 2) {
                    adjustedOdds = Math.round((adjustedDecimal - 1) * 100);
                } else {
                    adjustedOdds = Math.round(-100 / (adjustedDecimal - 1));
                }
            }
            
            console.log('Parlay calculation:', {
                bets: manualParlayBets.map(b => `${b.player} ${b.odds}`),
                totalDecimal: totalOdds.toFixed(4),
                mathematicalOdds: parlayOdds,
                hasCorrelation: hasCorrelation,
                correlationPenalty: correlationPenalty,
                adjustedOdds: adjustedOdds
            });
            
            // Calculate combined edge using TRUE EDGE (hit rate vs implied probability)
            const avgEdge = manualParlayBets.reduce((sum, bet) => {
                // Use true_edge if available, otherwise calculate it
                let trueEdge;
                if (bet.true_edge !== undefined) {
                    trueEdge = parseFloat(bet.true_edge);
                } else {
                    // Calculate true edge from hit rate vs implied probability
                    const hitRate = parseFloat(bet.hit_rate);
                    const impliedProb = bet.odds < 0 
                        ? (Math.abs(bet.odds) / (Math.abs(bet.odds) + 100)) * 100
                        : (100 / (bet.odds + 100)) * 100;
                    trueEdge = hitRate - impliedProb;
                }
                return sum + trueEdge;
            }, 0) / manualParlayBets.length;
            
            // Calculate combined probability
            // For independent legs: multiply all hit rates
            let independentProb = manualParlayBets.reduce((prob, bet) => {
                const hitRate = parseFloat(bet.hit_rate) / 100;
                return prob * hitRate;
            }, 1);
            
            // Adjust for correlation if exists
            let combinedProb = independentProb;
            let correlationBoost = 0;
            
            if (hasCorrelation) {
                // Correlated legs are MORE LIKELY to hit together
                // When one hits, others more likely to hit
                // Increase combined probability by 15-25%
                correlationBoost = 0.20 * correlatedGroups.length; // 20% boost per correlated group
                
                // Calculate boosted probability
                // But cap the boost so it doesn't exceed individual leg hit rates
                const maxPossibleProb = Math.min(...manualParlayBets.map(b => parseFloat(b.hit_rate) / 100));
                combinedProb = Math.min(independentProb * (1 + correlationBoost), maxPossibleProb);
            }
            
            // Calculate implied probability from adjusted odds
            const adjustedImpliedProb = adjustedOdds < 0 
                ? Math.abs(adjustedOdds) / (Math.abs(adjustedOdds) + 100)
                : 100 / (adjustedOdds + 100);
            
            // Calculate true parlay edge using adjusted odds
            const parlayEdge = (combinedProb - adjustedImpliedProb) * 100;
            
            // Determine recommendation
            let recommendation, recommendColor, recommendIcon;
            
            // Check if any leg has negative true edge
            const hasNegativeEdge = manualParlayBets.some(bet => {
                let trueEdge;
                if (bet.true_edge !== undefined) {
                    trueEdge = parseFloat(bet.true_edge);
                } else {
                    const hitRate = parseFloat(bet.hit_rate);
                    const impliedProb = bet.odds < 0 
                        ? (Math.abs(bet.odds) / (Math.abs(bet.odds) + 100)) * 100
                        : (100 / (bet.odds + 100)) * 100;
                    trueEdge = hitRate - impliedProb;
                }
                return trueEdge < 0;
            });
            
            if (hasNegativeEdge) {
                recommendation = "AVOID - NEGATIVE EDGE LEG";
                recommendColor = "#ef4444";
                recommendIcon = "‚ùå";
            } else if (parlayEdge >= 5 && avgEdge >= 5 && manualParlayBets.length <= 4) {
                recommendation = "STRONG PLAY";
                recommendColor = "#22c55e";
                recommendIcon = "üî•";
            } else if (parlayEdge >= 3 && avgEdge >= 3 && manualParlayBets.length <= 5) {
                recommendation = "GOOD VALUE";
                recommendColor = "#3b82f6";
                recommendIcon = "‚úÖ";
            } else if (parlayEdge >= 1 && avgEdge >= 2) {
                recommendation = "SLIGHT EDGE";
                recommendColor = "#f59e0b";
                recommendIcon = "‚ö°";
            } else if (parlayEdge < 0 || avgEdge < 0) {
                recommendation = "AVOID";
                recommendColor = "#ef4444";
                recommendIcon = "‚ùå";
            } else {
                recommendation = "BORDERLINE";
                recommendColor = "#94a3b8";
                recommendIcon = "‚ö†Ô∏è";
            }
            
            // Get explanation
            let explanation = "";
            if (hasNegativeEdge) {
                explanation = `‚ö†Ô∏è <strong>WARNING:</strong> One or more legs has NEGATIVE true edge (hit rate below implied probability). This means you're expected to lose money on that leg over time. Remove the negative edge leg(s) or skip this parlay entirely.`;
            } else if (recommendation === "STRONG PLAY") {
                explanation = `Excellent parlay! Strong edge on each leg (${avgEdge.toFixed(1)}% avg true edge) and good overall parlay edge (${parlayEdge.toFixed(1)}%). With ${manualParlayBets.length} legs, the combined probability is still reasonable.`;
            } else if (recommendation === "GOOD VALUE") {
                explanation = `Solid parlay with positive expected value. Each leg has decent true edge (${avgEdge.toFixed(1)}% avg) and overall parlay edge is ${parlayEdge.toFixed(1)}%.`;
            } else if (recommendation === "SLIGHT EDGE") {
                explanation = `Marginal positive value. Edge is thin at ${parlayEdge.toFixed(1)}%. Consider whether the reduced probability (${(combinedProb * 100).toFixed(1)}%) is worth the parlay odds.`;
            } else if (recommendation === "AVOID") {
                explanation = `Negative expected value. ${parlayEdge < 0 ? `Parlay edge is ${parlayEdge.toFixed(1)}%` : `Average leg true edge is only ${avgEdge.toFixed(1)}%`}. Individual bets likely better than parlaying them.`;
            } else {
                explanation = `Break-even territory. Edge is near zero. Consider playing individual legs instead where you have more certain value.`;
            }
            
            // Add warning if too many legs
            if (manualParlayBets.length > 5) {
                explanation += ` <strong>Note:</strong> With ${manualParlayBets.length} legs, variance is very high even with positive edge on each leg.`;
            }
            
            const resultDiv = document.getElementById('manual-parlay-result');
            
            resultDiv.innerHTML = `
                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; border-radius: 12px; margin-bottom: 15px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3>üé∞ ${manualParlayBets.length}-Leg Parlay</h3>
                        <div style="background: ${recommendColor}; padding: 8px 16px; border-radius: 8px; font-weight: bold; font-size: 18px;">
                            ${recommendIcon} ${recommendation}
                        </div>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.2); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        ${manualParlayBets.map(bet => {
                            // Calculate true edge for display
                            let trueEdge;
                            if (bet.true_edge !== undefined) {
                                trueEdge = parseFloat(bet.true_edge);
                            } else {
                                const hitRate = parseFloat(bet.hit_rate);
                                const impliedProb = bet.odds < 0 
                                    ? (Math.abs(bet.odds) / (Math.abs(bet.odds) + 100)) * 100
                                    : (100 / (bet.odds + 100)) * 100;
                                trueEdge = hitRate - impliedProb;
                            }
                            
                            // Color code based on true edge
                            const edgeColor = trueEdge < 0 ? '#ef4444' : trueEdge > 10 ? '#22c55e' : '#f59e0b';
                            const edgeIcon = trueEdge < 0 ? '‚ùå' : trueEdge > 10 ? '‚úÖ' : '‚ö°';
                            
                            return `
                            <div style="margin-bottom: 8px; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    ${edgeIcon} <strong>${bet.player}</strong> ${bet.bet} ${bet.line} ${bet.prop_type.replace('_', ' ')}
                                </div>
                                <div style="font-size: 14px; opacity: 0.9;">
                                    ${bet.odds > 0 ? '+' : ''}${bet.odds} (${bet.hit_rate}% hit, <span style="color: ${edgeColor}; font-weight: bold;">${trueEdge > 0 ? '+' : ''}${trueEdge.toFixed(1)}%</span> true edge)
                                </div>
                            </div>
                            `;
                        }).join('')}
                    </div>
                    
                    ${hasCorrelation ? `
                    <div style="background: rgba(255, 193, 7, 0.2); border-left: 4px solid #ffc107; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <div style="font-weight: bold; margin-bottom: 8px; font-size: 16px;">‚ö†Ô∏è CORRELATION DETECTED</div>
                        <div style="font-size: 14px; opacity: 0.95; line-height: 1.6;">
                            ${correlatedGroups.map(group => 
                                `<strong>${group.legs.length} legs involve ${group.player}</strong>: ${group.legs.map(l => l.bet.prop_type.replace('_', ' ')).join(', ')}`
                            ).join('<br>')}
                            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.3);">
                                üìâ <strong>Sportsbooks reduce payout for correlated parlays:</strong><br>
                                Mathematical odds: ${parlayOdds > 0 ? '+' : ''}${parlayOdds}<br>
                                Estimated book odds: ${adjustedOdds > 0 ? '+' : ''}${adjustedOdds} (${(correlationPenalty * 100).toFixed(0)}% penalty)<br>
                                <br>
                                üìà <strong>But correlation helps win probability:</strong><br>
                                Independent probability: ${(independentProb * 100).toFixed(1)}%<br>
                                Correlated probability: ${(combinedProb * 100).toFixed(1)}% (${((combinedProb - independentProb) * 100).toFixed(1)}% boost)<br>
                                <br>
                                üí° When one leg hits, others more likely to hit too!
                            </div>
                        </div>
                    </div>
                    ` : ''}
                    
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 15px;">
                        <div>
                            <div style="font-size: 12px; opacity: 0.9;">${hasCorrelation ? 'Math Odds' : 'Parlay Odds'}</div>
                            <div style="font-size: 24px; font-weight: bold;">${parlayOdds > 0 ? '+' : ''}${parlayOdds}</div>
                            ${hasCorrelation ? `<div style="font-size: 11px; opacity: 0.7;">Book: ~${adjustedOdds > 0 ? '+' : ''}${adjustedOdds}</div>` : ''}
                        </div>
                        <div>
                            <div style="font-size: 12px; opacity: 0.9;">True Probability</div>
                            <div style="font-size: 24px; font-weight: bold;">${(combinedProb * 100).toFixed(1)}%</div>
                        </div>
                        <div>
                            <div style="font-size: 12px; opacity: 0.9;">Parlay Edge</div>
                            <div style="font-size: 24px; font-weight: bold; color: ${parlayEdge > 0 ? '#4ade80' : '#f87171'};">
                                ${parlayEdge > 0 ? '+' : ''}${parlayEdge.toFixed(1)}%
                            </div>
                        </div>
                        <div>
                            <div style="font-size: 12px; opacity: 0.9;">Avg Edge/Leg</div>
                            <div style="font-size: 24px; font-weight: bold;">${avgEdge > 0 ? '+' : ''}${avgEdge.toFixed(1)}%</div>
                        </div>
                        <div>
                            <div style="font-size: 12px; opacity: 0.9;">Book's Implied Prob</div>
                            <div style="font-size: 24px; font-weight: bold;">${(adjustedImpliedProb * 100).toFixed(1)}%</div>
                        </div>
                        <div>
                            <div style="font-size: 12px; opacity: 0.9;">$100 Payout</div>
                            <div style="font-size: 24px; font-weight: bold;">$${hasCorrelation ? 
                                ((adjustedOdds > 0 ? adjustedOdds : (100 / Math.abs(adjustedOdds)) * 100) + 100).toFixed(2) :
                                (100 * totalOdds).toFixed(2)
                            }</div>
                            ${hasCorrelation ? `<div style="font-size: 11px; opacity: 0.7;">Math: $${(100 * totalOdds).toFixed(2)}</div>` : ''}
                        </div>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.15); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <div style="font-weight: bold; margin-bottom: 8px;">üìä Analysis:</div>
                        <div style="font-size: 14px; line-height: 1.6;">
                            ${explanation}
                        </div>
                    </div>
                    
                    <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 8px; font-size: 13px;">
                        <strong>üí° Key Insight:</strong> ${
                            hasCorrelation 
                            ? `Correlated parlay detected! Even with ${(correlationPenalty * 100).toFixed(0)}% payout penalty, your true edge is ${parlayEdge.toFixed(1)}% because correlated legs boost win probability to ${(combinedProb * 100).toFixed(1)}%. The legs help each other hit!`
                            : parlayEdge > avgEdge 
                            ? `Your parlay actually has BETTER edge (${parlayEdge.toFixed(1)}%) than the average individual leg (${avgEdge.toFixed(1)}%). This is rare and indicates strong value!`
                            : `Your parlay edge (${parlayEdge.toFixed(1)}%) is less than the average individual leg (${avgEdge.toFixed(1)}%). Consider betting legs individually for more guaranteed value.`
                        }
                    </div>
                </div>
                
                <button onclick="transferToParlayBuilder()" class="btn" style="width: 100%; background: #8b5cf6; padding: 15px; font-size: 16px; font-weight: 600; margin-top: 15px;">
                    ‚ûï Add to Parlay Builder
                </button>
                <p style="color: #666; font-size: 12px; text-align: center; margin-top: 8px;">
                    This will transfer all bets to the Parlay Builder tab where you can save for later or track results
                </p>
            `;
        }
        
        function transferToParlayBuilder() {
            if (manualParlayBets.length === 0) {
                alert('No bets to transfer');
                return;
            }
            
            // Transfer each bet to currentParlay
            manualParlayBets.forEach(bet => {
                currentParlay.push(bet);
                addToAIPool(bet); // Also add to AI Parlay Pool!
            });
            
            // Save to localStorage
            localStorage.setItem('currentParlay', JSON.stringify(currentParlay));
            
            // Clear manual parlay
            manualParlayBets = [];
            updateManualParlayList();
            document.getElementById('manual-parlay-result').innerHTML = '';
            
            // Update parlay display
            updateParlayDisplay();
            
            // Switch to Parlay Builder tab
            showTab('parlay');
            
            alert(`‚úÖ ${currentParlay.length} bets transferred to Parlay Builder!\n\n‚ú® Also added to AI Parlay Pool for optimal recommendations!\n\nYou can now:\n‚Ä¢ Save for later\n‚Ä¢ Add more legs\n‚Ä¢ Track WIN/LOSS when ready`);
        }
        
        // Results Tracking Functions
        function trackBetResult(player, propType, line, side, projection, result, betData) {
            // Parse the bet data if it's a string
            const originalBet = typeof betData === 'string' ? JSON.parse(betData) : betData;
            
            // Ask for actual result value (for ML training)
            const actualValue = prompt(
                `Enter ${player}'s actual ${propType} from the game:\n\n` +
                `This helps the ML model learn and improve predictions.\n` +
                `(Leave blank if you don't know)`
            );
            
            // If actual result provided, ask about excluding from ML
            let excludeFromML = false;
            if (actualValue && !isNaN(parseFloat(actualValue))) {
                excludeFromML = confirm(
                    `‚ö†Ô∏è ML Training Exclusion\n\n` +
                    `Was this result affected by:\n` +
                    `‚Ä¢ Early injury (Q1-Q2 exit)\n` +
                    `‚Ä¢ Ejection\n` +
                    `‚Ä¢ Surprise DNP/benching\n` +
                    `‚Ä¢ Other unpredictable outlier\n\n` +
                    `Click OK to EXCLUDE from ML training\n` +
                    `Click Cancel to INCLUDE in ML training (normal)`
                );
            }
            
            const bet = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                player: player,
                propType: propType,
                line: line,
                side: side,
                projection: parseFloat(projection),
                result: result,
                actualResult: actualValue && !isNaN(parseFloat(actualValue)) ? parseFloat(actualValue) : undefined,
                excludeFromML: excludeFromML,
                // Save original analysis metadata
                hit_rate: originalBet?.hit_rate || null,
                true_edge: originalBet?.true_edge || null,
                confidence: originalBet?.confidence || null,
                odds: originalBet?.odds || (side === 'OVER' ? originalBet?.over_odds : originalBet?.under_odds) || null,
                bookmaker: originalBet?.bookmaker || null
            };
            
            trackedBets.push(bet);
            localStorage.setItem('betTracking', JSON.stringify(trackedBets));
            updateTrackingDisplay();
            
            // If we have enough data, retrain ML model (only using non-excluded bets)
            const completeData = trackedBets.filter(b => b.actualResult !== undefined && !b.excludeFromML).length;
            if (completeData >= 10 && completeData % 5 === 0) {
                // Retrain every 5 new complete data points
                setTimeout(() => {
                    trainMLModel().then(success => {
                        if (success) {
                            alert(`ü§ñ ML model retrained on ${completeData} data points!\n\nPredictions will now be more accurate.`);
                        }
                    });
                }, 100);
            }
            
            let message = `‚úÖ Bet tracked as ${result.toUpperCase()}!\n\n${player} ${side} ${line} ${propType}\nProjection: ${projection}`;
            if (bet.actualResult) {
                const error = Math.abs(bet.actualResult - bet.projection);
                const errorPct = ((error / bet.actualResult) * 100).toFixed(1);
                message += `\nActual: ${bet.actualResult}\nError: ${error.toFixed(1)} (${errorPct}%)`;
                
                if (excludeFromML) {
                    message += `\n\n‚ö†Ô∏è EXCLUDED from ML training (outlier)`;
                } else if (completeData >= 10) {
                    message += `\n\nü§ñ ML will use this to improve predictions!`;
                } else {
                    message += `\n\n‚è≥ ${10 - completeData} more data points needed to train ML`;
                }
            }
            
            alert(message);
        }
        
        function updateParlayPerformanceStats() {
            const performanceContainer = document.getElementById('parlay-performance-stats');
            
            // Combine both data sources
            const savedParlaysData = JSON.parse(localStorage.getItem('savedParlays') || '[]').filter(p => p.result);
            const trackedParlaysData = trackedParlays || [];
            
            // Convert savedParlays to same format as trackedParlays
            const convertedSaved = savedParlaysData.map(sp => ({
                result: sp.result === 'WON' ? 'win' : 'loss',
                activeLegs: sp.activeLegCount || sp.legCount,
                legCount: sp.legCount,
                adjustedOdds: sp.adjustedOdds || sp.odds,
                totalOdds: sp.odds
            }));
            
            // Combine all parlays
            const allParlays = [...trackedParlaysData, ...convertedSaved];
            
            if (allParlays.length === 0) {
                performanceContainer.innerHTML = `
                    <p style="color: #92400e; text-align: center; font-size: 13px; font-style: italic; margin: 0;">
                        No parlays tracked yet
                    </p>
                `;
                return;
            }
            
            // Overall parlay stats
            const totalParlays = allParlays.length;
            const parlayWins = allParlays.filter(p => p.result === 'win').length;
            const parlayLosses = allParlays.filter(p => p.result === 'loss').length;
            const parlayWinRate = totalParlays > 0 ? ((parlayWins / totalParlays) * 100).toFixed(1) : '0.0';
            
            // Calculate profit/loss (assuming $100 per parlay)
            let totalProfit = 0;
            allParlays.forEach(parlay => {
                const odds = parlay.adjustedOdds || parlay.totalOdds;
                if (parlay.result === 'win') {
                    // Calculate payout
                    const decimalOdds = odds > 0 ? (odds / 100) + 1 : (100 / Math.abs(odds)) + 1;
                    totalProfit += (decimalOdds * 100) - 100; // Profit only
                } else {
                    totalProfit -= 100; // Loss
                }
            });
            
            const roi = totalParlays > 0 ? ((totalProfit / (totalParlays * 100)) * 100).toFixed(1) : '0.0';
            
            // Break down by leg count
            const byLegCount = {};
            allParlays.forEach(parlay => {
                const legCount = parlay.activeLegs || parlay.legCount;
                if (!byLegCount[legCount]) {
                    byLegCount[legCount] = { total: 0, wins: 0 };
                }
                byLegCount[legCount].total++;
                if (parlay.result === 'win') {
                    byLegCount[legCount].wins++;
                }
            });
            
            // Calculate average odds
            const avgOdds = totalParlays > 0 
                ? Math.round(allParlays.reduce((sum, p) => sum + (p.adjustedOdds || p.totalOdds || 0), 0) / totalParlays)
                : 0;
            
            // Build the display
            let html = `
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; text-align: center; margin-bottom: 12px;">
                    <div>
                        <div style="font-size: 20px; font-weight: bold; color: #92400e;">${totalParlays}</div>
                        <div style="font-size: 10px; color: #78350f;">Total Parlays</div>
                    </div>
                    <div>
                        <div style="font-size: 20px; font-weight: bold; color: #10b981;">${parlayWins}</div>
                        <div style="font-size: 10px; color: #78350f;">Wins</div>
                    </div>
                    <div>
                        <div style="font-size: 20px; font-weight: bold; color: ${parseFloat(parlayWinRate) >= 30 ? '#10b981' : '#ef4444'};">${parlayWinRate}%</div>
                        <div style="font-size: 10px; color: #78350f;">Win Rate</div>
                    </div>
                    <div>
                        <div style="font-size: 20px; font-weight: bold; color: ${totalProfit >= 0 ? '#10b981' : '#ef4444'};">${totalProfit >= 0 ? '+' : ''}$${totalProfit.toFixed(0)}</div>
                        <div style="font-size: 10px; color: #78350f;">Profit ($100/bet)</div>
                    </div>
                </div>
                
                <div style="border-top: 1px solid #fbbf24; padding-top: 10px; margin-top: 5px;">
                    <div style="font-size: 11px; color: #78350f; margin-bottom: 8px; font-weight: 600;">Performance by Leg Count:</div>
                    <div style="display: grid; gap: 6px;">
            `;
            
            // Sort by leg count
            const sortedLegCounts = Object.keys(byLegCount).sort((a, b) => parseInt(a) - parseInt(b));
            
            sortedLegCounts.forEach(legCount => {
                const data = byLegCount[legCount];
                const winRate = ((data.wins / data.total) * 100).toFixed(1);
                const color = parseFloat(winRate) >= 40 ? '#10b981' : parseFloat(winRate) >= 25 ? '#f59e0b' : '#ef4444';
                
                html += `
                    <div style="display: flex; justify-content: space-between; align-items: center; background: white; padding: 6px 10px; border-radius: 4px;">
                        <span style="font-size: 11px; color: #92400e; font-weight: 600;">${legCount}-Leg:</span>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <span style="font-size: 11px; color: #78350f;">${data.wins}/${data.total}</span>
                            <span style="font-size: 12px; font-weight: bold; color: ${color};">${winRate}%</span>
                        </div>
                    </div>
                `;
            });
            
            html += `
                    </div>
                </div>
                
                <div style="border-top: 1px solid #fbbf24; padding-top: 10px; margin-top: 10px; font-size: 11px; color: #78350f;">
                    <div style="display: flex; justify-content: space-between;">
                        <span>Avg Odds:</span>
                        <span style="font-weight: bold;">${avgOdds > 0 ? '+' : ''}${avgOdds}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 4px;">
                        <span>ROI:</span>
                        <span style="font-weight: bold; color: ${parseFloat(roi) >= 0 ? '#10b981' : '#ef4444'};">${roi}%</span>
                    </div>
                </div>
            `;
            
            performanceContainer.innerHTML = html;
        }
        
        function updateHitRateAccuracyStats() {
            const container = document.getElementById('hit-rate-accuracy-stats');
            if (!container) return;
            
            // Filter bets that have both hit_rate and actual results from OLD system
            const oldBetsWithHitRates = trackedBets.filter(b => 
                b.hit_rate !== null && 
                b.hit_rate !== undefined && 
                b.actualResult !== undefined &&
                !b.excludeFromML
            );
            
            // Get bets from NEW Results & Tracking system (savedParlays)
            const savedParlays = JSON.parse(localStorage.getItem('savedParlays') || '[]');
            const newBetsWithHitRates = [];
            savedParlays.filter(p => p.result).forEach(parlay => {
                parlay.legs.forEach(leg => {
                    if (leg.hit_rate && leg.actualResult !== undefined && leg.hit !== undefined) {
                        newBetsWithHitRates.push({
                            hit_rate: parseFloat(leg.hit_rate),
                            result: leg.hit ? 'win' : 'loss',
                            actualResult: parseFloat(leg.actualResult)
                        });
                    }
                });
            });
            
            // Get bets from HISTORICAL parlays (trackedParlays)
            const trackedParlaysData = typeof trackedParlays !== 'undefined' ? trackedParlays : [];
            const historicalBetsWithHitRates = [];
            trackedParlaysData.forEach(tp => {
                tp.legs.forEach(leg => {
                    if (leg.actualResult !== undefined && !leg.voided) {
                        // Alt lines use >= and <=, regular lines use > and <
                        const legHit = leg.is_alt_line ? 
                            ((leg.bet === 'OVER' && leg.actualResult >= leg.line) || 
                             (leg.bet === 'UNDER' && leg.actualResult <= leg.line)) :
                            ((leg.bet === 'OVER' && leg.actualResult > leg.line) || 
                             (leg.bet === 'UNDER' && leg.actualResult < leg.line));
                        // Only include if we have some confidence data
                        historicalBetsWithHitRates.push({
                            hit_rate: 50, // Default assumption
                            result: legHit ? 'win' : 'loss',
                            actualResult: parseFloat(leg.actualResult)
                        });
                    }
                });
            });
            
            // Combine all sources
            const betsWithHitRates = [...oldBetsWithHitRates, ...newBetsWithHitRates, ...historicalBetsWithHitRates];
            
            if (betsWithHitRates.length === 0) {
                container.innerHTML = `
                    <p style="color: #9ca3af; text-align: center; font-size: 13px; font-style: italic; margin: 0;">
                        No bets with hit rates tracked yet
                    </p>
                `;
                return;
            }
            
            // Group bets by hit rate tiers
            const tiers = {
                '90-100%': { min: 90, max: 100, total: 0, wins: 0 },
                '80-89%': { min: 80, max: 89, total: 0, wins: 0 },
                '70-79%': { min: 70, max: 79, total: 0, wins: 0 },
                '60-69%': { min: 60, max: 69, total: 0, wins: 0 },
                '50-59%': { min: 50, max: 59, total: 0, wins: 0 },
                '<50%': { min: 0, max: 49, total: 0, wins: 0 }
            };
            
            betsWithHitRates.forEach(bet => {
                const hitRate = parseFloat(bet.hit_rate);
                const won = bet.result === 'win';
                
                for (const [tierName, tierData] of Object.entries(tiers)) {
                    if (hitRate >= tierData.min && hitRate <= tierData.max) {
                        tierData.total++;
                        if (won) tierData.wins++;
                        break;
                    }
                }
            });
            
            // Build display
            let html = `
                <div style="font-size: 11px; color: #1e40af; margin-bottom: 8px; text-align: center;">
                    <strong>Predicted vs Actual Win Rates</strong>
                    <div style="font-size: 10px; color: #64748b; margin-top: 2px;">
                        (${betsWithHitRates.length} bets analyzed)
                    </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr; gap: 6px;">
            `;
            
            Object.entries(tiers).forEach(([tierName, data]) => {
                if (data.total === 0) return;
                
                const actualRate = ((data.wins / data.total) * 100).toFixed(1);
                const expectedMid = (data.min + data.max) / 2;
                const diff = parseFloat(actualRate) - expectedMid;
                const diffColor = Math.abs(diff) < 10 ? '#10b981' : Math.abs(diff) < 20 ? '#f59e0b' : '#ef4444';
                
                html += `
                    <div style="background: white; padding: 10px; border-radius: 6px; border-left: 4px solid ${diffColor}; margin-bottom: 4px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
                            <span style="font-size: 12px; color: #1e40af; font-weight: 600;">${tierName} Predicted</span>
                            <span style="font-size: 11px; color: #64748b; font-weight: 600;">${data.wins}/${data.total} bets hit</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div style="font-size: 10px; color: #64748b;">
                                Expected: ~${expectedMid.toFixed(0)}%
                            </div>
                            <div style="display: flex; gap: 8px; align-items: center;">
                                <span style="font-size: 13px; font-weight: bold; color: ${diffColor};">${actualRate}% actual</span>
                                <span style="font-size: 11px; font-weight: 600; color: ${diff > 0 ? '#10b981' : diff < 0 ? '#ef4444' : '#64748b'};">${diff > 0 ? '+' : ''}${diff.toFixed(1)}%</span>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += `
                </div>
                <div style="border-top: 1px solid #93c5fd; padding-top: 8px; margin-top: 8px; font-size: 10px; color: #475569; text-align: center;">
                    Green = Accurate | Orange = Slightly off | Red = Very off
                </div>
            `;
            
            // Calculate overall calibration factor
            const totalPredicted = betsWithHitRates.reduce((sum, bet) => sum + parseFloat(bet.hit_rate), 0);
            const avgPredicted = totalPredicted / betsWithHitRates.length;
            const actualWinRate = (betsWithHitRates.filter(b => b.result === 'win').length / betsWithHitRates.length) * 100;
            const calibrationFactor = actualWinRate / avgPredicted;
            
            // Store globally for use in predictions
            window.hitRateCalibrationFactor = calibrationFactor;
            
            if (betsWithHitRates.length >= 20) {
                const isWellCalibrated = calibrationFactor >= 0.9 && calibrationFactor <= 1.1;
                const isAcceptable = calibrationFactor >= 0.75;
                
                html += `
                    <div style="background: ${isWellCalibrated ? '#d1fae5' : isAcceptable ? '#fef3c7' : '#fee2e2'}; 
                                border: 2px solid ${isWellCalibrated ? '#10b981' : isAcceptable ? '#f59e0b' : '#ef4444'}; 
                                padding: 12px; border-radius: 8px; margin-top: 10px;">
                        <div style="font-size: 12px; font-weight: bold; color: #1e40af; margin-bottom: 6px; text-align: center;">
                            üìä OVERALL CALIBRATION
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                            <div style="background: white; padding: 6px; border-radius: 4px; text-align: center;">
                                <div style="font-size: 9px; color: #64748b; margin-bottom: 2px;">Avg Predicted</div>
                                <div style="font-size: 14px; font-weight: bold; color: #1e40af;">${avgPredicted.toFixed(1)}%</div>
                            </div>
                            <div style="background: white; padding: 6px; border-radius: 4px; text-align: center;">
                                <div style="font-size: 9px; color: #64748b; margin-bottom: 2px;">Actual Win Rate</div>
                                <div style="font-size: 14px; font-weight: bold; color: #1e40af;">${actualWinRate.toFixed(1)}%</div>
                            </div>
                        </div>
                        <div style="background: rgba(255,255,255,0.6); padding: 8px; border-radius: 6px; text-align: center;">
                            <div style="font-size: 10px; color: #475569; margin-bottom: 3px;">Calibration Factor</div>
                            <div style="font-size: 20px; font-weight: bold; color: ${isWellCalibrated ? '#10b981' : isAcceptable ? '#f59e0b' : '#ef4444'};">
                                ${(calibrationFactor * 100).toFixed(1)}%
                            </div>
                            <div style="font-size: 10px; color: #475569; margin-top: 4px; padding-top: 6px; border-top: 1px solid rgba(0,0,0,0.1);">
                                ${calibrationFactor < 0.9 ? 
                                    `‚ö†Ô∏è Over-confident: Multiply predictions by <strong>${calibrationFactor.toFixed(2)}</strong>` : 
                                  calibrationFactor > 1.1 ? 
                                    `‚ö†Ô∏è Under-confident: Multiply predictions by <strong>${calibrationFactor.toFixed(2)}</strong>` : 
                                    '‚úÖ Well-calibrated! No adjustment needed'}
                            </div>
                        </div>
                        ${calibrationFactor < 0.9 ? `
                            <div style="background: rgba(255,255,255,0.8); padding: 8px; border-radius: 4px; margin-top: 8px; font-size: 10px; color: #475569;">
                                <strong style="color: #1e40af;">Example:</strong> Tool shows 60% ‚Üí Adjust to ${(60 * calibrationFactor).toFixed(1)}% actual
                            </div>
                        ` : ''}
                    </div>
                `;
            } else {
                html += `
                    <div style="background: #f3f4f6; padding: 8px; border-radius: 6px; margin-top: 8px; font-size: 10px; color: #6b7280; text-align: center;">
                        Track ${20 - betsWithHitRates.length} more bets to calculate calibration factor
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }
        
        function updateTrackingDisplay() {
            const total = trackedBets.length;
            const wins = trackedBets.filter(b => b.result === 'win').length;
            const losses = trackedBets.filter(b => b.result === 'loss').length;
            const winRate = total > 0 ? ((wins / total) * 100).toFixed(1) : '0.0';
            const completeData = trackedBets.filter(b => b.actualResult !== undefined).length;
            
            document.getElementById('track-total').textContent = total;
            document.getElementById('track-wins').textContent = wins;
            document.getElementById('track-losses').textContent = losses;
            document.getElementById('track-winrate').textContent = winRate + '%';
            
            // Update ML status
            const mlStatusText = document.getElementById('ml-status-text');
            if (mlStatusText) {
                const excludedCount = trackedBets.filter(b => b.actualResult !== undefined && b.excludeFromML).length;
                const excludedText = excludedCount > 0 ? ` (${excludedCount} excluded as outliers)` : '';
                
                if (completeData >= 10) {
                    if (mlModelTrained) {
                        mlStatusText.innerHTML = `‚úÖ <strong>ML Model Active!</strong> Trained on ${completeData} data points${excludedText}. Ensemble predictions are now being used to improve accuracy.`;
                        mlStatusText.style.color = '#059669';
                    } else {
                        mlStatusText.innerHTML = `‚è≥ Training ML model on ${completeData} data points${excludedText}... Refresh or analyze a new bet to activate ML predictions.`;
                        mlStatusText.style.color = '#d97706';
                    }
                } else {
                    mlStatusText.innerHTML = `üìä ${completeData}/10 data points collected${excludedText}. Enter actual results when tracking bets to train ML model. (${10 - completeData} more needed)`;
                    mlStatusText.style.color = '#7c3aed';
                }
            }
            
            // Update Parlay Performance Stats
            updateParlayPerformanceStats();
            
            // Update Hit Rate Accuracy Stats
            updateHitRateAccuracyStats();
            
            const listContainer = document.getElementById('tracked-bets-list');
            if (total === 0) {
                listContainer.innerHTML = `
                    <p style="color: #9ca3af; text-align: center; padding: 20px; font-style: italic;">
                        No bets tracked yet. After analyzing a bet, click WIN or LOSS buttons on analyzed bets.
                    </p>
                `;
            } else {
                const sortedBets = [...trackedBets].reverse();
                listContainer.innerHTML = sortedBets.map(bet => {
                    const hasActual = bet.actualResult !== undefined;
                    const error = hasActual ? Math.abs(bet.actualResult - bet.projection) : null;
                    const errorPct = hasActual && bet.actualResult ? ((error / bet.actualResult) * 100).toFixed(1) : null;
                    const excludedFromML = bet.excludeFromML === true;
                    const hasHitRate = bet.hit_rate !== null && bet.hit_rate !== undefined;
                    const hasTrueEdge = bet.true_edge !== null && bet.true_edge !== undefined;
                    
                    return `
                    <div style="background: ${bet.result === 'win' ? '#d1fae5' : '#fee2e2'}; padding: 12px; border-radius: 8px; margin-bottom: 10px; border-left: 4px solid ${bet.result === 'win' ? '#10b981' : '#ef4444'};">
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div style="flex: 1;">
                                <strong>${bet.player}</strong> ${bet.side} ${bet.line} ${bet.propType}<br>
                                <small style="color: #6b7280;">
                                    Projection: ${bet.projection}${hasActual ? ` | Actual: ${bet.actualResult}` : ''}
                                    ${hasHitRate ? ` | <strong style="color: #3b82f6;">Hit Rate: ${parseFloat(bet.hit_rate).toFixed(1)}%</strong>` : ''}
                                    ${hasTrueEdge ? ` | <strong style="color: ${parseFloat(bet.true_edge) > 10 ? '#10b981' : parseFloat(bet.true_edge) > 5 ? '#f59e0b' : '#6b7280'};">Edge: ${parseFloat(bet.true_edge) > 0 ? '+' : ''}${parseFloat(bet.true_edge).toFixed(1)}%</strong>` : ''}<br>
                                    ${hasActual ? `Error: ${error.toFixed(1)} (${errorPct}%) ${excludedFromML ? '<span style="color: #f59e0b;">‚ö†Ô∏è EXCLUDED from ML</span>' : '<span style="color: #8b5cf6;">ü§ñ Used for ML</span>'}` : '<span style="color: #9ca3af;">‚è≥ No actual result (not used for ML)</span>'}<br>
                                    ${new Date(bet.timestamp).toLocaleDateString()}
                                </small>
                            </div>
                            <div style="display: flex; gap: 5px; align-items: center;">
                                <span style="font-size: 20px;">${bet.result === 'win' ? '‚úÖ' : '‚ùå'}</span>
                                <button onclick="deleteBet(${bet.id})" style="padding: 4px 8px; background: #9ca3af; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">
                                    Delete
                                </button>
                            </div>
                        </div>
                    </div>
                `}).join('');
            }
        }
        
        function deleteBet(id) {
            if (!confirm('Delete this tracked bet?')) return;
            trackedBets = trackedBets.filter(b => b.id !== id);
            localStorage.setItem('betTracking', JSON.stringify(trackedBets));
            updateTrackingDisplay();
        }
        
        function exportTracking() {
            if (trackedBets.length === 0) {
                alert('No bets to export');
                return;
            }
            
            const csv = [
                ['Date', 'Player', 'Prop', 'Side', 'Line', 'Projection', 'Result'].join(','),
                ...trackedBets.map(bet => [
                    new Date(bet.timestamp).toLocaleDateString(),
                    bet.player,
                    bet.propType,
                    bet.side,
                    bet.line,
                    bet.projection,
                    bet.result
                ].join(','))
            ].join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `bet-tracking-${new Date().toISOString().split('T')[0]}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        function clearTracking() {
            if (!confirm(`Delete all ${trackedBets.length} tracked bets? This cannot be undone.`)) return;
            trackedBets = [];
            localStorage.setItem('betTracking', JSON.stringify(trackedBets));
            updateTrackingDisplay();
        }
        
        // ========================================
        // PARLAY TRACKING FUNCTIONS
        // ========================================
        
        
        // Add TD prop to parlay
        function addTDToParlay(player, propType, betType, odds, hitRate, edge, bookmaker) {
            const tdBet = {
                player: player,
                prop_type: propType,
                line: betType, // "Anytime TD", "First TD", "2+ TDs", "3+ TDs"
                bet: 'YES', // TD props are always YES bets
                odds: odds,
                adjusted_projection: `${hitRate}%`, // Use hit rate as projection
                hit_rate: hitRate,
                true_edge: edge,
                bookmaker: bookmaker,
                is_td_prop: true
            };
            
            // Add to parlay
            currentParlay.push(tdBet);
            localStorage.setItem('currentParlay', JSON.stringify(currentParlay));
            updateParlayDisplay();
            
            // Also add to AI pool
            addToAIPool(tdBet);
            
            // Show success message
            alert(`‚úÖ Added to parlay!\n\n${player} ${betType}\nOdds: ${odds > 0 ? '+' : ''}${odds}\nHit Rate: ${hitRate}%\n\n‚ú® Also added to AI Parlay Pool for optimal parlay suggestions!\n\nGo to Parlay Builder tab to see your parlay.`);
            showTab('parlay');
        }
        
        function addToParlay(bet) {
            // Add bet to current parlay
            currentParlay.push(bet);
            localStorage.setItem('currentParlay', JSON.stringify(currentParlay));
            updateParlayDisplay();
            
            // Also add to AI pool for optimal parlay building
            addToAIPool(bet);
            
            // Show success message and switch to parlay tab
            alert(`‚úÖ Added to parlay!\n\n${bet.player} ${bet.bet} ${bet.line} ${bet.prop_type}\n\n‚ú® Also added to AI Parlay Pool for optimal parlay suggestions!\n\nGo to Parlay Builder tab to see your parlay.`);
            showTab('parlay');
        }
        
        function sendToAltLines(bet) {
            // Fill in Alt Lines Analyzer form with data from Manual Entry
            document.getElementById('alt-player').value = bet.player || '';
            document.getElementById('alt-prop-type').value = bet.prop_type || '';
            
            // CRITICAL: Fill in the adjusted projection so Alt Lines uses it!
            if (bet.adjusted_projection) {
                document.getElementById('alt-adjusted-projection').value = bet.adjusted_projection;
            }
            
            // Fill in recent games - games array is stored directly
            if (bet.games && bet.games.length > 0) {
                document.getElementById('alt-recent-games').value = bet.games.join(', ');
            }
            
            // Fill in minutes data if available
            if (bet.recent_minutes && bet.recent_minutes.length > 0) {
                document.getElementById('alt-recent-minutes').value = bet.recent_minutes.join(', ');
            }
            
            // Fill in tonight's minutes if available
            if (bet.tonight_minutes) {
                document.getElementById('alt-tonight-minutes').value = bet.tonight_minutes;
            }
            
            // Fill in context adjustments if they exist
            if (bet.opponent_team) {
                const opponentSelect = document.getElementById('alt-opponent-team');
                // Try to find matching option
                for (let i = 0; i < opponentSelect.options.length; i++) {
                    if (opponentSelect.options[i].value.toLowerCase() === bet.opponent_team.toLowerCase() ||
                        opponentSelect.options[i].text.toLowerCase().includes(bet.opponent_team.toLowerCase())) {
                        opponentSelect.selectedIndex = i;
                        break;
                    }
                }
            }
            
            // Build detailed message
            let transferredData = [
                `Player: ${bet.player}`,
                `Prop: ${bet.prop_type}`,
                `Projection: ${bet.adjusted_projection}`,
                `Games: ${bet.games ? bet.games.join(', ') : 'N/A'}`
            ];
            
            if (bet.recent_minutes && bet.recent_minutes.length > 0) {
                transferredData.push(`Minutes: ${bet.recent_minutes.join(', ')}`);
            }
            
            if (bet.tonight_minutes) {
                transferredData.push(`Expected Tonight: ${bet.tonight_minutes} min`);
            }
            
            const message = `üì§ Sent to Alt Lines Analyzer!\n\n${transferredData.join('\n')}\n\nNow just enter the alternate lines you want to compare!`;
            
            alert(message);
            
            // Scroll to Alt Lines section
            setTimeout(() => {
                const altLinesHeading = Array.from(document.querySelectorAll('h3')).find(h => h.textContent.includes('Alt Lines Analyzer'));
                if (altLinesHeading) {
                    altLinesHeading.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    // Highlight the player field briefly
                    const playerField = document.getElementById('alt-player');
                    playerField.style.background = '#bfdbfe';
                    setTimeout(() => {
                        playerField.style.background = '';
                    }, 2000);
                }
            }, 100);
        }
        
        function updateParlayDisplay() {
            const count = currentParlay.length;
            document.getElementById('parlay-count').textContent = count;
            
            const legsContainer = document.getElementById('parlay-legs');
            const summaryDiv = document.getElementById('parlay-summary');
            const actionsDiv = document.getElementById('parlay-actions');
            
            if (count === 0) {
                legsContainer.innerHTML = `
                    <p style="color: #9ca3af; text-align: center; padding: 40px; font-style: italic;">
                        No bets added yet. Analyze bets in Manual Entry and click "Add to Parlay"
                    </p>
                `;
                summaryDiv.style.display = 'none';
                actionsDiv.style.display = 'none';
                return;
            }
            
            // Display parlay legs
            legsContainer.innerHTML = currentParlay.map((bet, index) => {
                // Format bet display based on whether it's a game bet or player prop
                const isGameBet = bet.is_game_bet || bet.prop_type === 'moneyline' || bet.prop_type === 'spread' || bet.prop_type.includes('total_');
                
                let betDisplay = '';
                if (isGameBet) {
                    // Game bet formatting
                    if (bet.prop_type === 'moneyline') {
                        betDisplay = `<strong style="font-size: 16px;">${bet.player} ML</strong><br>`;
                    } else if (bet.prop_type === 'spread') {
                        betDisplay = `<strong style="font-size: 16px;">${bet.player} ${bet.line > 0 ? '+' : ''}${bet.line}</strong><br>`;
                    } else if (bet.prop_type === 'total_over') {
                        betDisplay = `<strong style="font-size: 16px;">OVER ${bet.line}</strong>${bet.away_team && bet.home_team ? `<br><small style="color: #6b7280;">${bet.away_team} @ ${bet.home_team}</small>` : ''}<br>`;
                    } else if (bet.prop_type === 'total_under') {
                        betDisplay = `<strong style="font-size: 16px;">UNDER ${bet.line}</strong>${bet.away_team && bet.home_team ? `<br><small style="color: #6b7280;">${bet.away_team} @ ${bet.home_team}</small>` : ''}<br>`;
                    }
                } else {
                    // Player prop formatting (existing)
                    betDisplay = `<strong style="font-size: 16px;">${bet.player}</strong> ${bet.bet} ${bet.line} ${bet.prop_type}<br>`;
                }
                
                return `
                    <div style="background: #f3f4f6; padding: 15px; border-radius: 8px; margin-bottom: 10px; border-left: 4px solid ${isGameBet ? '#f59e0b' : '#8b5cf6'};">
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div style="flex: 1;">
                                ${betDisplay}
                                <small style="color: #6b7280;">
                                    ${isGameBet ? `${bet.sport.toUpperCase()} Game Bet` : 'Player Prop'} | Odds: ${bet.odds > 0 ? '+' : ''}${bet.odds}
                                    ${bet.hit_rate ? ` | <strong style="color: #3b82f6;">Prob: ${parseFloat(bet.hit_rate).toFixed(1)}%</strong>` : ''}
                                    ${bet.true_edge ? ` | <strong style="color: ${parseFloat(bet.true_edge) > 10 ? '#10b981' : parseFloat(bet.true_edge) > 5 ? '#f59e0b' : '#6b7280'};">Edge: ${parseFloat(bet.true_edge) > 0 ? '+' : ''}${parseFloat(bet.true_edge).toFixed(1)}%</strong>` : ''}
                                </small>
                            </div>
                            <button onclick="removeFromParlay(${index})" style="padding: 6px 12px; background: #ef4444; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 12px;">
                                Remove
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Calculate parlay odds
            const americanOdds = currentParlay.map(b => parseInt(b.odds));
            const decimalOdds = americanOdds.map(odds => 
                odds > 0 ? (odds / 100) + 1 : (100 / Math.abs(odds)) + 1
            );
            const totalDecimal = decimalOdds.reduce((a, b) => a * b, 1);
            const totalAmerican = totalDecimal >= 2 ? Math.round((totalDecimal - 1) * 100) : Math.round(-100 / (totalDecimal - 1));
            const payout = totalDecimal * 100;
            
            // Calculate probability (assuming independence)
            const hitRates = currentParlay.map(b => parseFloat(b.hit_rate) / 100);
            const combinedProb = hitRates.reduce((a, b) => a * b, 1) * 100;
            
            // Update summary
            document.getElementById('parlay-total-odds').textContent = totalAmerican > 0 ? '+' + totalAmerican : totalAmerican;
            document.getElementById('parlay-probability').textContent = combinedProb.toFixed(1) + '%';
            
            // Calculate payouts for different bet amounts
            const payout1 = totalDecimal * 1;
            const payout10 = totalDecimal * 10;
            const payout100 = totalDecimal * 100;
            
            document.getElementById('parlay-payout-1').textContent = '$' + payout1.toFixed(2);
            document.getElementById('parlay-payout-10').textContent = '$' + payout10.toFixed(2);
            document.getElementById('parlay-payout-100').textContent = '$' + payout100.toFixed(0);
            
            summaryDiv.style.display = 'block';
            actionsDiv.style.display = 'block';
        }
        
        function removeFromParlay(index) {
            currentParlay.splice(index, 1);
            localStorage.setItem('currentParlay', JSON.stringify(currentParlay));
            updateParlayDisplay();
        }
        
        function clearParlay() {
            if (!confirm('Clear all legs from current parlay?')) return;
            currentParlay = [];
            localStorage.setItem('currentParlay', JSON.stringify(currentParlay));
            updateParlayDisplay();
        }
        
        // Update Pending Results Display
        function updatePendingResultsDisplay() {
            const pendingList = document.getElementById('pending-results-list');
            const pendingParlays = JSON.parse(localStorage.getItem('savedParlays') || '[]').filter(p => !p.result);
            
            if (pendingParlays.length === 0) {
                pendingList.innerHTML = '<p style="color: #78350f; font-style: italic; margin: 0;">No pending bets. Save a parlay from Parlay Builder!</p>';
                return;
            }
            
            pendingList.innerHTML = pendingParlays.map((parlay, parlayIndex) => {
                const actualParlayIndex = JSON.parse(localStorage.getItem('savedParlays') || '[]').findIndex(p => 
                    p.timestamp === parlay.timestamp && !p.result
                );
                
                return `
                    <div style="background: white; border: 2px solid #fbbf24; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 15px;">
                            <div>
                                <h4 style="margin: 0 0 5px 0; color: #92400e;">${parlay.name || 'Unnamed Parlay'}</h4>
                                <div style="font-size: 13px; color: #78350f;">
                                    ${parlay.legs.length} legs ‚Ä¢ ${parlay.odds > 0 ? '+' : ''}${parlay.odds} odds ‚Ä¢ ${new Date(parlay.timestamp).toLocaleDateString()}
                                </div>
                                ${parlay.adjustedProbability || parlay.probability ? `
                                    <div style="font-size: 13px; font-weight: 600; color: #92400e; margin-top: 5px; background: rgba(251, 191, 36, 0.3); display: inline-block; padding: 4px 8px; border-radius: 4px;">
                                        üéØ Win Probability: ${parlay.adjustedProbability || parlay.probability}%
                                        ${parlay.correlationPenalty > 0 ? `<span style="font-size: 11px; opacity: 0.8;"> (${parlay.probability}% naive)</span>` : ''}
                                    </div>
                                ` : ''}
                                ${parlay.correlationWarning ? `
                                    <div style="font-size: 11px; color: #f59e0b; margin-top: 3px;">
                                        ${parlay.correlationWarning}
                                    </div>
                                ` : ''}
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 12px; color: #78350f;">Bet Amount</div>
                                <div style="font-size: 18px; font-weight: 600; color: #92400e;">$${parlay.betAmount || 100}</div>
                            </div>
                        </div>
                        
                        ${parlay.legs.map((leg, legIndex) => {
                            const isPlayerProp = !leg.is_game_bet && !['moneyline', 'spread', 'total_over', 'total_under'].includes(leg.prop_type);
                            
                            // Try to infer team names for OVER/UNDER from other legs in same parlay
                            let inferredAwayTeam = leg.away_team;
                            let inferredHomeTeam = leg.home_team;
                            if (!inferredAwayTeam && !inferredHomeTeam && (leg.prop_type === 'total_over' || leg.prop_type === 'total_under')) {
                                // Look for ML or spread bets in same parlay to get team names
                                parlay.legs.forEach(otherLeg => {
                                    if (otherLeg.prop_type === 'moneyline' || otherLeg.prop_type === 'spread') {
                                        if (!inferredAwayTeam && otherLeg.player && otherLeg.player !== 'OVER' && otherLeg.player !== 'UNDER') {
                                            // Assume first team found is away team (common pattern)
                                            if (!inferredAwayTeam) inferredAwayTeam = otherLeg.player;
                                            else if (!inferredHomeTeam && otherLeg.player !== inferredAwayTeam) inferredHomeTeam = otherLeg.player;
                                        }
                                    }
                                });
                            }
                            
                            return `
                                <div style="background: #fef3c7; padding: 12px; border-radius: 6px; margin-bottom: 10px; border-left: 3px solid #f59e0b;">
                                    <div style="font-weight: 600; margin-bottom: 8px; color: #92400e;">
                                        ${isPlayerProp ? `${leg.player} ${leg.bet} ${leg.line} ${leg.prop_type}` : 
                                          leg.prop_type === 'moneyline' ? `${leg.player} ML` :
                                          leg.prop_type === 'spread' ? `${leg.player} ${leg.line > 0 ? '+' : ''}${leg.line}` :
                                          leg.prop_type === 'total_over' ? `OVER ${leg.line}${inferredAwayTeam && inferredHomeTeam ? ` (${inferredAwayTeam} @ ${inferredHomeTeam})` : ''}` :
                                          `UNDER ${leg.line}${inferredAwayTeam && inferredHomeTeam ? ` (${inferredAwayTeam} @ ${inferredHomeTeam})` : ''}`}
                                    </div>
                                    
                                    ${/* Show projection and hit rate */''}
                                    ${leg.hit_rate || leg.adjusted_projection ? `
                                        <div style="font-size: 12px; color: #92400e; margin-bottom: 8px; background: rgba(251, 191, 36, 0.2); padding: 6px 8px; border-radius: 4px;">
                                            ${leg.adjusted_projection ? `üìà <strong>Projection: ${parseFloat(leg.adjusted_projection).toFixed(1)}</strong>` : ''}
                                            ${leg.hit_rate && leg.adjusted_projection ? ` ‚Ä¢ ` : ''}
                                            ${leg.hit_rate ? `üéØ <strong>Hit Rate: ${parseFloat(leg.hit_rate).toFixed(1)}%</strong>` : ''}
                                            ${leg.odds ? ` ‚Ä¢ Odds: ${leg.odds > 0 ? '+' : ''}${leg.odds}` : ''}
                                            ${leg.true_edge ? ` ‚Ä¢ Edge: <span style="color: ${parseFloat(leg.true_edge) > 5 ? '#10b981' : '#92400e'};">${parseFloat(leg.true_edge) > 0 ? '+' : ''}${parseFloat(leg.true_edge).toFixed(1)}%</span>` : ''}
                                        </div>
                                    ` : ''}
                                    
                                    ${isPlayerProp ? `
                                        <div style="margin-bottom: 10px;">
                                            <label style="font-size: 12px; color: #78350f; display: block; margin-bottom: 5px;">
                                                Actual Result (enter number):
                                            </label>
                                            <div style="display: flex; gap: 8px; align-items: center;">
                                                <input type="number" 
                                                       id="result-${actualParlayIndex}-${legIndex}" 
                                                       step="0.1"
                                                       placeholder="e.g., 33"
                                                       style="width: 100px; padding: 6px; border: 2px solid #fbbf24; border-radius: 4px; font-size: 14px;">
                                                <span style="font-size: 12px; color: #78350f;">
                                                    (Line: ${leg.line})
                                                </span>
                                                <button onclick="setPlayerDNP(${actualParlayIndex}, ${legIndex})"
                                                        id="dnp-${actualParlayIndex}-${legIndex}"
                                                        style="padding: 6px 12px; background: #6b7280; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; font-size: 12px; white-space: nowrap;"
                                                        onmouseover="this.style.background='#4b5563'"
                                                        onmouseout="if(!this.classList.contains('dnp-selected')) { this.style.background='#6b7280'; }">
                                                    DNP
                                                </button>
                                            </div>
                                            <small style="font-size: 10px; color: #78350f; display: block; margin-top: 4px;">
                                                Click DNP if player didn't play (voids this leg)
                                            </small>
                                        </div>
                                    ` : `
                                        <div style="margin-bottom: 10px;">
                                            <label style="font-size: 12px; color: #78350f; display: block; margin-bottom: 8px;">
                                                Did this bet hit?
                                            </label>
                                            <div style="display: flex; gap: 10px;">
                                                <button onclick="setLegResult(${actualParlayIndex}, ${legIndex}, 'YES')"
                                                        id="result-${actualParlayIndex}-${legIndex}-yes"
                                                        style="flex: 1; padding: 10px; background: white; border: 2px solid #10b981; color: #10b981; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 14px; transition: all 0.2s;"
                                                        onmouseover="this.style.background='#10b981'; this.style.color='white';"
                                                        onmouseout="if(!this.classList.contains('selected')) { this.style.background='white'; this.style.color='#10b981'; }">
                                                    ‚úì YES
                                                </button>
                                                <button onclick="setLegResult(${actualParlayIndex}, ${legIndex}, 'NO')"
                                                        id="result-${actualParlayIndex}-${legIndex}-no"
                                                        style="flex: 1; padding: 10px; background: white; border: 2px solid #ef4444; color: #ef4444; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 14px; transition: all 0.2s;"
                                                        onmouseover="this.style.background='#ef4444'; this.style.color='white';"
                                                        onmouseout="if(!this.classList.contains('selected')) { this.style.background='white'; this.style.color='#ef4444'; }">
                                                    ‚úó NO
                                                </button>
                                            </div>
                                        </div>
                                    `}
                                </div>
                            `;
                        }).join('')}
                        
                        <button onclick="submitParlayResults(${actualParlayIndex})" 
                                style="width: 100%; padding: 12px; background: #f59e0b; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 14px; margin-top: 10px;"
                                onmouseover="this.style.background='#d97706'" 
                                onmouseout="this.style.background='#f59e0b'">
                            üíæ Save Results
                        </button>
                    </div>
                `;
            }).join('');
        }
        
        // Set leg result (for YES/NO buttons)
        function setLegResult(parlayIndex, legIndex, result) {
            const yesBtn = document.getElementById(`result-${parlayIndex}-${legIndex}-yes`);
            const noBtn = document.getElementById(`result-${parlayIndex}-${legIndex}-no`);
            
            // Clear both selections
            yesBtn.classList.remove('selected');
            noBtn.classList.remove('selected');
            yesBtn.style.background = 'white';
            yesBtn.style.color = '#10b981';
            noBtn.style.background = 'white';
            noBtn.style.color = '#ef4444';
            
            // Set selected
            if (result === 'YES') {
                yesBtn.classList.add('selected');
                yesBtn.style.background = '#10b981';
                yesBtn.style.color = 'white';
            } else {
                noBtn.classList.add('selected');
                noBtn.style.background = '#ef4444';
                noBtn.style.color = 'white';
            }
            
            // Store in temp storage
            if (!window.tempResults) window.tempResults = {};
            if (!window.tempResults[parlayIndex]) window.tempResults[parlayIndex] = {};
            window.tempResults[parlayIndex][legIndex] = result;
        }
        
        // Set player as DNP (Did Not Play)
        function setPlayerDNP(parlayIndex, legIndex) {
            const dnpBtn = document.getElementById(`dnp-${parlayIndex}-${legIndex}`);
            const inputField = document.getElementById(`result-${parlayIndex}-${legIndex}`);
            
            if (!dnpBtn) return;
            
            // Toggle DNP state
            const isDNP = dnpBtn.classList.contains('dnp-selected');
            
            if (isDNP) {
                // Un-mark DNP
                dnpBtn.classList.remove('dnp-selected');
                dnpBtn.style.background = '#6b7280';
                dnpBtn.textContent = 'DNP';
                inputField.disabled = false;
                inputField.value = '';
                inputField.style.opacity = '1';
                
                // Remove from temp storage
                if (window.tempDNP && window.tempDNP[parlayIndex]) {
                    delete window.tempDNP[parlayIndex][legIndex];
                }
            } else {
                // Mark as DNP
                dnpBtn.classList.add('dnp-selected');
                dnpBtn.style.background = '#ef4444';
                dnpBtn.textContent = '‚äò DNP';
                inputField.disabled = true;
                inputField.value = '';
                inputField.style.opacity = '0.5';
                inputField.placeholder = 'Did Not Play';
                
                // Store in temp DNP storage
                if (!window.tempDNP) window.tempDNP = {};
                if (!window.tempDNP[parlayIndex]) window.tempDNP[parlayIndex] = {};
                window.tempDNP[parlayIndex][legIndex] = true;
            }
        }
        
        // Submit parlay results
        function submitParlayResults(parlayIndex) {
            const savedParlays = JSON.parse(localStorage.getItem('savedParlays') || '[]');
            const parlay = savedParlays[parlayIndex];
            
            if (!parlay) {
                alert('Parlay not found');
                return;
            }
            
            let allResultsEntered = true;
            let legsHit = 0;
            let dnpCount = 0;
            
            parlay.legs.forEach((leg, legIndex) => {
                const isPlayerProp = !leg.is_game_bet && !['moneyline', 'spread', 'total_over', 'total_under'].includes(leg.prop_type);
                
                // Check if marked as DNP
                const isDNP = window.tempDNP?.[parlayIndex]?.[legIndex];
                
                if (isDNP) {
                    // Player didn't play - void this leg
                    leg.voided = true;
                    leg.actualResult = 'DNP';
                    leg.hit = null; // Doesn't count as hit or miss
                    dnpCount++;
                    return; // Skip this leg
                }
                
                if (isPlayerProp) {
                    // Get actual stat from input
                    const input = document.getElementById(`result-${parlayIndex}-${legIndex}`);
                    if (!input || input.value === '') {
                        allResultsEntered = false;
                        return;
                    }
                    
                    const actualStat = parseFloat(input.value);
                    leg.actualResult = actualStat;
                    leg.voided = false;
                    
                    // Determine if hit based on OVER/UNDER
                    const isOver = leg.bet.toUpperCase() === 'OVER';
                    const hit = isOver ? (actualStat > parseFloat(leg.line)) : (actualStat < parseFloat(leg.line));
                    leg.hit = hit;
                    
                    if (hit) legsHit++;
                } else {
                    // Get YES/NO result from temp storage
                    const result = window.tempResults?.[parlayIndex]?.[legIndex];
                    if (!result) {
                        allResultsEntered = false;
                        return;
                    }
                    
                    leg.actualResult = result;
                    leg.voided = false;
                    leg.hit = result === 'YES';
                    
                    if (leg.hit) legsHit++;
                }
            });
            
            if (!allResultsEntered) {
                alert('Please enter results for all legs before submitting (or mark as DNP)');
                return;
            }
            
            // Calculate active legs (non-voided)
            const activeLegs = parlay.legs.filter(leg => !leg.voided);
            const activeLegCount = activeLegs.length;
            
            // Calculate parlay result
            const parlayWon = legsHit === activeLegCount && activeLegCount > 0;
            const betAmount = parlay.betAmount || 100;
            let payout = 0;
            let adjustedOdds = parlay.odds;
            
            if (dnpCount > 0 && activeLegCount > 0) {
                // Recalculate odds for reduced parlay
                const originalLegs = parlay.legs.length;
                
                // If voided legs reduce to 1 leg, use that leg's odds
                if (activeLegCount === 1) {
                    adjustedOdds = parseInt(activeLegs[0].odds) || -110;
                } else {
                    // Recalculate combined odds for remaining legs
                    const legOdds = activeLegs.map(leg => parseInt(leg.odds) || -110);
                    const decimalOdds = legOdds.map(odds => 
                        odds > 0 ? (odds / 100) + 1 : (100 / Math.abs(odds)) + 1
                    );
                    const totalDecimal = decimalOdds.reduce((a, b) => a * b, 1);
                    adjustedOdds = totalDecimal >= 2 ? Math.round((totalDecimal - 1) * 100) : Math.round(-100 / (totalDecimal - 1));
                }
            }
            
            if (parlayWon) {
                const decimalOdds = adjustedOdds > 0 ? (adjustedOdds / 100) + 1 : (100 / Math.abs(adjustedOdds)) + 1;
                payout = betAmount * decimalOdds;
            }
            
            parlay.result = parlayWon ? 'WON' : 'LOST';
            parlay.legsHit = legsHit;
            parlay.activeLegCount = activeLegCount;
            parlay.dnpCount = dnpCount;
            parlay.adjustedOdds = adjustedOdds;
            parlay.payout = payout;
            parlay.profit = payout - betAmount;
            parlay.resultDate = new Date().toISOString();
            
            // Save
            savedParlays[parlayIndex] = parlay;
            localStorage.setItem('savedParlays', JSON.stringify(savedParlays));
            
            // Clear temp results and DNP markers
            if (window.tempResults) delete window.tempResults[parlayIndex];
            if (window.tempDNP) delete window.tempDNP[parlayIndex];
            
            // Update displays
            updatePendingResultsDisplay();
            updateRecentResultsDisplay();
            updateStatsDisplay();
            
            let resultMessage = `‚úÖ Results saved!\n\nParlay: ${parlayWon ? 'WON' : 'LOST'}`;
            if (dnpCount > 0) {
                resultMessage += `\n\n‚äò ${dnpCount} leg${dnpCount > 1 ? 's' : ''} voided (DNP)`;
                resultMessage += `\nAdjusted to ${activeLegCount}-leg parlay`;
                resultMessage += `\nAdjusted odds: ${adjustedOdds > 0 ? '+' : ''}${adjustedOdds}`;
            }
            resultMessage += `\nLegs Hit: ${legsHit}/${activeLegCount}`;
            resultMessage += `\nProfit: $${parlay.profit.toFixed(2)}`;
            
            alert(resultMessage);
        }
        
        // Update Recent Results Display
        function updateRecentResultsDisplay() {
            const recentList = document.getElementById('recent-results-list');
            
            // Get new parlays
            const newParlays = JSON.parse(localStorage.getItem('savedParlays') || '[]')
                .filter(p => p.result)
                .map(p => ({...p, source: 'new'}));
            
            // MAIN SOURCE: trackedParlays (your 66 existing parlays)
            const trackedParlaysData = typeof trackedParlays !== 'undefined' ? trackedParlays : [];
            const mainParlays = trackedParlaysData.map(tp => {
                const won = tp.result === 'win';
                const betAmount = 100;
                
                // Calculate profit
                let profit = 0;
                if (won) {
                    const odds = tp.adjustedOdds || tp.odds || 0;
                    if (odds > 0) {
                        profit = betAmount * (odds / 100);
                    } else {
                        profit = betAmount * (100 / Math.abs(odds));
                    }
                } else {
                    profit = -betAmount;
                }
                
                // Count legs hit
                const legsHit = tp.legs.filter(leg => !leg.voided && leg.actualResult !== undefined && 
                    (leg.is_alt_line ? 
                        ((leg.bet === 'OVER' && leg.actualResult >= leg.line) || 
                         (leg.bet === 'UNDER' && leg.actualResult <= leg.line)) :
                        ((leg.bet === 'OVER' && leg.actualResult > leg.line) || 
                         (leg.bet === 'UNDER' && leg.actualResult < leg.line)))).length;
                
                return {
                    name: `${tp.legCount}-Leg Parlay`,
                    result: won ? 'WON' : 'LOST',
                    legsHit: legsHit,
                    legs: tp.legs.map(leg => ({
                        player: leg.player,
                        bet: leg.bet,
                        line: leg.line,
                        prop_type: leg.propType,
                        hit: leg.actualResult !== undefined && !leg.voided && 
                            (leg.is_alt_line ? 
                                ((leg.bet === 'OVER' && leg.actualResult >= leg.line) || 
                                 (leg.bet === 'UNDER' && leg.actualResult <= leg.line)) :
                                ((leg.bet === 'OVER' && leg.actualResult > leg.line) || 
                                 (leg.bet === 'UNDER' && leg.actualResult < leg.line))),
                        actualResult: leg.actualResult,
                        voided: leg.voided
                    })),
                    resultDate: tp.timestamp,
                    betAmount: betAmount,  // Add bet amount to display
                    profit: profit,
                    source: 'tracked'
                };
            });
            
            // Get old parlays
            const trackedBets = JSON.parse(localStorage.getItem('trackedBets') || '[]');
            const oldParlays = trackedBets
                .filter(tb => tb.status === 'complete' || (tb.legs && tb.legs.every(leg => leg.result !== null || leg.actualResult !== undefined)))
                .map(tb => {
                    const allLegsHit = tb.legs && tb.legs.every(leg => leg.result === true || leg.hit === true);
                    const won = allLegsHit;
                    const legsHit = tb.legs ? tb.legs.filter(leg => leg.result === true || leg.hit === true).length : 0;
                    
                    const betAmount = tb.stake || 100;
                    let profit = 0;
                    if (won && tb.payout) {
                        profit = tb.payout - betAmount;
                    } else if (won) {
                        profit = betAmount * 0.5;
                    } else {
                        profit = -betAmount;
                    }
                    
                    return {
                        name: tb.legs && tb.legs.length > 0 ? 
                            `${tb.legs[0].player}${tb.legs.length > 1 ? '/' + tb.legs[1].player : ''}` : 
                            'Old Parlay',
                        result: won ? 'WON' : 'LOST',
                        legsHit: legsHit,
                        legs: tb.legs || [],
                        resultDate: tb.date || new Date().toISOString(),
                        betAmount: betAmount,  // Add bet amount to display
                        profit: profit,
                        source: 'old'
                    };
                });
            
            // Combine and sort (prioritize trackedParlays)
            const completedParlays = [...mainParlays, ...newParlays, ...oldParlays]
                .sort((a, b) => new Date(b.resultDate) - new Date(a.resultDate))
                .slice(0, 20);
            
            if (completedParlays.length === 0) {
                recentList.innerHTML = '<p style="color: #6b7280; font-style: italic; margin: 0;">No results yet. Start tracking your bets!</p>';
                return;
            }
            
            recentList.innerHTML = completedParlays.map(parlay => {
                const won = parlay.result === 'WON';
                const sourceLabel = parlay.source === 'tracked' ? 'HISTORY' : (parlay.source === 'old' ? 'MIGRATED' : 'NEW');
                
                return `
                    <div style="background: ${won ? '#d1fae5' : '#fee2e2'}; border-left: 4px solid ${won ? '#10b981' : '#ef4444'}; padding: 15px; border-radius: 8px; margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <div>
                                <h4 style="margin: 0 0 5px 0; color: ${won ? '#065f46' : '#991b1b'};">
                                    ${won ? '‚úÖ' : '‚ùå'} ${parlay.name || 'Unnamed Parlay'}
                                    <span style="font-size: 10px; background: #6b7280; color: white; padding: 2px 6px; border-radius: 4px; margin-left: 8px;">${sourceLabel}</span>
                                </h4>
                                <div style="font-size: 13px; color: ${won ? '#047857' : '#7f1d1d'};">
                                    ${parlay.legsHit}/${parlay.activeLegCount || parlay.legs.length} legs hit${parlay.dnpCount ? ` (${parlay.dnpCount} voided)` : ''} ‚Ä¢ ${new Date(parlay.resultDate).toLocaleDateString()}
                                </div>
                                ${parlay.adjustedProbability || parlay.probability ? `
                                    <div style="font-size: 11px; color: ${won ? '#047857' : '#7f1d1d'}; margin-top: 3px;">
                                        üéØ Predicted: ${parlay.adjustedProbability || parlay.probability}% win chance
                                        ${parlay.correlationPenalty > 0 ? ` (${parlay.probability}% naive)` : ''}
                                        ‚Ä¢ <strong>Actual: ${won ? 'WON ‚úÖ' : 'LOST ‚ùå'}</strong>
                                    </div>
                                ` : ''}
                                ${parlay.legs && parlay.legs.length > 0 ? `
                                    <div style="font-size: 10px; color: ${won ? '#047857' : '#7f1d1d'}; margin-top: 5px; opacity: 0.8;">
                                        ${parlay.legs.filter(l => !l.voided).map(leg => {
                                            const actual = leg.actualResult !== undefined ? leg.actualResult : leg.actual_value;
                                            const projection = leg.adjusted_projection || leg.projection;
                                            if (actual !== undefined && projection) {
                                                const error = Math.abs(actual - parseFloat(projection));
                                                const errorSymbol = actual >= parseFloat(projection) ? '‚Üó' : '‚Üò';
                                                return `${leg.player}: ${projection}‚Üí${actual} ${errorSymbol}${error.toFixed(1)}`;
                                            }
                                            return null;
                                        }).filter(Boolean).join(' | ')}
                                    </div>
                                ` : ''}
                            </div>
                            <div style="text-align: right;">
                                <div style="font-size: 11px; color: ${won ? '#047857' : '#7f1d1d'}; margin-bottom: 2px;">
                                    Bet: $${parlay.betAmount || 100}
                                </div>
                                <div style="font-size: 12px; color: ${won ? '#047857' : '#7f1d1d'};">Profit/Loss</div>
                                <div style="font-size: 20px; font-weight: 600; color: ${won ? '#10b981' : '#ef4444'};">
                                    ${parlay.profit >= 0 ? '+' : ''}$${Math.abs(parlay.profit).toFixed(2)}
                                </div>
                            </div>
                        </div>
                        
                        <details style="margin-top: 10px;">
                            <summary style="cursor: pointer; color: ${won ? '#047857' : '#7f1d1d'}; font-size: 13px; font-weight: 600;">View Legs</summary>
                            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid ${won ? '#a7f3d0' : '#fecaca'};">
                                ${parlay.legs.map(leg => {
                                    if (leg.voided) {
                                        return `<div style="font-size: 12px; padding: 5px 0; color: #6b7280; opacity: 0.6;">‚äò ${leg.player} ${leg.bet || ''} ${leg.line} ${leg.prop_type || leg.propType || ''} (VOIDED)</div>`;
                                    }
                                    
                                    const legHit = leg.hit || leg.result === true;
                                    const playerName = leg.player || 'Unknown';
                                    const betType = leg.bet || '';
                                    const line = leg.line || '';
                                    const propType = leg.prop_type || leg.propType || '';
                                    const actual = leg.actualResult !== undefined ? leg.actualResult : (leg.actual_value !== undefined ? leg.actual_value : '');
                                    const hitRate = leg.hit_rate ? parseFloat(leg.hit_rate).toFixed(1) : null;
                                    const projection = leg.adjusted_projection || leg.projection || null;
                                    
                                    return `
                                        <div style="font-size: 12px; padding: 5px 0; color: ${won ? '#065f46' : '#991b1b'};">
                                            ${legHit ? '‚úì' : '‚úó'} ${playerName} ${betType} ${line} ${propType}
                                            ${actual !== '' ? ` ‚Üí ${actual}` : ''}
                                            ${projection && actual !== '' ? ` <span style="font-size: 10px; opacity: 0.6;">(proj: ${projection})</span>` : ''}
                                            ${hitRate ? ` <span style="font-size: 10px; opacity: 0.7;">(${hitRate}% predicted)</span>` : ''}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </details>
                    </div>
                `;
            }).join('');
        }
        
        // Update Stats Display
        function updateStatsDisplay() {
            // Get data from ALL sources
            const savedParlaysRaw = JSON.parse(localStorage.getItem('savedParlays') || '[]').filter(p => p.result);
            const trackedBetsRaw = JSON.parse(localStorage.getItem('trackedBets') || '[]');
            
            // MAIN SOURCE: trackedParlays (your 66 existing parlays)
            const trackedParlaysData = typeof trackedParlays !== 'undefined' ? trackedParlays : [];
            
            console.log('üìä Stats Debug:');
            console.log('  trackedParlays:', trackedParlaysData.length);
            console.log('  savedParlays:', savedParlaysRaw.length);
            console.log('  trackedBets (old):', trackedBetsRaw.length);
            console.log('  ‚Üí Using: trackedParlays + savedParlays');
            console.log('  ‚Üí Skipping: trackedBets (has bad data)');
            
            // Convert trackedParlays to standard format
            const mainParlays = trackedParlaysData.map(tp => {
                const won = tp.result === 'win';
                const betAmount = 100; // Standard bet amount
                
                // Calculate profit based on odds
                let profit = 0;
                if (won) {
                    const odds = tp.adjustedOdds || tp.odds || 0;
                    if (odds > 0) {
                        profit = betAmount * (odds / 100);
                    } else if (odds < 0) {
                        profit = betAmount * (100 / Math.abs(odds));
                    }
                } else {
                    profit = -betAmount;
                }
                
                // Validate profit is a real number
                if (!isFinite(profit)) {
                    profit = won ? 0 : -betAmount;
                }
                
                return {
                    result: won ? 'WON' : 'LOST',
                    betAmount: betAmount,
                    profit: profit,
                    source: 'tracked'
                };
            });
            
            // Convert savedParlays (new Results & Tracking system)
            const savedParlays = savedParlaysRaw.map(sp => {
                const won = sp.result === 'WON';
                const betAmount = sp.betAmount || 100;
                let profit = sp.profit;
                
                // Validate profit
                if (!isFinite(profit)) {
                    profit = won ? betAmount * 0.5 : -betAmount;
                }
                
                return {
                    result: won ? 'WON' : 'LOST',
                    betAmount: betAmount,
                    profit: profit,
                    source: 'new'
                };
            });
            
            // SKIP old trackedBets entirely - it has bad data and is redundant with trackedParlays
            // This is the source of your Infinity bug
            console.log('  ‚ö†Ô∏è Skipping trackedBets (old system) to avoid duplicates and bad data');
            
            // Combine sources (EXCLUDING trackedBets)
            const allParlays = [...mainParlays, ...savedParlays];
            
            // Validate all data
            const validParlays = allParlays.filter(p => {
                const valid = isFinite(p.profit) && isFinite(p.betAmount) && p.betAmount > 0;
                if (!valid) {
                    console.warn('  ‚ö†Ô∏è Filtered out invalid parlay:', p);
                }
                return valid;
            });
            
            const totalBets = validParlays.length;
            const wins = validParlays.filter(p => p.result === 'WON').length;
            const winRate = totalBets > 0 ? (wins / totalBets * 100) : 0;
            
            const totalWagered = validParlays.reduce((sum, p) => sum + p.betAmount, 0);
            const totalProfit = validParlays.reduce((sum, p) => sum + p.profit, 0);
            const roi = totalWagered > 0 ? (totalProfit / totalWagered * 100) : 0;
            
            console.log('  ‚úÖ Final stats:');
            console.log('    Total bets:', totalBets);
            console.log('    Win rate:', winRate.toFixed(1) + '%');
            console.log('    Total P/L:', totalProfit.toFixed(2));
            console.log('    ROI:', roi.toFixed(1) + '%');
            
            // Validate final numbers before display
            document.getElementById('stats-total-bets').textContent = totalBets;
            document.getElementById('stats-total-wagered').textContent = isFinite(totalWagered) ? '$' + totalWagered.toFixed(0) : '$0';
            document.getElementById('stats-win-rate').textContent = isFinite(winRate) ? winRate.toFixed(1) + '%' : '0%';
            document.getElementById('stats-total-pl').textContent = isFinite(totalProfit) ? ((totalProfit >= 0 ? '+' : '') + '$' + totalProfit.toFixed(2)) : '$0.00';
            document.getElementById('stats-roi').textContent = isFinite(roi) ? ((roi >= 0 ? '+' : '') + roi.toFixed(1) + '%') : '0%';
            
            // Color code P/L and ROI
            const plElement = document.getElementById('stats-total-pl');
            const roiElement = document.getElementById('stats-roi');
            
            plElement.style.color = totalProfit >= 0 ? '#10b981' : '#ef4444';
            roiElement.style.color = roi >= 0 ? '#10b981' : '#ef4444';
        }
        
        // Results Tracking Functions
        function saveParlayForTracking() {
            if (currentParlay.length === 0) {
                alert('No bets in parlay to track!');
                return;
            }
            
            // Prompt for parlay name
            const parlayName = prompt('Name this parlay (optional):', 
                currentParlay.length > 1 ? `${currentParlay[0].player}/${currentParlay[1].player}` : currentParlay[0].player
            ) || 'Unnamed Parlay';
            
            // Prompt for bet amount
            const betAmountStr = prompt('How much are you betting?', '100');
            const betAmount = parseFloat(betAmountStr) || 100;
            
            // Calculate combined odds
            let combinedDecimalOdds = 1;
            let combinedProb = 1;
            
            currentParlay.forEach(bet => {
                const odds = bet.odds;
                const decimalOdds = odds > 0 ? (odds / 100) + 1 : (100 / Math.abs(odds)) + 1;
                combinedDecimalOdds *= decimalOdds;
                
                const prob = parseFloat(bet.hit_rate || bet.adjusted_projection || '50') / 100;
                combinedProb *= prob;
            });
            
            const americanOdds = combinedDecimalOdds >= 2 ? 
                Math.round((combinedDecimalOdds - 1) * 100) : 
                Math.round(-100 / (combinedDecimalOdds - 1));
            
            // CORRELATION DETECTION
            const players = currentParlay.map(bet => bet.player);
            const uniquePlayers = [...new Set(players)];
            const isSamePlayer = uniquePlayers.length === 1 && currentParlay.length > 1;
            const hasDuplicatePlayers = uniquePlayers.length < players.length;
            
            // Detect same-game parlays (game bets or props with team info)
            const teams = currentParlay.map(bet => {
                // Extract team from player name or use team field
                if (bet.is_game_bet) return bet.player; // Team name for game bets
                // For player props, we'd need to track team separately (enhancement for later)
                return null;
            }).filter(Boolean);
            const uniqueTeams = [...new Set(teams)];
            const isSameGame = uniqueTeams.length > 0 && uniqueTeams.length <= 2 && currentParlay.length > 1;
            
            // Calculate correlation penalty
            let correlationPenalty = 0;
            let correlationWarning = '';
            
            if (isSamePlayer) {
                correlationPenalty = 0.25; // 25% reduction for same-player parlays
                correlationWarning = '‚ö†Ô∏è Same-player parlay: High correlation detected';
            } else if (hasDuplicatePlayers) {
                correlationPenalty = 0.15; // 15% reduction for duplicate players
                correlationWarning = '‚ö†Ô∏è Multiple legs on same player(s): Moderate correlation';
            } else if (isSameGame) {
                correlationPenalty = 0.10; // 10% reduction for same-game parlays
                correlationWarning = '‚ö†Ô∏è Same-game parlay: Correlation likely';
            }
            
            // Adjusted probability accounting for correlation
            const naiveProbability = (combinedProb * 100).toFixed(1);
            const adjustedProbability = Math.max(5, combinedProb * 100 * (1 - correlationPenalty)).toFixed(1);
            
            const savedParlays = JSON.parse(localStorage.getItem('savedParlays') || '[]');
            
            const parlayToSave = {
                name: parlayName,
                timestamp: new Date().toISOString(),
                legs: JSON.parse(JSON.stringify(currentParlay)), // Deep copy
                odds: americanOdds,
                probability: naiveProbability,
                adjustedProbability: adjustedProbability,
                correlationPenalty: correlationPenalty,
                correlationWarning: correlationWarning,
                isSamePlayer: isSamePlayer,
                hasDuplicatePlayers: hasDuplicatePlayers,
                isSameGame: isSameGame,
                legCount: currentParlay.length,
                betAmount: betAmount,
                result: null, // Will be filled when results are entered
                legsHit: null,
                payout: null,
                profit: null,
                resultDate: null
            };
            
            savedParlays.push(parlayToSave);
            localStorage.setItem('savedParlays', JSON.stringify(savedParlays));
            
            let alertMessage = `‚úÖ Parlay saved for tracking!\n\n"${parlayName}"\n${currentParlay.length} legs ‚Ä¢ ${americanOdds > 0 ? '+' : ''}${americanOdds} odds`;
            
            if (correlationWarning) {
                alertMessage += `\n\n${correlationWarning}\nNaive probability: ${naiveProbability}%\nAdjusted probability: ${adjustedProbability}%`;
            } else {
                alertMessage += `\nProbability: ${naiveProbability}%`;
            }
            
            alertMessage += '\n\nGo to Results tab to enter results after games finish.';
            
            alert(alertMessage);
            
            // Clear current parlay
            currentParlay = [];
            localStorage.setItem('currentParlay', JSON.stringify(currentParlay));
            updateParlayDisplay();
        }
        
        function updateResultsDisplay() {
            const trackedBets = JSON.parse(localStorage.getItem('trackedBets') || '[]');
            const pendingBets = trackedBets.filter(b => b.status === 'pending');
            const completedBets = trackedBets.filter(b => b.status === 'complete');
            
            // Stats are now handled by updateStatsDisplay() which includes ALL sources
            // No longer calculating stats here - just display pending/recent from old system
            
            // Update pending list
            const pendingList = document.getElementById('pending-results-list');
            if (!pendingList) return;
            
            if (pendingBets.length === 0) {
                pendingList.innerHTML = '<p style="color: #78350f; font-style: italic; margin: 0;">No pending bets. Add bets from Parlay Builder!</p>';
            } else {
                pendingList.innerHTML = pendingBets.map(parlay => `
                    <div style="background: white; border: 1px solid #fbbf24; border-radius: 6px; padding: 15px; margin-bottom: 10px;">
                        <div style="font-weight: 600; margin-bottom: 10px; color: #92400e;">
                            ${parlay.legs.length}-Leg Parlay - ${parlay.date}
                        </div>
                        ${parlay.legs.map((leg, idx) => `
                            <div style="padding: 10px; background: #fef3c7; border-radius: 4px; margin-bottom: 8px;">
                                <div style="font-weight: 600; margin-bottom: 8px; font-size: 14px;">
                                    Leg ${idx + 1}: ${leg.player} ${leg.is_game_bet ? '' : leg.bet} ${leg.line} ${leg.prop_type}
                                </div>
                                <div style="font-size: 13px; color: #78350f; margin-bottom: 8px;">
                                    Projection: ${leg.projection} | Odds: ${leg.odds > 0 ? '+' : ''}${leg.odds}
                                </div>
                                ${leg.is_game_bet ? `
                                    <div style="display: flex; gap: 10px; align-items: center;">
                                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; padding: 6px 12px; background: white; border: 2px solid #10b981; border-radius: 6px;">
                                            <input type="radio" name="result_${parlay.id}_${idx}" value="yes" onchange="updateLegResult(${parlay.id}, ${idx}, 'yes')">
                                            <span style="font-weight: 600; color: #059669;">YES ‚úÖ</span>
                                        </label>
                                        <label style="display: flex; align-items: center; gap: 5px; cursor: pointer; padding: 6px 12px; background: white; border: 2px solid #ef4444; border-radius: 6px;">
                                            <input type="radio" name="result_${parlay.id}_${idx}" value="no" onchange="updateLegResult(${parlay.id}, ${idx}, 'no')">
                                            <span style="font-weight: 600; color: #dc2626;">NO ‚ùå</span>
                                        </label>
                                    </div>
                                ` : `
                                    <div style="display: flex; gap: 10px; align-items: center;">
                                        <label style="font-size: 13px; color: #78350f; font-weight: 600;">Actual result:</label>
                                        <input type="number" step="0.1" placeholder="Enter ${leg.prop_type}" 
                                            style="padding: 8px 12px; border: 2px solid #fbbf24; border-radius: 6px; width: 120px; font-size: 14px; font-weight: 600;"
                                            onchange="updateLegResult(${parlay.id}, ${idx}, this.value)">
                                    </div>
                                `}
                            </div>
                        `).join('')}
                        <button onclick="completeParlayTracking(${parlay.id})" 
                            style="margin-top: 10px; padding: 12px 20px; background: #10b981; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; width: 100%; font-size: 15px;"
                            onmouseover="this.style.background='#059669'" 
                            onmouseout="this.style.background='#10b981'">
                            ‚úÖ Save Results
                        </button>
                    </div>
                `).join('');
            }
            
            // Update recent results
            const recentList = document.getElementById('recent-results-list');
            if (!recentList) return;
            
            if (completedBets.length === 0) {
                recentList.innerHTML = '<p style="color: #6b7280; font-style: italic; margin: 0;">No results yet. Start tracking your bets!</p>';
            } else {
                recentList.innerHTML = completedBets.slice(-10).reverse().map(parlay => `
                    <div style="background: ${parlay.result === 'won' ? '#d1fae5' : '#fee2e2'}; border-left: 4px solid ${parlay.result === 'won' ? '#10b981' : '#ef4444'}; border-radius: 6px; padding: 15px; margin-bottom: 10px;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <div style="flex: 1;">
                                <div style="font-weight: 600; font-size: 16px; color: ${parlay.result === 'won' ? '#065f46' : '#991b1b'};">
                                    ${parlay.result === 'won' ? '‚úÖ WON' : '‚ùå LOST'} - ${parlay.legs.length}-Leg Parlay
                                </div>
                                <div style="font-size: 13px; color: #666; margin-top: 4px;">
                                    ${parlay.date} | Stake: $${parlay.stake || 0} | P/L: <strong style="color: ${parlay.profit >= 0 ? '#10b981' : '#ef4444'};">${parlay.profit >= 0 ? '+' : ''}$${(parlay.profit || 0).toFixed(2)}</strong>
                                </div>
                            </div>
                        </div>
                        <div style="font-size: 13px; color: #374151; line-height: 1.6;">
                            ${parlay.legs.map(leg => `
                                ‚Ä¢ ${leg.player} ${leg.line} ${leg.prop_type}: ${leg.result === 'hit' ? '<strong style="color: #10b981;">‚úÖ HIT</strong>' : '<strong style="color: #ef4444;">‚ùå MISS</strong>'} 
                                ${!leg.is_game_bet && leg.actual_value !== null ? `(Actual: <strong>${leg.actual_value}</strong>)` : ''}
                            `).join('<br>')}
                        </div>
                    </div>
                `).join('');
            }
        }
        
        function updateLegResult(parlayId, legIndex, value) {
            const trackedBets = JSON.parse(localStorage.getItem('trackedBets') || '[]');
            const parlay = trackedBets.find(b => b.id === parlayId);
            
            if (!parlay) return;
            
            const leg = parlay.legs[legIndex];
            
            if (leg.is_game_bet) {
                leg.result = value === 'yes' ? 'hit' : 'miss';
            } else {
                leg.actual_value = parseFloat(value);
                const line = parseFloat(leg.line);
                
                if (leg.bet === 'OVER' || leg.bet === 'YES') {
                    leg.result = leg.actual_value > line ? 'hit' : 'miss';
                } else {
                    leg.result = leg.actual_value < line ? 'hit' : 'miss';
                }
            }
            
            localStorage.setItem('trackedBets', JSON.stringify(trackedBets));
        }
        
        function completeParlayTracking(parlayId) {
            const trackedBets = JSON.parse(localStorage.getItem('trackedBets') || '[]');
            const parlay = trackedBets.find(b => b.id === parlayId);
            
            if (!parlay) return;
            
            const allResultsEntered = parlay.legs.every(leg => leg.result !== null);
            
            if (!allResultsEntered) {
                alert('‚ö†Ô∏è Please enter results for all legs before saving!');
                return;
            }
            
            const allLegsHit = parlay.legs.every(leg => leg.result === 'hit');
            parlay.result = allLegsHit ? 'won' : 'lost';
            
            const stake = prompt('Enter your stake amount (e.g., 100):', '100');
            if (!stake || isNaN(stake)) return;
            
            parlay.stake = parseFloat(stake);
            
            if (allLegsHit) {
                let combinedOdds = 1;
                parlay.legs.forEach(leg => {
                    const decimalOdds = leg.odds > 0 ? (leg.odds / 100) + 1 : (100 / Math.abs(leg.odds)) + 1;
                    combinedOdds *= decimalOdds;
                });
                
                const americanOdds = combinedOdds >= 2 ? (combinedOdds - 1) * 100 : -100 / (combinedOdds - 1);
                const payout = americanOdds > 0 ? (parlay.stake * (americanOdds / 100)) : (parlay.stake / (Math.abs(americanOdds) / 100));
                
                parlay.payout = payout;
                parlay.profit = payout;
            } else {
                parlay.payout = 0;
                parlay.profit = -parlay.stake;
            }
            
            parlay.status = 'complete';
            
            localStorage.setItem('trackedBets', JSON.stringify(trackedBets));
            updateResultsDisplay();
            
            alert(`‚úÖ Results saved!\n\nParlay ${allLegsHit ? 'WON' : 'LOST'}\nP/L: ${parlay.profit >= 0 ? '+' : ''}$${parlay.profit.toFixed(2)}`);
        }
        
        function savePendingParlay() {
            if (currentParlay.length === 0) {
                alert('No parlay to save!');
                return;
            }
            
            // Ask for parlay name
            const defaultName = currentParlay.map(b => b.player.split(' ').pop()).join('/');
            const parlayName = prompt(
                `Give this parlay a name (for easy reference):\n\n` +
                `${currentParlay.length} legs:\n` +
                currentParlay.map(b => `‚Ä¢ ${b.player} ${b.bet} ${b.line}`).join('\n'),
                defaultName
            );
            
            if (!parlayName) return; // Cancelled
            
            // Calculate odds
            const americanOdds = currentParlay.map(b => parseInt(b.odds));
            const decimalOdds = americanOdds.map(odds => 
                odds > 0 ? (odds / 100) + 1 : (100 / Math.abs(odds)) + 1
            );
            const totalDecimal = decimalOdds.reduce((a, b) => a * b, 1);
            const totalAmerican = totalDecimal >= 2 ? Math.round((totalDecimal - 1) * 100) : Math.round(-100 / (totalDecimal - 1));
            
            // Calculate hit probability (assuming independence)
            const hitRates = currentParlay.map(b => parseFloat(b.hit_rate) / 100);
            const combinedProb = hitRates.reduce((a, b) => a * b, 1) * 100;
            
            // Save to pending
            const pending = {
                id: Date.now(),
                name: parlayName,
                timestamp: new Date().toISOString(),
                legs: [...currentParlay],
                totalOdds: totalAmerican,
                legCount: currentParlay.length,
                probability: combinedProb.toFixed(1)
            };
            
            pendingParlays.push(pending);
            localStorage.setItem('pendingParlays', JSON.stringify(pendingParlays));
            
            // Clear current parlay
            currentParlay = [];
            localStorage.setItem('currentParlay', JSON.stringify(currentParlay));
            
            // Update displays
            updateParlayDisplay();
            updatePendingParlaysDisplay();
            
            alert(`‚úÖ Parlay saved!\n\n"${parlayName}"\n${pending.legCount} legs at ${totalAmerican > 0 ? '+' : ''}${totalAmerican}\n\nYou can now build another parlay. Come back later to mark this one as WIN/LOSS.`);
        }
        
        function copyLegToCurrentParlay(parlayId, legIndex) {
            const parlay = pendingParlays.find(p => p.id === parlayId);
            if (!parlay) {
                alert('Parlay not found!');
                return;
            }
            
            const leg = parlay.legs[legIndex];
            if (!leg) {
                alert('Leg not found!');
                return;
            }
            
            // Check if already in current parlay
            const alreadyExists = currentParlay.some(b => 
                b.player === leg.player && 
                b.prop_type === leg.prop_type && 
                b.line === leg.line
            );
            
            if (alreadyExists) {
                alert(`${leg.player} ${leg.bet} ${leg.line} is already in Current Parlay`);
                return;
            }
            
            // Copy leg to current parlay
            currentParlay.push({...leg});
            localStorage.setItem('currentParlay', JSON.stringify(currentParlay));
            updateParlayDisplay();
            
            // Show success and switch to parlay builder
            const successMsg = document.createElement('div');
            successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #22c55e; color: white; padding: 15px 20px; border-radius: 8px; font-weight: bold; z-index: 9999; box-shadow: 0 4px 6px rgba(0,0,0,0.1);';
            successMsg.textContent = `‚úÖ Copied ${leg.player} to Current Parlay`;
            document.body.appendChild(successMsg);
            
            setTimeout(() => {
                successMsg.remove();
            }, 3000);
            
            showTab('parlay');
        }
        
        function copyHistoryLegToCurrentParlay(parlayId, legIndex) {
            const parlay = trackedParlays.find(p => p.id === parlayId);
            if (!parlay) {
                alert('Parlay not found!');
                return;
            }
            
            const leg = parlay.legs[legIndex];
            if (!leg) {
                alert('Leg not found!');
                return;
            }
            
            // Check if already in current parlay
            const alreadyExists = currentParlay.some(b => 
                b.player === leg.player && 
                b.prop_type === leg.prop_type && 
                b.line === leg.line
            );
            
            if (alreadyExists) {
                alert(`${leg.player} ${leg.bet} ${leg.line} is already in Current Parlay`);
                return;
            }
            
            // Copy leg to current parlay
            currentParlay.push({...leg});
            localStorage.setItem('currentParlay', JSON.stringify(currentParlay));
            updateParlayDisplay();
            
            // Show success and switch to parlay builder
            const successMsg = document.createElement('div');
            successMsg.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #22c55e; color: white; padding: 15px 20px; border-radius: 8px; font-weight: bold; z-index: 9999; box-shadow: 0 4px 6px rgba(0,0,0,0.1);';
            successMsg.textContent = `‚úÖ Copied ${leg.player} to Current Parlay`;
            document.body.appendChild(successMsg);
            
            setTimeout(() => {
                successMsg.remove();
            }, 3000);
            
            showTab('parlay');
        }
        
        function updatePendingParlaysDisplay() {
            const container = document.getElementById('pending-parlays-list');
            
            if (pendingParlays.length === 0) {
                container.innerHTML = `
                    <p style="color: #9ca3af; text-align: center; padding: 20px; font-style: italic;">
                        No pending parlays. Build a parlay and click "Save Parlay for Later"
                    </p>
                `;
                return;
            }
            
            const sorted = [...pendingParlays].reverse(); // Most recent first
            container.innerHTML = sorted.map(parlay => {
                const probability = parlay.probability || 'N/A';
                const probColor = parseFloat(probability) >= 50 ? '#059669' : parseFloat(probability) >= 30 ? '#d97706' : '#dc2626';
                
                return `
                <div style="background: #fef3c7; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #f59e0b;">
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                        <div style="flex: 1;">
                            <strong style="font-size: 16px;">${parlay.name}</strong><br>
                            <small style="color: #92400e;">
                                ${parlay.legCount} legs ‚Ä¢ ${parlay.totalOdds > 0 ? '+' : ''}${parlay.totalOdds} odds ‚Ä¢ 
                                <strong style="color: ${probColor};">${probability}% chance</strong> ‚Ä¢ 
                                ${new Date(parlay.timestamp).toLocaleDateString()}
                            </small>
                        </div>
                    </div>
                    
                    <div style="font-size: 13px; margin-bottom: 10px;">
                        ${parlay.legs.map((leg, legIndex) => `
                            <div style="padding: 8px; background: white; border-radius: 4px; margin-bottom: 4px;">
                                <div style="display: flex; justify-content: space-between; align-items: start;">
                                    <div style="flex: 1;">
                                        <strong>${leg.player}</strong> ${leg.bet} ${leg.line} ${leg.prop_type}
                                        <br><small style="color: #6b7280;">Projection: ${leg.adjusted_projection} | ${leg.odds > 0 ? '+' : ''}${leg.odds} | ${leg.hit_rate}% hit rate</small>
                                    </div>
                                    <button onclick="copyLegToCurrentParlay(${parlay.id}, ${legIndex})" 
                                            style="padding: 4px 8px; background: #8b5cf6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; white-space: nowrap; margin-left: 8px;"
                                            title="Copy this leg to Current Parlay">
                                        üìã Copy
                                    </button>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                        <button onclick="trackPendingParlay(${parlay.id}, 'win')" style="padding: 10px; background: #10b981; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 13px;">
                            ‚úÖ WIN
                        </button>
                        <button onclick="trackPendingParlay(${parlay.id}, 'loss')" style="padding: 10px; background: #ef4444; color: white; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; font-size: 13px;">
                            ‚ùå LOSS
                        </button>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button onclick="editPendingParlay(${parlay.id})" style="padding: 10px; background: #8b5cf6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px;">
                            ‚úèÔ∏è Edit
                        </button>
                        <button onclick="deletePendingParlay(${parlay.id})" style="padding: 10px; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 13px;">
                            üóëÔ∏è Delete
                        </button>
                    </div>
                </div>
            `}).join('');
        }
        
        function trackPendingParlay(parlayId, result) {
            const parlay = pendingParlays.find(p => p.id === parlayId);
            if (!parlay) {
                alert('Parlay not found!');
                return;
            }
            
            // Ask for actual results for each leg
            const legsWithActuals = [];
            const voidedLegs = [];
            let allActualsProvided = true;
            
            for (let bet of parlay.legs) {
                const response = prompt(
                    `${bet.player} ${bet.bet} ${bet.line} ${bet.prop_type}\n\n` +
                    `Projection: ${bet.adjusted_projection}\n\n` +
                    `Enter actual result:\n` +
                    `‚Ä¢ Type the number (e.g., "21" if they scored 21)\n` +
                    `‚Ä¢ Type "VOID" if player didn't play\n` +
                    `‚Ä¢ Leave blank if unknown`
                );
                
                if (response && response.trim().toUpperCase() === 'VOID') {
                    // Leg was voided (player didn't play)
                    voidedLegs.push(bet.player);
                    legsWithActuals.push({
                        ...bet,
                        actualResult: undefined,
                        voided: true
                    });
                } else {
                    legsWithActuals.push({
                        ...bet,
                        actualResult: response && !isNaN(parseFloat(response)) ? parseFloat(response) : undefined,
                        voided: false
                    });
                    
                    if (!response || isNaN(parseFloat(response))) {
                        allActualsProvided = false;
                    }
                }
            }
            
            // Calculate adjusted odds if legs were voided
            const activeLegs = legsWithActuals.filter(leg => !leg.voided);
            let adjustedOdds = parlay.totalOdds;
            
            if (voidedLegs.length > 0) {
                // Recalculate odds with voided legs removed
                const activeLegOdds = activeLegs.map(leg => {
                    const odds = parseInt(leg.odds);
                    return odds > 0 ? (odds / 100) + 1 : (100 / Math.abs(odds)) + 1;
                });
                const totalDecimal = activeLegOdds.reduce((a, b) => a * b, 1);
                adjustedOdds = totalDecimal >= 2 ? Math.round((totalDecimal - 1) * 100) : Math.round(-100 / (totalDecimal - 1));
            }
            
            // Save to parlay history
            const trackedParlay = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                name: parlay.name,
                legs: legsWithActuals,
                result: result,
                legCount: parlay.legCount,
                activeLegs: activeLegs.length,
                voidedLegs: voidedLegs,
                originalOdds: parlay.totalOdds,
                adjustedOdds: adjustedOdds
            };
            
            trackedParlays.push(trackedParlay);
            localStorage.setItem('parlayTracking', JSON.stringify(trackedParlays));
            
            // Add individual legs to ML training data (skip voided legs)
            let mlTrainingCount = 0;
            for (let leg of legsWithActuals) {
                // Don't train on voided legs
                if (!leg.voided && leg.actualResult !== undefined) {
                    // Ask if this leg should be excluded from ML
                    const excludeFromML = confirm(
                        `‚ö†Ô∏è ML Training for ${leg.player}\n\n` +
                        `Actual: ${leg.actualResult}\n` +
                        `Projection: ${leg.adjusted_projection}\n\n` +
                        `Exclude from ML if:\n` +
                        `‚Ä¢ Early injury (Q1-Q2)\n` +
                        `‚Ä¢ Ejection\n` +
                        `‚Ä¢ Surprise benching\n` +
                        `‚Ä¢ Other outlier\n\n` +
                        `OK = EXCLUDE | Cancel = INCLUDE`
                    );
                    
                    trackedBets.push({
                        id: Date.now() + Math.random(),
                        timestamp: new Date().toISOString(),
                        player: leg.player,
                        propType: leg.prop_type,
                        line: leg.line,
                        side: leg.bet,
                        projection: parseFloat(leg.adjusted_projection),
                        result: (leg.is_alt_line ? 
                            (leg.bet === 'OVER' ? leg.actualResult >= leg.line : leg.actualResult <= leg.line) :
                            (leg.bet === 'OVER' ? leg.actualResult > leg.line : leg.actualResult < leg.line)) ? 'win' : 'loss',
                        actualResult: leg.actualResult,
                        excludeFromML: excludeFromML,
                        fromParlay: true,
                        parlayName: parlay.name
                    });
                    
                    if (!excludeFromML) {
                        mlTrainingCount++;
                    }
                }
            }
            
            localStorage.setItem('betTracking', JSON.stringify(trackedBets));
            
            // Remove from pending
            pendingParlays = pendingParlays.filter(p => p.id !== parlayId);
            localStorage.setItem('pendingParlays', JSON.stringify(pendingParlays));
            
            // Update displays
            updatePendingParlaysDisplay();
            updateParlayHistory();
            updateTrackingDisplay();
            
            // Check if we should retrain ML
            const completeData = trackedBets.filter(b => b.actualResult !== undefined).length;
            if (completeData >= 10 && mlTrainingCount > 0) {
                setTimeout(() => {
                    trainMLModel().then(success => {
                        if (success) {
                            console.log('ü§ñ ML model retrained with parlay data!');
                        }
                    });
                }, 100);
            }
            
            // Show success message
            let message = `‚úÖ "${parlay.name}" tracked as ${result.toUpperCase()}!\n\n`;
            
            if (voidedLegs.length > 0) {
                message += `‚ö†Ô∏è ${voidedLegs.length} leg(s) VOIDED:\n`;
                message += voidedLegs.map(name => `‚Ä¢ ${name}`).join('\n') + '\n\n';
                message += `Parlay adjusted: ${parlay.legCount}-leg ‚Üí ${activeLegs.length}-leg\n`;
                message += `Odds adjusted: ${parlay.totalOdds > 0 ? '+' : ''}${parlay.totalOdds} ‚Üí ${adjustedOdds > 0 ? '+' : ''}${adjustedOdds}\n\n`;
            }
            
            message += `Active legs: ${activeLegs.length}\n`;
            message += `ML Training Data: ${mlTrainingCount}/${activeLegs.length} legs\n\n`;
            
            if (mlTrainingCount < legsWithActuals.length) {
                message += `‚ö†Ô∏è Enter actual results for all legs to maximize ML learning!`;
            } else if (completeData >= 10) {
                message += `ü§ñ ML model will use this data to improve!`;
            } else {
                message += `‚è≥ ${10 - completeData} more data points needed to train ML`;
            }
            
            alert(message);
        }
        
        function editPendingParlay(parlayId) {
            const parlay = pendingParlays.find(p => p.id === parlayId);
            if (!parlay) {
                alert('Parlay not found!');
                return;
            }
            
            // Confirm edit
            if (!confirm(`Edit "${parlay.name}"?\n\nThis will load it into the Current Parlay builder. You can add/remove legs, then save again.`)) {
                return;
            }
            
            // Load parlay legs into current parlay
            currentParlay = [...parlay.legs];
            localStorage.setItem('currentParlay', JSON.stringify(currentParlay));
            
            // Remove from pending
            pendingParlays = pendingParlays.filter(p => p.id !== parlayId);
            localStorage.setItem('pendingParlays', JSON.stringify(pendingParlays));
            
            // Update displays
            updateParlayDisplay();
            updatePendingParlaysDisplay();
            
            // Switch to Parlay Builder tab
            showTab('parlay');
            
            alert(`‚úèÔ∏è Parlay loaded!\n\n"${parlay.name}" is now in Current Parlay.\n\nYou can:\n‚Ä¢ Add more legs from Manual Entry\n‚Ä¢ Remove legs with Remove buttons\n‚Ä¢ Save when ready`);
        }
        
        function deletePendingParlay(parlayId) {
            const parlay = pendingParlays.find(p => p.id === parlayId);
            if (!parlay) return;
            
            if (!confirm(`Delete "${parlay.name}" from pending parlays?`)) return;
            
            pendingParlays = pendingParlays.filter(p => p.id !== parlayId);
            localStorage.setItem('pendingParlays', JSON.stringify(pendingParlays));
            updatePendingParlaysDisplay();
        }
        
        function trackParlayResultDirect(result) {
            // This is the old immediate tracking function
            trackParlayResult(result);
        }
        
        function trackParlayResult(result) {
            if (currentParlay.length === 0) {
                alert('No parlay to track!');
                return;
            }
            
            // Ask for actual results for each leg
            const legsWithActuals = [];
            let allActualsProvided = true;
            
            for (let bet of currentParlay) {
                const actual = prompt(
                    `Enter ${bet.player}'s actual ${bet.prop_type}:\n\n` +
                    `Projection was: ${bet.adjusted_projection}\n` +
                    `(Leave blank if you don't know)`
                );
                
                legsWithActuals.push({
                    ...bet,
                    actualResult: actual && !isNaN(parseFloat(actual)) ? parseFloat(actual) : undefined
                });
                
                if (!actual || isNaN(parseFloat(actual))) {
                    allActualsProvided = false;
                }
            }
            
            // Save parlay to history
            const parlay = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                legs: legsWithActuals,
                result: result,
                legCount: currentParlay.length
            };
            
            trackedParlays.push(parlay);
            localStorage.setItem('parlayTracking', JSON.stringify(trackedParlays));
            
            // Add individual legs to ML training data if actuals provided
            let mlTrainingCount = 0;
            for (let leg of legsWithActuals) {
                if (leg.actualResult !== undefined) {
                    trackedBets.push({
                        id: Date.now() + Math.random(),
                        timestamp: new Date().toISOString(),
                        player: leg.player,
                        propType: leg.prop_type,
                        line: leg.line,
                        side: leg.bet,
                        projection: parseFloat(leg.adjusted_projection),
                        result: (leg.is_alt_line ? 
                            (leg.bet === 'OVER' ? leg.actualResult >= leg.line : leg.actualResult <= leg.line) :
                            (leg.bet === 'OVER' ? leg.actualResult > leg.line : leg.actualResult < leg.line)) ? 'win' : 'loss',
                        actualResult: leg.actualResult,
                        fromParlay: true
                    });
                    mlTrainingCount++;
                }
            }
            
            localStorage.setItem('betTracking', JSON.stringify(trackedBets));
            
            // Clear current parlay
            currentParlay = [];
            localStorage.setItem('currentParlay', JSON.stringify(currentParlay));
            
            // Update displays
            updateParlayDisplay();
            updateParlayHistory();
            updateTrackingDisplay();
            
            // Check if we should retrain ML
            const completeData = trackedBets.filter(b => b.actualResult !== undefined).length;
            if (completeData >= 10 && mlTrainingCount > 0) {
                setTimeout(() => {
                    trainMLModel().then(success => {
                        if (success) {
                            console.log('ü§ñ ML model retrained with parlay data!');
                        }
                    });
                }, 100);
            }
            
            // Show success message
            let message = `‚úÖ Parlay tracked as ${result.toUpperCase()}!\n\n`;
            message += `${legsWithActuals.length}-leg parlay\n`;
            message += `ML Training Data: ${mlTrainingCount}/${legsWithActuals.length} legs\n\n`;
            
            if (mlTrainingCount < legsWithActuals.length) {
                message += `‚ö†Ô∏è Enter actual results for all legs to maximize ML learning!`;
            } else if (completeData >= 10) {
                message += `ü§ñ ML model will use this data to improve!`;
            } else {
                message += `‚è≥ ${10 - completeData} more data points needed to train ML`;
            }
            
            alert(message);
        }
        
        function updateParlayHistory() {
            const historyContainer = document.getElementById('parlay-history-list');
            
            if (trackedParlays.length === 0) {
                historyContainer.innerHTML = `
                    <p style="color: #9ca3af; text-align: center; padding: 20px; font-style: italic;">
                        No parlays tracked yet
                    </p>
                `;
                return;
            }
            
            const sorted = [...trackedParlays].reverse();
            historyContainer.innerHTML = sorted.map(parlay => {
                const legsWithActuals = parlay.legs.filter(l => l.actualResult !== undefined && !l.voided).length;
                const voidedCount = parlay.legs.filter(l => l.voided).length;
                const hasVoids = voidedCount > 0;
                
                return `
                <div style="background: ${parlay.result === 'win' ? '#d1fae5' : '#fee2e2'}; padding: 15px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid ${parlay.result === 'win' ? '#10b981' : '#ef4444'};">
                    <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                        <div>
                            <strong style="font-size: 16px;">${parlay.legCount}-Leg Parlay ${parlay.result === 'win' ? '‚úÖ' : '‚ùå'}</strong>
                            ${hasVoids ? `<span style="color: #d97706; font-size: 13px;"> (${voidedCount} voided)</span>` : ''}
                            <br>
                            <small style="color: #6b7280;">${new Date(parlay.timestamp).toLocaleDateString()}</small>
                            ${hasVoids ? `<br><small style="color: #d97706;">Adjusted to ${parlay.activeLegs}-leg ‚Ä¢ ${parlay.adjustedOdds > 0 ? '+' : ''}${parlay.adjustedOdds} odds</small>` : ''}
                        </div>
                        <div style="display: flex; gap: 5px;">
                            <button onclick="editParlayResult(${parlay.id})" style="padding: 4px 8px; background: #8b5cf6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">
                                ‚úèÔ∏è Edit
                            </button>
                            <button onclick="deleteParlay(${parlay.id})" style="padding: 4px 8px; background: #9ca3af; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">
                                Delete
                            </button>
                        </div>
                    </div>
                    <div style="font-size: 13px;">
                        ${parlay.legs.map((leg, legIndex) => {
                            let legResult = '‚è≥';
                            let legStyle = '';
                            
                            if (leg.voided) {
                                legResult = '‚äò';
                                legStyle = 'opacity: 0.5; text-decoration: line-through;';
                            } else if (leg.actualResult !== undefined) {
                                const legHit = leg.bet === 'OVER' 
                                    ? leg.actualResult > leg.line 
                                    : leg.actualResult < leg.line;
                                legResult = legHit ? '‚úÖ' : '‚ùå';
                            }
                            
                            return `
                                <div style="padding: 8px; background: white; border-radius: 4px; margin-bottom: 5px; ${legStyle}">
                                    <div style="display: flex; justify-content: space-between; align-items: start;">
                                        <div style="flex: 1;">
                                            ${legResult} <strong>${leg.player}</strong> ${leg.bet} ${leg.line} ${leg.prop_type}
                                            ${leg.voided ? `<br><small style="color: #d97706;">VOID - Player didn't play</small>` : 
                                                leg.actualResult !== undefined ? `<br><small style="color: #6b7280;">Projected: ${leg.adjusted_projection} | Actual: ${leg.actualResult}</small>` : ''}
                                        </div>
                                        ${!leg.voided ? `
                                        <button onclick="copyHistoryLegToCurrentParlay(${parlay.id}, ${legIndex})" 
                                                style="padding: 4px 8px; background: #8b5cf6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px; white-space: nowrap; margin-left: 8px;"
                                                title="Copy this leg to Current Parlay">
                                            üìã Copy
                                        </button>
                                        ` : ''}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                        <div style="margin-top: 10px; font-size: 12px; color: #6b7280;">
                            ${hasVoids ? `‚ö†Ô∏è ${voidedCount} leg(s) voided | ` : ''}
                            ${legsWithActuals === (parlay.activeLegs || parlay.legCount) ? 
                                `ü§ñ All ${parlay.activeLegs || parlay.legCount} active legs used for ML training` : 
                                `‚ö†Ô∏è Only ${legsWithActuals}/${parlay.activeLegs || parlay.legCount} active legs have actual results for ML`
                            }
                        </div>
                    </div>
                </div>
            `}).join('');
        }
        
        function editParlayResult(parlayId) {
            const parlay = trackedParlays.find(p => p.id === parlayId);
            if (!parlay) {
                alert('Parlay not found!');
                return;
            }
            
            const currentResult = parlay.result === 'win' ? 'WIN' : 'LOSS';
            const newResult = confirm(
                `Current result: ${currentResult}\n\n` +
                `Click OK to change to ${currentResult === 'WIN' ? 'LOSS' : 'WIN'}\n` +
                `Click Cancel to keep as ${currentResult}`
            );
            
            if (!newResult) return;
            
            // Toggle the result
            const oldResult = parlay.result;
            parlay.result = parlay.result === 'win' ? 'loss' : 'win';
            
            // Update in storage
            localStorage.setItem('parlayTracking', JSON.stringify(trackedParlays));
            
            // Update displays
            updateParlayHistory();
            updateParlayPerformanceStats();
            
            // Show confirmation
            alert(`‚úÖ Parlay result updated!\n\nChanged from ${oldResult.toUpperCase()} to ${parlay.result.toUpperCase()}\n\n${parlay.legCount}-leg parlay ‚Ä¢ ${new Date(parlay.timestamp).toLocaleDateString()}`);
        }
        
        function deleteParlay(id) {
            if (!confirm('Delete this parlay from history?')) return;
            trackedParlays = trackedParlays.filter(p => p.id !== id);
            localStorage.setItem('parlayTracking', JSON.stringify(trackedParlays));
            updateParlayHistory();
        }
        
        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize sport (defaults to NBA for basketball props)
            switchSport('nba');
            
            // Initialize tracking displays
            updateTrackingDisplay();
            updateParlayDisplay();
            updateParlayHistory();
            updatePendingParlaysDisplay();
            updateParlayPerformanceStats();
            
            // Initialize Results & Tracking stats (includes all 3 data sources)
            updateStatsDisplay();
            updatePendingResultsDisplay();
            updateRecentResultsDisplay();
            
            // Initialize game mode (defaults to manual since API often unavailable)
            if (document.getElementById('mode-manual-btn')) {
                switchGameMode('manual');
            }
            
            console.log('‚úÖ Page initialized - Manual Entry mode active');
        });
        
        // ========================================
        // AI PARLAY BUILDER
        // ========================================
        
        // Helper function to get calibrated hit rate
        function getCalibratedHitRate(rawHitRate) {
            const calibrationFactor = window.hitRateCalibrationFactor;
            
            // Collect bets from all sources for calibration
            const oldBetsWithHitRates = trackedBets.filter(b => 
                b.hit_rate !== null && 
                b.hit_rate !== undefined && 
                b.actualResult !== undefined &&
                !b.excludeFromML
            );
            
            // Get bets from savedParlays
            const savedParlays = JSON.parse(localStorage.getItem('savedParlays') || '[]');
            const newBetsWithHitRates = [];
            savedParlays.filter(p => p.result).forEach(parlay => {
                parlay.legs.forEach(leg => {
                    if (leg.hit_rate && leg.actualResult !== undefined) {
                        newBetsWithHitRates.push(leg);
                    }
                });
            });
            
            const totalBetsWithHitRates = oldBetsWithHitRates.length + newBetsWithHitRates.length;
            
            // Only apply if we have enough data (20+ tracked bets with hit rates)
            if (totalBetsWithHitRates < 20 || !calibrationFactor) {
                return null; // Not enough data for calibration
            }
            
            return rawHitRate * calibrationFactor;
        }
        
        function updateAIPoolDisplay() {
            const poolBetsDiv = document.getElementById('ai-pool-bets');
            const poolCountSpan = document.getElementById('ai-pool-count');
            
            if (!poolBetsDiv || !poolCountSpan) return;
            
            poolCountSpan.textContent = `${aiParlayPool.length} bets`;
            
            if (aiParlayPool.length === 0) {
                poolBetsDiv.innerHTML = `
                    <p style="text-align: center; opacity: 0.7; font-size: 12px; margin: 10px 0;">
                        Analyze bets in Manual Entry to add them to the pool
                    </p>
                `;
                return;
            }
            
            poolBetsDiv.innerHTML = aiParlayPool.map((bet, index) => `
                <div style="background: rgba(255,255,255,0.2); padding: 8px; border-radius: 6px; margin-bottom: 6px; font-size: 11px; display: flex; justify-content: space-between; align-items: center;">
                    <div style="flex: 1;">
                        <strong>${bet.player}</strong> ${bet.bet} ${bet.line} ${bet.prop_type}
                        <div style="opacity: 0.8; font-size: 10px; margin-top: 2px;">
                            Hit: ${bet.hit_rate ? parseFloat(bet.hit_rate).toFixed(1) : '?'}% | 
                            Edge: ${bet.true_edge ? (parseFloat(bet.true_edge) > 0 ? '+' : '') + parseFloat(bet.true_edge).toFixed(1) : '?'}%
                        </div>
                    </div>
                    <button onclick="removeFromAIPool(${index})" style="background: rgba(255,0,0,0.3); border: none; color: white; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 10px;">
                        ‚úï
                    </button>
                </div>
            `).join('');
        }
        
        function addToAIPool(bet) {
            // Check if bet already in pool
            const exists = aiParlayPool.some(b => 
                b.player === bet.player && 
                b.prop_type === bet.prop_type && 
                b.line === bet.line
            );
            
            if (exists) {
                return; // Already in pool, silently skip
            }
            
            aiParlayPool.push(bet);
            localStorage.setItem('aiParlayPool', JSON.stringify(aiParlayPool));
            updateAIPoolDisplay();
        }
        
        function removeFromAIPool(index) {
            aiParlayPool.splice(index, 1);
            localStorage.setItem('aiParlayPool', JSON.stringify(aiParlayPool));
            updateAIPoolDisplay();
        }
        
        function clearAIPool() {
            if (!confirm('Clear all bets from AI Pool?')) return;
            aiParlayPool = [];
            localStorage.setItem('aiParlayPool', JSON.stringify(aiParlayPool));
            updateAIPoolDisplay();
            document.getElementById('ai-recommendations').style.display = 'none';
        }
        
        function buildOptimalParlays(legCount) {
            // Special handling for 1-leg (singles)
            if (legCount === 1) {
                if (aiParlayPool.length === 0) {
                    alert(`‚ùå No analyzed bets in the pool!\n\nAnalyze bets in Manual Entry first.`);
                    return;
                }
                
                console.log('Building 1-leg picks from pool:', aiParlayPool);
                
                // For singles, just rank all bets by EV
                const singles = aiParlayPool.map(leg => {
                    const hitRate = parseFloat(leg.hit_rate || 50);
                    const odds = parseInt(leg.odds);
                    const trueEdge = parseFloat(leg.true_edge || 0);
                    
                    // Calculate EV
                    const decimalOdds = odds > 0 ? (odds / 100) + 1 : (100 / Math.abs(odds)) + 1;
                    const payout = decimalOdds * 100 - 100;
                    const ev = (hitRate / 100) * payout - ((100 - hitRate) / 100) * 100;
                    
                    console.log(`${leg.player}: Hit=${hitRate}%, Odds=${odds}, EV=${ev.toFixed(2)}`);
                    
                    return {
                        legs: [leg],
                        combinedProb: hitRate,
                        rawCombinedProb: hitRate,
                        totalAmerican: odds,
                        trueEdge: trueEdge,
                        ev: ev,
                        avgLegEdge: trueEdge,
                        legNames: leg.player,
                        correlationWarning: null,
                        correlationFactor: 1.0,
                        minHitRate: hitRate,
                        avgHitRate: hitRate,
                        qualityScore: ev,
                        hasLowConfidenceLeg: hitRate < 65,
                        hasVeryLowConfidenceLeg: hitRate < 55,
                        hasSameGame: false
                    };
                });
                
                // Sort by EV
                singles.sort((a, b) => b.ev - a.ev);
                
                console.log('Top singles by EV:', singles.slice(0, 5).map(s => `${s.legNames}: $${s.ev.toFixed(2)}`));
                
                // Display top 10 singles - BYPASS quality filter check
                displayAIRecommendations(singles.slice(0, 10), 1);
                return;
            }
            
            // Special handling for 5+ legs
            if (legCount >= 5) {
                if (aiParlayPool.length < 5) {
                    alert(`‚ùå Need at least 5 analyzed bets for 5+ leg parlays!\n\nYou have ${aiParlayPool.length}. Analyze more bets first.`);
                    return;
                }
                
                // Limit to max 7 legs to avoid combinatorial explosion
                const maxLegs = Math.min(7, aiParlayPool.length);
                const allParlays = [];
                
                // Generate parlays for 5, 6, and 7 legs
                for (let size = 5; size <= maxLegs; size++) {
                    const combinations = [];
                    
                    function generateCombinations(arr, targetSize, start = 0, current = []) {
                        if (current.length === targetSize) {
                            combinations.push([...current]);
                            return;
                        }
                        
                        // Limit combinations to prevent browser freeze
                        if (combinations.length > 100) return;
                        
                        for (let i = start; i < arr.length; i++) {
                            current.push(arr[i]);
                            generateCombinations(arr, targetSize, i + 1, current);
                            current.pop();
                        }
                    }
                    
                    generateCombinations(aiParlayPool, size);
                    
                    // Add size info to each combination
                    combinations.forEach(combo => {
                        allParlays.push({combo, size});
                    });
                }
                
                // Calculate metrics for all combinations
                const parlays = allParlays.map(({combo: legs, size}) => {
                    // Same calculation as normal parlays...
                    const players = legs.map(l => l.player);
                    const uniquePlayers = [...new Set(players)];
                    const hasSamePlayer = uniquePlayers.length < legs.length;
                    
                    const rawHitRates = legs.map(leg => parseFloat(leg.hit_rate || 50));
                    const calibratedHitRates = rawHitRates.map(rate => {
                        const calibrated = getCalibratedHitRate(rate);
                        return (calibrated || rate) / 100;
                    });
                    let combinedProb = calibratedHitRates.reduce((a, b) => a * b, 1) * 100;
                    const rawCombinedProb = rawHitRates.reduce((a, b) => a * (b / 100), 1) * 100;
                    
                    let correlationWarning = null;
                    let correlationFactor = 1.0;
                    
                    if (hasSamePlayer) {
                        correlationWarning = '‚ö†Ô∏è Same Player - Highly Correlated';
                        correlationFactor = 0.85;
                        combinedProb *= correlationFactor;
                    }
                    
                    const americanOdds = legs.map(leg => parseInt(leg.odds));
                    const decimalOdds = americanOdds.map(odds => 
                        odds > 0 ? (odds / 100) + 1 : (100 / Math.abs(odds)) + 1
                    );
                    const totalDecimal = decimalOdds.reduce((a, b) => a * b, 1);
                    const totalAmerican = totalDecimal >= 2 ? Math.round((totalDecimal - 1) * 100) : Math.round(-100 / (totalDecimal - 1));
                    
                    const impliedProb = totalAmerican > 0 
                        ? 100 / (totalAmerican + 100)
                        : Math.abs(totalAmerican) / (Math.abs(totalAmerican) + 100);
                    const trueEdge = combinedProb - (impliedProb * 100);
                    
                    const payout = totalDecimal * 100 - 100;
                    const ev = (combinedProb / 100) * payout - ((100 - combinedProb) / 100) * 100;
                    
                    const avgLegEdge = legs.reduce((sum, leg) => sum + parseFloat(leg.true_edge || 0), 0) / legs.length;
                    
                    // Calculate quality metrics (same as normal parlays)
                    const minHitRate = Math.min(...rawHitRates);
                    const avgHitRate = rawHitRates.reduce((a, b) => a + b, 0) / rawHitRates.length;
                    const hasLowConfidenceLeg = rawHitRates.some(r => r < 65);
                    const hasVeryLowConfidenceLeg = rawHitRates.some(r => r < 55);
                    const avgConfidenceTooLow = avgHitRate < 67;
                    
                    // Calculate quality score
                    let qualityScore = ev;
                    if (hasVeryLowConfidenceLeg) qualityScore -= 50;
                    else if (hasLowConfidenceLeg) qualityScore -= 25;
                    if (avgConfidenceTooLow) qualityScore -= 15;
                    if (hasSamePlayer) qualityScore -= 10;
                    if (minHitRate < 60) qualityScore -= 30;
                    
                    return {
                        legs,
                        combinedProb,
                        rawCombinedProb,
                        totalAmerican,
                        trueEdge,
                        ev,
                        avgLegEdge,
                        legNames: legs.map(l => l.player).join(' + '),
                        correlationWarning,
                        correlationFactor,
                        legCount: size,
                        minHitRate,
                        avgHitRate,
                        qualityScore,
                        hasLowConfidenceLeg,
                        hasVeryLowConfidenceLeg,
                        hasSameGame: hasSamePlayer // Using same player as proxy for same game
                    };
                });
                
                parlays.sort((a, b) => b.ev - a.ev);
                displayAIRecommendations(parlays.slice(0, 5), legCount);
                return;
            }
            
            // Normal handling for 2, 3, 4 legs
            if (aiParlayPool.length < legCount) {
                alert(`‚ùå Need at least ${legCount} analyzed bets in the pool!\n\nYou have ${aiParlayPool.length}. Analyze more bets in Manual Entry first.`);
                return;
            }
            
            // Generate all combinations of size legCount
            const combinations = [];
            
            function generateCombinations(arr, size, start = 0, current = []) {
                if (current.length === size) {
                    combinations.push([...current]);
                    return;
                }
                
                for (let i = start; i < arr.length; i++) {
                    current.push(arr[i]);
                    generateCombinations(arr, size, i + 1, current);
                    current.pop();
                }
            }
            
            generateCombinations(aiParlayPool, legCount);
            
            // Calculate metrics for each combination
            const parlays = combinations.map(legs => {
                // Detect correlations
                const samePlayer = legs.length === legs.filter((leg, i, arr) => 
                    arr.findIndex(l => l.player === leg.player) === i
                ).length === false;
                
                const players = legs.map(l => l.player);
                const uniquePlayers = [...new Set(players)];
                const hasSamePlayer = uniquePlayers.length < legs.length;
                
                // NEW: Detect same-game parlays (check if opponents match)
                const opponents = legs.map(l => l.opponent).filter(o => o);
                const uniqueOpponents = [...new Set(opponents)];
                const hasSameGame = opponents.length > 0 && uniqueOpponents.length < opponents.length;
                
                // NEW: Check individual leg quality
                const rawHitRates = legs.map(leg => parseFloat(leg.hit_rate || 50));
                const minHitRate = Math.min(...rawHitRates);
                const avgHitRate = rawHitRates.reduce((a, b) => a + b, 0) / rawHitRates.length;
                
                // NEW: Quality flags
                const hasLowConfidenceLeg = minHitRate < 65; // Any leg under 65%
                const hasVeryLowConfidenceLeg = minHitRate < 55; // Any leg under 55%
                const avgConfidenceTooLow = avgHitRate < 70; // Average under 70%
                
                // Calculate combined probability with calibration
                const calibratedHitRates = rawHitRates.map(rate => {
                    const calibrated = getCalibratedHitRate(rate);
                    return (calibrated || rate) / 100; // Use calibrated if available, otherwise raw
                });
                let combinedProb = calibratedHitRates.reduce((a, b) => a * b, 1) * 100;
                const rawCombinedProb = rawHitRates.reduce((a, b) => a * (b / 100), 1) * 100;
                
                // Apply correlation adjustments
                let correlationWarning = null;
                let correlationFactor = 1.0;
                
                if (hasSamePlayer) {
                    // Same player, different lines - HIGHLY correlated
                    correlationWarning = '‚ö†Ô∏è Same Player - Highly Correlated';
                    correlationFactor = 0.85; // Reduce combined prob by 15%
                    combinedProb *= correlationFactor;
                }
                
                // NEW: Same-game correlation
                if (hasSameGame && !hasSamePlayer) {
                    correlationWarning = '‚ö†Ô∏è Same Game - Correlated';
                    correlationFactor = 0.90; // Reduce combined prob by 10%
                    combinedProb *= correlationFactor;
                }
                
                // Calculate parlay odds
                const americanOdds = legs.map(leg => parseInt(leg.odds));
                const decimalOdds = americanOdds.map(odds => 
                    odds > 0 ? (odds / 100) + 1 : (100 / Math.abs(odds)) + 1
                );
                const totalDecimal = decimalOdds.reduce((a, b) => a * b, 1);
                const totalAmerican = totalDecimal >= 2 ? Math.round((totalDecimal - 1) * 100) : Math.round(-100 / (totalDecimal - 1));
                
                // Calculate expected value using CALIBRATED probability
                const impliedProb = totalAmerican > 0 
                    ? 100 / (totalAmerican + 100)
                    : Math.abs(totalAmerican) / (Math.abs(totalAmerican) + 100);
                const trueEdge = combinedProb - (impliedProb * 100);
                
                // Calculate EV per $100 using CALIBRATED probability
                const payout = totalDecimal * 100 - 100;
                const ev = (combinedProb / 100) * payout - ((100 - combinedProb) / 100) * 100;
                
                // Average true edge of legs
                const avgLegEdge = legs.reduce((sum, leg) => sum + parseFloat(leg.true_edge || 0), 0) / legs.length;
                
                // NEW: Calculate quality score (penalize risky parlays)
                let qualityScore = ev;
                
                // Penalties:
                if (hasVeryLowConfidenceLeg) qualityScore -= 50; // Severe penalty
                else if (hasLowConfidenceLeg) qualityScore -= 25; // Moderate penalty
                
                if (avgConfidenceTooLow) qualityScore -= 15;
                if (hasSameGame) qualityScore -= 10; // Correlation risk
                if (minHitRate < 60) qualityScore -= 30; // Very risky leg
                
                return {
                    legs,
                    combinedProb,
                    rawCombinedProb,
                    totalAmerican,
                    trueEdge,
                    ev,
                    avgLegEdge,
                    legNames: legs.map(l => l.player).join(' + '),
                    correlationWarning,
                    correlationFactor,
                    minHitRate,
                    avgHitRate,
                    qualityScore,
                    hasLowConfidenceLeg,
                    hasVeryLowConfidenceLeg,
                    hasSameGame
                };
            });
            
            // Sort by QUALITY SCORE (not just EV)
            parlays.sort((a, b) => (b.qualityScore || 0) - (a.qualityScore || 0));
            
            // Apply different filters based on leg count
            let recommendable;
            
            if (legCount === 1) {
                // For singles, be more lenient - show anything with positive EV
                recommendable = parlays.filter(p => p.ev > 0);
            } else if (legCount === 2) {
                // For 2-legs, moderate standards
                recommendable = parlays.filter(p => {
                    return !p.hasVeryLowConfidenceLeg && // No leg under 55%
                           p.minHitRate >= 60 && // All legs at least 60%
                           p.avgHitRate >= 65 && // Average at least 65%
                           p.ev > 0; // Positive EV
                });
            } else if (legCount >= 3) {
                // For 3+ legs, STRICT standards (you're 0/21, need better picks)
                recommendable = parlays.filter(p => {
                    return !p.hasVeryLowConfidenceLeg && // No leg under 55%
                           !p.hasLowConfidenceLeg && // No leg under 65% 
                           p.minHitRate >= 68 && // All legs at least 68%
                           p.avgHitRate >= 70 && // Average at least 70%
                           !p.hasSameGame && // No same-game parlays
                           p.combinedProb >= 25 && // At least 25% combined
                           p.ev > 20; // Strong positive EV
                });
            }
            
            // If no recommendable parlays found, show warning but also show top 3 anyway for analysis
            if (recommendable.length === 0) {
                console.log(`No parlays met quality standards for ${legCount}-leg. Showing top 3 for analysis.`);
                recommendable = parlays.slice(0, 3);
            }
            
            // Display top 5 recommendations (or top 10 for singles)
            const displayCount = legCount === 1 ? 10 : 5;
            displayAIRecommendations(recommendable.slice(0, displayCount), legCount);
        }
        
        function displayAIRecommendations(parlays, legCount) {
            const recommendationsDiv = document.getElementById('ai-recommendations');
            const listDiv = document.getElementById('ai-recommendations-list');
            
            if (!recommendationsDiv || !listDiv) return;
            
            recommendationsDiv.style.display = 'block';
            
            if (parlays.length === 0) {
                listDiv.innerHTML = `
                    <p style="text-align: center; color: #ef4444; padding: 20px; background: #fee2e2; border-radius: 8px; border: 2px solid #f87171;">
                        <strong>‚ö†Ô∏è No Quality Parlays Found!</strong><br>
                        <span style="font-size: 12px; margin-top: 5px; display: block;">
                            All combinations failed quality checks. Individual legs may have:<br>
                            ‚Ä¢ Hit rates under 60%<br>
                            ‚Ä¢ High variance/volatility<br>
                            ‚Ä¢ Negative expected value<br>
                            <br>
                            Try analyzing more high-confidence bets first.
                        </span>
                    </p>
                `;
                return;
            }
            
            listDiv.innerHTML = parlays.map((parlay, index) => {
                // 5-Star Rating System based on EV and Hit Rate
                let stars = 1;
                let ratingLabel = 'Low Confidence';
                let ratingColor = '#ef4444'; // Red
                
                // Calculate stars based on EV
                if (parlay.ev > 60) {
                    stars = 5;
                    ratingLabel = 'Exceptional';
                    ratingColor = '#059669'; // Dark green
                } else if (parlay.ev > 40) {
                    stars = 4;
                    ratingLabel = 'High Confidence';
                    ratingColor = '#10b981'; // Green
                } else if (parlay.ev > 20) {
                    stars = 3;
                    ratingLabel = 'Moderate Confidence';
                    ratingColor = '#3b82f6'; // Blue
                } else if (parlay.ev > 5) {
                    stars = 2;
                    ratingLabel = 'Low Confidence';
                    ratingColor = '#f59e0b'; // Orange
                } else {
                    stars = 1;
                    ratingLabel = 'Very Low Confidence';
                    ratingColor = '#ef4444'; // Red
                }
                
                // Adjust stars down if hit rate is low (for multi-leg parlays)
                if (legCount > 1 && parlay.combinedProb < 30 && stars > 2) {
                    stars = Math.max(2, stars - 1);
                    ratingLabel = 'Moderate Confidence (Low Hit Rate)';
                }
                
                // Generate star display
                const starDisplay = '‚≠ê'.repeat(stars) + '‚òÜ'.repeat(5 - stars);
                const rating = `${starDisplay} ${ratingLabel}`;
                
                // Determine label based on leg count
                const actualLegCount = parlay.legCount || legCount;
                const parlayLabel = legCount === 1 ? 'Single Bet' : 
                                   legCount >= 5 ? `${actualLegCount}-Leg Parlay` :
                                   `${legCount}-Leg Parlay`;
                
                // Quality indicators
                const qualityBadges = [];
                if (parlay.minHitRate >= 70) qualityBadges.push('<span style="background: #10b981; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 5px;">‚úì High Confidence</span>');
                if (parlay.hasSameGame) qualityBadges.push('<span style="background: #f59e0b; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 5px;">‚ö†Ô∏è Same Game</span>');
                if (parlay.correlationWarning) qualityBadges.push('<span style="background: #ef4444; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 5px;">‚ö†Ô∏è Correlated</span>');
                if (parlay.minHitRate < 65 && legCount >= 3) qualityBadges.push('<span style="background: #dc2626; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; margin-left: 5px;">‚ùå Low Confidence</span>');
                
                return `
                    <div style="background: white; border: 2px solid ${ratingColor}; border-radius: 10px; padding: 15px; margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <div>
                                <h4 style="margin: 0 0 5px 0; color: #1f2937; font-size: 14px;">
                                    Rank ${index + 1}: ${parlayLabel} ${qualityBadges.join('')}
                                </h4>
                                <div style="font-size: 12px; font-weight: bold; color: ${ratingColor};">
                                    ${rating}
                                </div>
                            </div>
                            <button onclick="saveAIParlayToBuilder(${index})" style="background: #8b5cf6; color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600;">
                                üíæ Save This Parlay
                            </button>
                        </div>
                        
                        ${parlay.legs.map(leg => `
                            <div style="background: #f9fafb; padding: 8px; border-radius: 6px; margin-bottom: 6px; font-size: 12px;">
                                <strong>${leg.player}</strong> ${leg.bet} ${leg.line} ${leg.prop_type}
                                <div style="color: #6b7280; font-size: 11px; margin-top: 2px;">
                                    Projection: ${leg.adjusted_projection} | Odds: ${leg.odds > 0 ? '+' : ''}${leg.odds} | 
                                    Hit: <strong style="color: #3b82f6;">${parseFloat(leg.hit_rate).toFixed(1)}%</strong> | 
                                    Edge: <strong style="color: ${parseFloat(leg.true_edge) > 0 ? '#10b981' : '#ef4444'};">${parseFloat(leg.true_edge) > 0 ? '+' : ''}${parseFloat(leg.true_edge).toFixed(1)}%</strong>
                                </div>
                            </div>
                        `).join('')}
                        
                        <div style="background: #f3f4f6; padding: 10px; border-radius: 6px; margin-top: 10px; font-size: 12px;">
                            ${parlay.correlationWarning ? `
                            <div style="background: #fef3c7; border-left: 3px solid #f59e0b; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-size: 11px; color: #92400e;">
                                ${parlay.correlationWarning}
                                <div style="font-size: 10px; margin-top: 3px; opacity: 0.9;">
                                    Probability adjusted ${(parlay.correlationFactor * 100).toFixed(0)}% to account for correlation between legs
                                </div>
                            </div>
                            ` : ''}
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; text-align: center;">
                                <div>
                                    <div style="color: #6b7280; font-size: 10px; margin-bottom: 2px;">COMBINED PROB</div>
                                    <div style="font-weight: bold; color: #1f2937;">${parlay.combinedProb.toFixed(1)}%</div>
                                    ${parlay.rawCombinedProb !== parlay.combinedProb ? `<div style="font-size: 9px; color: #9ca3af; text-decoration: line-through;">${parlay.rawCombinedProb.toFixed(1)}%</div>` : ''}
                                </div>
                                <div>
                                    <div style="color: #6b7280; font-size: 10px; margin-bottom: 2px;">ODDS</div>
                                    <div style="font-weight: bold; color: #1f2937;">${parlay.totalAmerican > 0 ? '+' : ''}${parlay.totalAmerican}</div>
                                </div>
                                <div>
                                    <div style="color: #6b7280; font-size: 10px; margin-bottom: 2px;">EV PER $100</div>
                                    <div style="font-weight: bold; color: ${parlay.ev > 0 ? '#10b981' : '#ef4444'};">${parlay.ev > 0 ? '+' : ''}$${parlay.ev.toFixed(2)}</div>
                                </div>
                            </div>
                            <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #d1d5db; text-align: center; color: #6b7280; font-size: 11px;">
                                True Edge: <strong style="color: ${parlay.trueEdge > 0 ? '#10b981' : '#ef4444'};">${parlay.trueEdge > 0 ? '+' : ''}${parlay.trueEdge.toFixed(1)}%</strong> | 
                                Avg Leg Edge: <strong>${parlay.avgLegEdge > 0 ? '+' : ''}${parlay.avgLegEdge.toFixed(1)}%</strong>
                            </div>
                            <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #d1d5db; display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; text-align: center; font-size: 11px; color: #6b7280;">
                                <div>
                                    <div style="font-size: 9px; margin-bottom: 2px;">MIN HIT RATE</div>
                                    <div style="font-weight: bold; color: ${(parlay.minHitRate || parlay.combinedProb) >= 70 ? '#10b981' : (parlay.minHitRate || parlay.combinedProb) >= 60 ? '#f59e0b' : '#ef4444'};">
                                        ${(parlay.minHitRate || parlay.combinedProb).toFixed(1)}%
                                    </div>
                                </div>
                                <div>
                                    <div style="font-size: 9px; margin-bottom: 2px;">AVG HIT RATE</div>
                                    <div style="font-weight: bold; color: ${(parlay.avgHitRate || parlay.combinedProb) >= 75 ? '#10b981' : (parlay.avgHitRate || parlay.combinedProb) >= 65 ? '#f59e0b' : '#ef4444'};">
                                        ${(parlay.avgHitRate || parlay.combinedProb).toFixed(1)}%
                                    </div>
                                </div>
                                <div>
                                    <div style="font-size: 9px; margin-bottom: 2px;">QUALITY SCORE</div>
                                    <div style="font-weight: bold; color: ${(parlay.qualityScore || 0) > 30 ? '#10b981' : (parlay.qualityScore || 0) > 0 ? '#f59e0b' : '#ef4444'};">
                                        ${(parlay.qualityScore || 0).toFixed(1)}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Add calibration notice if applied
            const calibrationFactor = window.hitRateCalibrationFactor;
            if (calibrationFactor && calibrationFactor !== 1) {
                listDiv.innerHTML += `
                    <div style="background: #eff6ff; border: 2px solid #3b82f6; border-radius: 8px; padding: 12px; margin-top: 10px;">
                        <div style="font-size: 12px; color: #1e40af; font-weight: bold; margin-bottom: 4px;">
                            üìä Calibration Applied
                        </div>
                        <div style="font-size: 11px; color: #475569;">
                            Probabilities adjusted by ${(calibrationFactor * 100).toFixed(1)}% based on your ${trackedBets.filter(b => b.hit_rate && b.actualResult && !b.excludeFromML).length} tracked bets.
                            ${calibrationFactor < 0.9 ? 'Tool was over-confident, probabilities lowered to match reality.' : 'Tool was under-confident, probabilities increased.'}
                        </div>
                    </div>
                `;
            }
            
            // Store current recommendations for saving
            window.currentAIRecommendations = parlays;
            
            // Scroll to recommendations
            recommendationsDiv.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        function saveAIParlayToBuilder(index) {
            if (!window.currentAIRecommendations || !window.currentAIRecommendations[index]) {
                alert('Error: Parlay not found');
                return;
            }
            
            const parlay = window.currentAIRecommendations[index];
            
            // Clear current parlay
            currentParlay = [];
            
            // Add all legs
            parlay.legs.forEach(leg => {
                currentParlay.push({...leg});
            });
            
            localStorage.setItem('currentParlay', JSON.stringify(currentParlay));
            updateParlayDisplay();
            
            // Show success message
            alert(`‚úÖ AI Parlay Saved!\n\n${parlay.legNames}\n\nCombined Probability: ${parlay.combinedProb.toFixed(1)}%\nOdds: ${parlay.totalAmerican > 0 ? '+' : ''}${parlay.totalAmerican}\nExpected Value: $${parlay.ev.toFixed(2)} per $100\n\nScroll down to see in Current Parlay section!`);
            
            // Scroll to current parlay
            document.getElementById('parlay-list-container').scrollIntoView({ behavior: 'smooth' });
        }
        
        // Initialize AI pool display on page load
        document.addEventListener('DOMContentLoaded', () => {
            updateAIPoolDisplay();
            
            // Blowout Risk Warning Updater (Alt Lines Analyzer)
            const updateBlowoutWarning = () => {
                const spread = parseFloat(document.getElementById('alt-game-spread')?.value || 0);
                const teamFavored = document.getElementById('alt-team-favored')?.value || 'neutral';
                const warningDiv = document.getElementById('blowout-warning');
                
                if (!warningDiv) return;
                
                const isLargeSpread = Math.abs(spread) >= 10;
                const isHugeSpread = Math.abs(spread) >= 15;
                
                if (isLargeSpread && teamFavored === 'player') {
                    let risk, adjustment, message;
                    if (isHugeSpread) {
                        risk = 60;
                        adjustment = -12;
                        message = `‚ö†Ô∏è <strong>HIGH BLOWOUT RISK (${risk}%)</strong><br>Team favored by ${Math.abs(spread)}. Star players often rest in 4th quarter.<br>Projection reduced by ${Math.abs(adjustment)}% to account for limited minutes.`;
                    } else {
                        risk = 40;
                        adjustment = -5;
                        message = `‚ö†Ô∏è <strong>MODERATE BLOWOUT RISK (${risk}%)</strong><br>Team favored by ${Math.abs(spread)}. Some rest risk in blowouts.<br>Projection reduced by ${Math.abs(adjustment)}% as precaution.`;
                    }
                    warningDiv.innerHTML = message;
                    warningDiv.style.display = 'block';
                    warningDiv.style.borderLeft = '3px solid #f59e0b';
                } else if (isLargeSpread && teamFavored === 'opponent') {
                    let risk, adjustment;
                    if (isHugeSpread) {
                        risk = 60;
                        adjustment = -8;
                    } else {
                        risk = 40;
                        adjustment = -3;
                    }
                    warningDiv.innerHTML = `‚ö†Ô∏è <strong>HEAVY UNDERDOG (${Math.abs(spread)} point spread)</strong><br>Player's team likely to be blown out. Limited competitive minutes expected.<br>Projection reduced by ${Math.abs(adjustment)}%.`;
                    warningDiv.style.display = 'block';
                    warningDiv.style.borderLeft = '3px solid #ef4444';
                } else if (Math.abs(spread) > 0 && Math.abs(spread) < 10) {
                    warningDiv.innerHTML = `‚úÖ <strong>LOW BLOWOUT RISK</strong><br>Spread of ${spread > 0 ? '+' : ''}${spread} suggests competitive game. No adjustment needed.`;
                    warningDiv.style.display = 'block';
                    warningDiv.style.borderLeft = '3px solid #10b981';
                } else {
                    warningDiv.style.display = 'none';
                }
            };
            
            // Blowout Risk Warning Updater (Manual Entry)
            const updateManualBlowoutWarning = () => {
                const spread = parseFloat(document.getElementById('manual-game-spread')?.value || 0);
                const teamFavored = document.getElementById('manual-team-favored')?.value || 'neutral';
                const warningDiv = document.getElementById('manual-blowout-warning');
                
                if (!warningDiv) return;
                
                const isLargeSpread = Math.abs(spread) >= 10;
                const isHugeSpread = Math.abs(spread) >= 15;
                
                if (isLargeSpread && teamFavored === 'player') {
                    let risk, adjustment, message;
                    if (isHugeSpread) {
                        risk = 60;
                        adjustment = -12;
                        message = `‚ö†Ô∏è <strong>HIGH BLOWOUT RISK (${risk}%)</strong><br>Team favored by ${Math.abs(spread)}. Star players often rest in 4th quarter.<br>Projection will be reduced by ${Math.abs(adjustment)}% to account for limited minutes.`;
                    } else {
                        risk = 40;
                        adjustment = -5;
                        message = `‚ö†Ô∏è <strong>MODERATE BLOWOUT RISK (${risk}%)</strong><br>Team favored by ${Math.abs(spread)}. Some rest risk in blowouts.<br>Projection will be reduced by ${Math.abs(adjustment)}% as precaution.`;
                    }
                    warningDiv.innerHTML = message;
                    warningDiv.style.display = 'block';
                    warningDiv.style.borderLeft = '3px solid #f59e0b';
                } else if (isLargeSpread && teamFavored === 'opponent') {
                    let risk, adjustment;
                    if (isHugeSpread) {
                        risk = 60;
                        adjustment = -8;
                    } else {
                        risk = 40;
                        adjustment = -3;
                    }
                    warningDiv.innerHTML = `‚ö†Ô∏è <strong>HEAVY UNDERDOG (${Math.abs(spread)} point spread)</strong><br>Player's team likely to be blown out. Limited competitive minutes expected.<br>Projection will be reduced by ${Math.abs(adjustment)}%.`;
                    warningDiv.style.display = 'block';
                    warningDiv.style.borderLeft = '3px solid #ef4444';
                } else if (Math.abs(spread) > 0 && Math.abs(spread) < 10) {
                    warningDiv.innerHTML = `‚úÖ <strong>LOW BLOWOUT RISK</strong><br>Spread of ${spread > 0 ? '+' : ''}${spread} suggests competitive game. No adjustment needed.`;
                    warningDiv.style.display = 'block';
                    warningDiv.style.borderLeft = '3px solid #10b981';
                } else {
                    warningDiv.style.display = 'none';
                }
            };
            
            // Attach listeners for Alt Lines
            document.getElementById('alt-game-spread')?.addEventListener('input', updateBlowoutWarning);
            document.getElementById('alt-team-favored')?.addEventListener('change', updateBlowoutWarning);
            
            // Attach listeners for Manual Entry
            document.getElementById('manual-game-spread')?.addEventListener('input', updateManualBlowoutWarning);
            document.getElementById('manual-team-favored')?.addEventListener('change', updateManualBlowoutWarning);
            
            // Initial update
            updateBlowoutWarning();
            updateManualBlowoutWarning();
        });
        
        // ============================================
        // ANALYTICS DASHBOARD FUNCTIONS
        // ============================================
        
        let monthlyChart, profitTrendChart, calibrationChart;
        let currentAnalyticsPeriod = 'all';
        
        function updateAnalyticsPeriod(period) {
            currentAnalyticsPeriod = period;
            
            // Update button styles
            document.querySelectorAll('.analytics-period-btn').forEach(btn => {
                btn.style.background = '#6b7280';
            });
            document.getElementById(`analytics-period-${period}`).style.background = '#3b82f6';
            
            // Refresh analytics
            updateAnalyticsDashboard();
        }
        
        function updateAnalyticsDashboard() {
            console.log('üìä Updating Analytics Dashboard...');
            
            // Get all parlay data
            const savedParlays = JSON.parse(localStorage.getItem('savedParlays') || '[]').filter(p => p.result);
            const trackedParlaysData = typeof trackedParlays !== 'undefined' ? trackedParlays : [];
            
            // Combine and filter by period
            let allParlays = [...savedParlays, ...trackedParlaysData.map(tp => ({
                name: `${tp.legCount}-Leg Parlay`,
                timestamp: tp.timestamp,
                result: tp.result === 'win' ? 'WON' : 'LOST',
                legs: tp.legs,
                odds: tp.adjustedOdds || tp.odds,
                betAmount: 100,
                profit: calculateProfit(tp)
            }))];
            
            // Filter by time period
            const now = new Date();
            allParlays = allParlays.filter(p => {
                const date = new Date(p.timestamp || p.resultDate);
                if (currentAnalyticsPeriod === 'all') return true;
                if (currentAnalyticsPeriod === '30days') return (now - date) / (1000 * 60 * 60 * 24) <= 30;
                if (currentAnalyticsPeriod === '3months') return (now - date) / (1000 * 60 * 60 * 24) <= 90;
                if (currentAnalyticsPeriod === '6months') return (now - date) / (1000 * 60 * 60 * 24) <= 180;
                return true;
            });
            
            console.log(`Found ${allParlays.length} parlays in period: ${currentAnalyticsPeriod}`);
            
            if (allParlays.length === 0) {
                document.getElementById('analytics-total-parlays').textContent = '0';
                document.getElementById('analytics-win-rate').textContent = '0%';
                document.getElementById('analytics-total-pl').textContent = '$0';
                document.getElementById('analytics-roi').textContent = '0%';
                return;
            }
            
            // Calculate summary stats
            const totalParlays = allParlays.length;
            const wins = allParlays.filter(p => p.result === 'WON').length;
            const winRate = (wins / totalParlays * 100).toFixed(1);
            const totalProfit = allParlays.reduce((sum, p) => sum + (p.profit || 0), 0);
            const totalWagered = allParlays.reduce((sum, p) => sum + (p.betAmount || 100), 0);
            const roi = ((totalProfit / totalWagered) * 100).toFixed(1);
            
            // Update summary cards
            document.getElementById('analytics-total-parlays').textContent = totalParlays;
            document.getElementById('analytics-win-rate').textContent = winRate + '%';
            document.getElementById('analytics-total-pl').textContent = (totalProfit >= 0 ? '+$' : '-$') + Math.abs(totalProfit).toFixed(2);
            document.getElementById('analytics-total-pl').parentElement.style.background = 
                totalProfit >= 0 ? 'linear-gradient(135deg, #10b981 0%, #059669 100%)' : 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)';
            document.getElementById('analytics-roi').textContent = (roi >= 0 ? '+' : '') + roi + '%';
            
            // Generate charts
            generateMonthlyChart(allParlays);
            generateProfitTrendChart(allParlays);
            generatePropTypeStats(allParlays);
            generatePlayerStats(allParlays);
            generateCalibrationChart(allParlays);
        }
        
        function calculateProfit(parlay) {
            const won = parlay.result === 'win';
            const betAmount = 100;
            if (!won) return -betAmount;
            
            const odds = parlay.adjustedOdds || parlay.odds || 0;
            if (odds > 0) return betAmount * (odds / 100);
            if (odds < 0) return betAmount * (100 / Math.abs(odds));
            return 0;
        }
        
        function generateMonthlyChart(parlays) {
            // Group by month
            const monthlyData = {};
            parlays.forEach(p => {
                const date = new Date(p.timestamp || p.resultDate);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[monthKey]) {
                    monthlyData[monthKey] = { wins: 0, losses: 0 };
                }
                if (p.result === 'WON') monthlyData[monthKey].wins++;
                else monthlyData[monthKey].losses++;
            });
            
            // Sort by date
            const sortedMonths = Object.keys(monthlyData).sort();
            const labels = sortedMonths.map(m => {
                const [year, month] = m.split('-');
                return new Date(year, month - 1).toLocaleDateString('en-US', { month: 'short', year: 'numeric' });
            });
            const wins = sortedMonths.map(m => monthlyData[m].wins);
            const losses = sortedMonths.map(m => monthlyData[m].losses);
            
            const ctx = document.getElementById('monthly-chart');
            if (monthlyChart) monthlyChart.destroy();
            
            monthlyChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Wins',
                            data: wins,
                            backgroundColor: '#10b981',
                            borderColor: '#059669',
                            borderWidth: 1
                        },
                        {
                            label: 'Losses',
                            data: losses,
                            backgroundColor: '#ef4444',
                            borderColor: '#dc2626',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { position: 'top' },
                        title: { display: false }
                    },
                    scales: {
                        y: { beginAtZero: true, ticks: { stepSize: 1 } }
                    }
                }
            });
        }
        
        function generateProfitTrendChart(parlays) {
            // Sort by date
            const sorted = [...parlays].sort((a, b) => 
                new Date(a.timestamp || a.resultDate) - new Date(b.timestamp || b.resultDate)
            );
            
            // Calculate cumulative profit
            let cumulative = 0;
            const cumulativeData = sorted.map(p => {
                cumulative += (p.profit || 0);
                return cumulative;
            });
            
            const labels = sorted.map((p, i) => `Bet ${i + 1}`);
            
            const ctx = document.getElementById('profit-trend-chart');
            if (profitTrendChart) profitTrendChart.destroy();
            
            profitTrendChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Cumulative Profit/Loss',
                        data: cumulativeData,
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.1)',
                        fill: true,
                        tension: 0.3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: false },
                        title: { display: false }
                    },
                    scales: {
                        y: { 
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toFixed(0);
                                }
                            }
                        }
                    }
                }
            });
        }
        
        function generatePropTypeStats(parlays) {
            // Extract all legs and group by prop type
            const propTypes = {};
            parlays.forEach(p => {
                if (!p.legs) return;
                p.legs.forEach(leg => {
                    if (leg.voided) return;
                    const propType = leg.prop_type || leg.propType || 'Unknown';
                    if (!propTypes[propType]) {
                        propTypes[propType] = { total: 0, wins: 0 };
                    }
                    propTypes[propType].total++;
                    
                    // Determine if leg hit based on bet type
                    let legHit = false;
                    
                    // Handle YES/NO bets (moneyline, total_over, total_under, spread)
                    if (leg.bet === 'YES' || leg.bet === 'NO') {
                        legHit = leg.actualResult === leg.bet;
                    }
                    // Handle OVER/UNDER bets (player props)
                    else if (leg.bet === 'OVER' || leg.bet === 'UNDER') {
                        legHit = leg.is_alt_line ? 
                            ((leg.bet === 'OVER' && leg.actualResult >= leg.line) || (leg.bet === 'UNDER' && leg.actualResult <= leg.line)) :
                            ((leg.bet === 'OVER' && leg.actualResult > leg.line) || (leg.bet === 'UNDER' && leg.actualResult < leg.line));
                    }
                    
                    if (legHit) propTypes[propType].wins++;
                });
            });
            
            // Sort by total bets
            const sorted = Object.entries(propTypes).sort((a, b) => b[1].total - a[1].total);
            
            let html = '<div style="display: grid; gap: 10px;">';
            sorted.forEach(([type, stats]) => {
                const winRate = (stats.wins / stats.total * 100).toFixed(1);
                const color = winRate >= 60 ? '#10b981' : winRate >= 50 ? '#f59e0b' : '#ef4444';
                html += `
                    <div style="background: white; padding: 12px; border-radius: 8px; border-left: 4px solid ${color};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-weight: 600; color: #374151;">${type}</div>
                                <div style="font-size: 12px; color: #6b7280;">${stats.wins}/${stats.total} legs won</div>
                            </div>
                            <div style="font-size: 24px; font-weight: bold; color: ${color};">${winRate}%</div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            
            document.getElementById('prop-type-stats').innerHTML = html;
        }
        
        function generatePlayerStats(parlays) {
            // Extract all legs and group by player
            const players = {};
            parlays.forEach(p => {
                if (!p.legs) return;
                p.legs.forEach(leg => {
                    if (leg.voided) return;
                    const player = leg.player || 'Unknown';
                    if (!players[player]) {
                        players[player] = { total: 0, wins: 0 };
                    }
                    players[player].total++;
                    
                    // Determine if leg hit based on bet type
                    let legHit = false;
                    
                    // Handle YES/NO bets (moneyline, total_over, total_under, spread)
                    if (leg.bet === 'YES' || leg.bet === 'NO') {
                        legHit = leg.actualResult === leg.bet;
                    }
                    // Handle OVER/UNDER bets (player props)
                    else if (leg.bet === 'OVER' || leg.bet === 'UNDER') {
                        legHit = leg.is_alt_line ? 
                            ((leg.bet === 'OVER' && leg.actualResult >= leg.line) || (leg.bet === 'UNDER' && leg.actualResult <= leg.line)) :
                            ((leg.bet === 'OVER' && leg.actualResult > leg.line) || (leg.bet === 'UNDER' && leg.actualResult < leg.line));
                    }
                    
                    if (legHit) players[player].wins++;
                });
            });
            
            // Sort by total bets, take top 10
            const sorted = Object.entries(players).sort((a, b) => b[1].total - a[1].total).slice(0, 10);
            
            let html = '<div style="display: grid; gap: 10px;">';
            sorted.forEach(([player, stats], index) => {
                const winRate = (stats.wins / stats.total * 100).toFixed(1);
                const color = winRate >= 60 ? '#10b981' : winRate >= 50 ? '#f59e0b' : '#ef4444';
                html += `
                    <div style="background: white; padding: 12px; border-radius: 8px; border-left: 4px solid ${color};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <div style="font-weight: 600; color: #374151;">#${index + 1} ${player}</div>
                                <div style="font-size: 12px; color: #6b7280;">${stats.wins}/${stats.total} legs won</div>
                            </div>
                            <div style="font-size: 24px; font-weight: bold; color: ${color};">${winRate}%</div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            
            document.getElementById('player-stats').innerHTML = html;
        }
        
        function generateCalibrationChart(parlays) {
            // This would need historical calibration data
            // For now, show a placeholder
            const ctx = document.getElementById('calibration-chart');
            if (calibrationChart) calibrationChart.destroy();
            
            // Mock data - in reality, you'd track this over time
            const labels = ['Week 1', 'Week 2', 'Week 3', 'Week 4', 'Current'];
            const calibrationData = [82, 84, 85, 86, 86.1];
            
            calibrationChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Calibration %',
                        data: calibrationData,
                        borderColor: '#8b5cf6',
                        backgroundColor: 'rgba(139, 92, 246, 0.1)',
                        fill: true,
                        tension: 0.3
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: { 
                            min: 70,
                            max: 100,
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                    }
                }
            });
        }
        
    </script>
</body>
</html>
